<div class="s-prose s-prose__disable-spoiler-hover js-post-body" itemprop="text">
<p>With all due respect to solutions offered, the solutions offered here are naive (naive in the sense of something that someone unfamiliar with computer science algorithms would think of). The most optimal solution will most probably be implemented using a dynamic programming approach (at the risk of stating the obvious I must emphasize that dynamic programming is not a language but an algorithmic concept that can be implemented in any language) where the program recursively finds smaller palindromes and combines them into larger ones when possible. The main problem with solutions offered here is that many sub-problems (which are essentially the same) are computed over and over and over and over again (you get the idea).</p>

<p>Actually, I just did a search for this and an elegant solution using dynamic programming is offered <a href="http://www.geeksforgeeks.org/dynamic-programming-set-12-longest-palindromic-subsequence/" rel="nofollow">here</a>. :)</p>
    </div>