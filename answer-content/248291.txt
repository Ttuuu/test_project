<div class="s-prose s-prose__disable-spoiler-hover js-post-body" itemprop="text">
<h1>Avoid converting command line arguments to ASCII</h1>
<p>There is no good reason to convert the command line arguments to ASCII. All the functions you use that take pointers to ASCII strings also have variants that handle wide strings, for example <code>lstrcmpW()</code> and <code>CreateFileW()</code>. This way, you can get rid of  <code>CommandLineToArgvA()</code>.</p>
<h1>Use <code>stderr</code> to report errors</h1>
<p>Consider that it is not unlikely that the user of your <code>cat</code> implementation redirects standard output to another file. If there is an error, instead of printing it to the console, you are writing the error message to that file instead. Just add <code>stderr = GetStdHandle(STD_ERROR_HANDLE)</code>, and use that for the error messages.</p>
<h1>Avoid allocating a buffer as large as each input file</h1>
<p>Disk space is typically at least an order of magnitude larger than RAM. If you want to cat a file larger than the amount of free RAM available, your program will fail. It is better to allocate a buffer with a fixed size of say 64 KiB, and use multiple calls to <code>ReadFile()</code> if necessary to read the input as chunks of up to 64 KiB. On one hand, it means more overhead from multiple calls to <code>ReadFile()</code>, on the other hand you will likely stay within the L2 cache of your CPU. In any case, I expect performance will not be changed dramatically by this, but now your program handles arbitrarily sized files.</p>
<p>This will also simplify your code: you no longer have to get the file size and resize the buffer if necessary. Instead, just read until you reach the <a href="https://docs.microsoft.com/en-us/windows/win32/fileio/testing-for-the-end-of-a-file" rel="nofollow noreferrer">end of the file</a>.</p>
<h1>Use a loop to read from <code>stdin</code> until your reach EOF</h1>
<p>If you specify <code>-</code> as an argument, you read only up to 2048 bytes from <code>stdin</code> before continuing to the next command line argument. And if you don't specify any arguments at all, you have an infinite loop that reads from <code>stdin</code>, even if there is nothing to read anymore.</p>
<p>Keep in mind that <code>stdin</code> might also have been redirected, and will actually read from a file, or reads the output from another program.</p>
<h1>Use the same buffer for <code>stdin</code> as for files</h1>
<p>There's no need to have two separate buffers, as you only handle either a file or <code>stdin</code> at a time. Just ensure it is large enough.</p>
<h1>Handle read and write errors</h1>
<p>Things can go wrong. If there is an error reading a file or writing to <code>stdout</code>, you should print an error message to <code>stderr</code> and then immediately exit with a non-zero exit code. This will notify the user of errors. Also, if your <code>cat</code> implementation is used in a batch script, the non-zero exit code will allow that script to detect the error, instead of blindly continuing with invalid data.</p>
    </div>