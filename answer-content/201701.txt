<div class="s-prose s-prose__disable-spoiler-hover js-post-body" itemprop="text">
<p>I'm assuming in this answer that you have infinite quantities of the designated numbers at your disposal, since that appears to be the way your code works. With that condition, this problem is the <strong><a href="https://projecteuler.net/problem=31" rel="nofollow noreferrer">coin sums problem on Project Euler</a></strong>: given a set of coin denominations, how many ways can change be made for a number?</p>

<p>Looking at your code in terms of efficiency, the top-down recursive function is doing a lot of repeated work because of overlapping subproblems, similar to the <a href="https://www.geeksforgeeks.org/program-for-nth-fibonacci-number/" rel="nofollow noreferrer">recursive Fibonacci problem</a> and is the hallmark of <a href="https://en.wikipedia.org/wiki/Dynamic_programming" rel="nofollow noreferrer">dynamic programming</a>.</p>

<p>The biggest improvement available to you is using a <a href="https://en.wikipedia.org/wiki/Memoization" rel="nofollow noreferrer">memo</a> or cache in the form of an associative array. Memoization makes it possible to keep track of what's already been computed for a given recursive call and avoid recomputations, pruning off huge chunks of the call tree. This effectively turns the exponential <em>O(n<sup>k</sup>)</em> problem into <em>O(nk)</em> <em>[<a href="https://leetcode.com/articles/coin-change/" rel="nofollow noreferrer">source</a>]</em> where <em>k</em> is the number of coins.</p>

<p>There's also a bottom-up iterative version which is an improvement still over the "recursion with cache" version. I recommend adding a cache to your algorithm as above, solving the <a href="https://projecteuler.net/problem=31" rel="nofollow noreferrer">Project Euler problem</a> and spending some time perusing the solution thread that you'll gain access to which contains many imaginative and efficient solutions including these bottom-up versions.</p>

<p>In terms of coding style, there are variables and loops that can be removed. Moving "set up" code out of the recursive call and into a wrapper can save a few conditional checks and eliminate the <code>level</code> variable. Doing an <code>array_search</code> through your coins array and setting used elements to 0 is a bit awkward and can be handled easily by passing an index variable to determine which coins have been used already. The full function header I used has 4 parameters (including the index and a reference to the memo), which makes it nice to wrap.</p>

<p>Lastly, your base case checks need only happen for being out of money. When that happens, either you've made change successfully, or the change you tried to make wasn't valid (you went into negative numbers). No need to test anything else. All told, the whole program can be 30 lines or less.</p>

<p>I'd like to post my PHP code here, but in the spirit of Project Euler, you'll have the most fun if you solve it yourself instead of reading a spoiler! We can compare notes afterwards if you want (although the solutions you'll see in the forum will be far superior).</p>
    </div>