<div class="s-prose s-prose__disable-spoiler-hover js-post-body" itemprop="text">
<p>Three suggestions. </p>

<hr>

<p><a href="https://codereview.stackexchange.com/a/207230/43360">Carciginate</a> repaired the syntax of your <code>gen-primes</code> algorithm. It can, though, be significantly simplified:</p>

<pre><code> (defn gen-primes []
  (letfn [(primes-step [table d]
            (letfn [(reinsert [table prime]
                      (update table (+ prime d) conj prime))]
              (if-let [factors (get table d)]
                (recur (reduce reinsert (dissoc table d) factors)
                       (inc d))
                (lazy-seq (cons d (primes-step
                                    (assoc table (* d d) [d])
                                    (inc d)))))))]
    (primes-step {} 2)))
</code></pre>

<p>What are the changes?</p>

<ul>
<li>Make the <code>reinsert</code> function local to the <code>primes-step</code> function.
This simplifies the <code>reduce</code> considerably.</li>
<li>Replace the oversized <code>update-in</code> with the well-fitting <code>update</code>.</li>
<li>Use vectors instead of a lists as values in the <code>table</code>. Small vectors are fast. </li>
</ul>

<p>Clojure currently handles lexical closures badly, so though the first change makes the program clearer, it probably slows it down a bit too. </p>

<hr>

<pre class="lang-clj prettyprint-override"><code>(defn get-digits [n]
  (-&gt;&gt; n
       (iterate #(quot % 10))
       (take-while pos?)
       (map #(mod % 10))))
</code></pre>

<p>... which is simpler than yours or Carciginate's.  </p>

<p>Down the line, you can probably speed this up using <a href="https://clojure.org/reference/transducers" rel="nofollow noreferrer">transducers</a>:</p>

<pre class="lang-clj prettyprint-override"><code>(defn get-digits [n]
  (sequence
    (comp
       (take-while pos?)
       (map #(mod % 10)))
    (iterate #(quot % 10) n)))
</code></pre>

<ul>
<li>Both <code>take-while</code> and <code>map</code>, given a single function argument,
produce transducers.</li>
<li>These are identical in form to those applied to a sequence by the
<code>-&gt;&gt;</code> (thread last) macro, which has an implicit argument.</li>
<li>The transducers combine by functional composition - <code>comp</code>.</li>
<li>We use <code>sequence</code> to thus transform the initial sequence generated by
<code>iterate</code>.</li>
</ul>

<hr>

<pre><code>(defn are-permutations-of-each-other? [num1 num2]
  (= (frequencies (get-digits num1)) (frequencies (get-digits num2))))
</code></pre>

<p>or</p>

<pre><code>(defn are-permutations-of-each-other? [&amp; nums]
  (-&gt;&gt; nums
       (map (comp frequencies get-digits))
       (apply =)))
</code></pre>

<p>... which might be respectively faster than yours and Cartiginate's. I haven't tested this. </p>
    </div>