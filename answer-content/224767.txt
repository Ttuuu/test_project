<div class="s-prose s-prose__disable-spoiler-hover js-post-body" itemprop="text">
<h2>Small Bias</h2>
<p>First a nit pick, <code>Math.random()</code> generates a number from 0 to &lt; 1. It will never generate 1. Thus to get a statistical odds of 1/2 you must test either <code>Math.random() &lt; 0.5</code> or <code>Math.random() &gt;= 0.5</code>. Testing <code>Math.random() &gt; 0.5 ? char : char.toUpperCase()</code> will give a very (VERY) small bias in favor of upper case characters.</p>
<h2>Dramatic Bias</h2>
<p>Also there is a very strong bias towards numerals in your function with a 0-9 being 2 times more likely than a-z or A-Z</p>
<p>The following snippet counts the occurrence of each character generated by your function and plots them (normalized) on a graph.</p>
<p>I animated it slowly for dramatic effect.</p>
<p></p><div class="snippet" data-lang="js" data-hide="false" data-console="true" data-babel="false">
<div class="snippet-code">
<pre class="snippet-code-js lang-js prettyprint-override"><code>canvas.width = innerWidth - 10;
const ctx = canvas.getContext("2d");
const w = canvas.width;
const h = canvas.height;
const chars = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
var testCount = 2;
const val = new Array(chars.length)
val.fill(0);
const func = randString;
function randString() {
    return [
        ...Math.random()
            .toString(36)
            .substr(2, 5),
    ].map(element =&gt; (Math.random() &gt; 0.5 ? element : element.toUpperCase())).join('');
}
function testRandomness() {
    var i = testCount;
    while (i--) {
        const a = func();
        for (const c of a) {  val[chars.indexOf(c)] += 1 }
    }
    
    const max = Math.max(...val);
    ctx.clearRect(0, 0, w, h);
    const ww = w / val.length;
    i = val.length;
    ctx.fillStyle = "blue";
    while (i--) {
        if (chars[i] === "z") { ctx.fillStyle = "green" }
        if (chars[i] === "9") { ctx.fillStyle = "red" }
        const v = val[i] / max * h;
        ctx.fillRect(i * ww, h - v, ww- 2, v)
    }
    setTimeout(testRandomness, 1000 / 30);
}
testRandomness();
canvas.addEventListener("click",()=&gt; (testCount = 10000,d.textContent = "Sample rate ~300,000per sec") ,{once:true});</code></pre>
<pre class="snippet-code-css lang-css prettyprint-override"><code>body { font-family: arial black; }
canvas {
  padding: 0px;
}
#a { color:red; }
#b { color:green; }
#c { color:blue; }
#d { font-family: arial; }</code></pre>
<pre class="snippet-code-html lang-html prettyprint-override"><code>&lt;canvas id="canvas"&gt;&lt;/canvas&gt;
&lt;span id="a"&gt;Red&lt;/span&gt; 0-9 &lt;span id="b"&gt;Green&lt;/span&gt; a-z &lt;span id="c"&gt;Blue&lt;/span&gt; A-Z &lt;span id="d"&gt;Click graph to increase sample rate to 10000&lt;/span&gt;</code></pre>
</div>
</div>

<p>Click the graph to increase the tests per sample to 10000 per 30th second (approx) and you will see that apart from the numeral bias the graph quickly becomes very flat showing no other major bias (the uppercase bias is way to small to see)</p>
<p>The reason for the bias is that you split the characters a-z in two when you convert half to uppercase.</p>
<p>Also note as pointed out in the other answer, there is a small chance that the returned string is less than 5 characters long.</p>
<h2>Performance</h2>
<p>In terms of performance using a lookup table is around 3 times faster ie calculate 1.5million strings in the time yours calculates 0.5million.</p>
<pre><code>const chars = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
function randString(size = 5) {
    var str = "";
    while (size--) { str += chars[Math.random() * chars.length | 0] }
    return str;
}
</code></pre>
<p>As a function it is much more flexible, and can easily be adapted to include extra characters, or reduced character sets.</p>
<p>If all that matters is performance you can get around 10% faster by avoiding some of the readability introduce overhead with</p>
<pre><code>function randString() {
    return  chars[Math.random() * 62 | 0] +
        chars[Math.random() * 62 | 0] +
        chars[Math.random() * 62 | 0] +
        chars[Math.random() * 62 | 0] +
        chars[Math.random() * 62 | 0];
}
</code></pre>
<p>Or (on chrome) the following is on average 2% faster than the one above but only after it has been run many time so that the optimizer knows what it does. If run only a few time it is slower than above</p>
<pre><code>function randString3() {
    return  `${chars[Math.random()*62|0]}${chars[Math.random()*62|0]}${chars[Math.random()*62|0]}${chars[Math.random()*62|0]}${chars[Math.random()*62|0]}`;
}
</code></pre>
    </div>