<div class="s-prose s-prose__disable-spoiler-hover js-post-body" itemprop="text">
<ol>
<li>You have both <code>IEnumerableStreamSerializer</code> and <code>EnumerableStreamSerializer</code>, and in fact neither of them are used in the code you posted. I'd have just stuck with one or the other (probably the interface, and introduce the base class if you need to share common functionality; alternatively if you need to worry about backwards compatibility with other people implementing it, opt for the abstract base class).</li>
<li>I'm not at all convinced that you need <code>BigInteger</code>. <code>long</code> goes up to <em>nine quintillion</em> - serializing something that large would mean transferring at least 36 exabytes of data (for json, more for xml). That's <a href="https://thenextweb.com/contributors/2017/04/11/current-global-state-internet/#.tnw_8pHvZxpk" rel="noreferrer">more than the entire world transfers over mobile data per month</a>.</li>
<li>Avoid <code>Encoding.Default</code>. It's based on the computer's code page, and will therefore be different across different computers. That's a very bad thing for a serialization library! A sensible, standard choice is <code>Encoding.UTF8</code>.</li>
<li>You've got default parameter values for <code>bufferSize</code> and <code>leaveOpen</code>, but use an overload for <code>encoding</code>. That's inconsistent. Just use <code>Encoding encoding = null</code>, then check for <code>null</code> in your method.</li>
<li>To be honest, I wouldn't make the buffer size configurable personally.</li>
<li>There's no point in having an <code>async</code> method which just does <code>await somethingElse;</code> Just make it non-async and <code>return somethingElse;</code> instead.</li>
<li>Your <code>GetFirstLineAsync</code> implementations will be throwing warnings, as they're <code>async</code> but don't have <code>awaits</code>. You'd be best off making them <code>non-async</code>, and returning a <code>Task.FromResult("whatever")</code>. You'll want to cache this <code>Task</code>, so you'll want a <code>private static readonly Task&lt;string&gt; firstLine = Task.FromResult("whatever")</code> then <code>public Task&lt;string&gt; GetFirstLineAsync() =&gt; firstLine;</code></li>
<li>Ditto <code>GetLastLineAsync()</code></li>
<li>Ditto <code>GetItemLineAsync()</code>, although in this case you can't cache the resulting <code>Task</code>. </li>
<li>That said, do those methods really need to be async? Serializing something is very unlikely to be IO-bound - it's either going to be so cheap it's almost free, or CPU-bound. If it's CPU-bound, you're not going to call <code>Task.Run</code> for <em>each line</em> - that's crazy expensive and of questionable benefit. I'd ditch it - if it becomes expensive and you need to farm it off to another thread for whatever reason, run the entire operation on another thread, not individual lines. With that gone, your entire serializer becomes synchronous which goes against your question, but then your code (being synchronous in reality) goes against your question.</li>
<li>If you're worried about speed, <code>$"{result},"</code> is going to be a bit slower than <code>result + ","</code>, and I'm not sure it's any more readable (of course, with more complex interpolated strings, you might want to take the performance hit for readability). Ditto the other bits of string interpolation. </li>
<li>Missing null-checks on parameters etc, generally, if you care. If you add null-checks to <code>EnumerableExtensions.Detailed</code>, don't forget to move the state machine to a separate private (possibly inner) method.</li>
</ol>
    </div>