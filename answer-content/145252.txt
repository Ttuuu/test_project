<div class="s-prose s-prose__disable-spoiler-hover js-post-body" itemprop="text">
<p>All of the answers given (when this 'answer' was first written) ignore an important constraint: native types.  In C, a <code>long int</code> is a 32-bit (or greater) signed type, meaning the largest positive value that can be (counted upon to be) represented is \$2^{31}-1\$.  The largest possible input to a function which calculates a fourth-power and [[can be counted on to]] return a correct long int would be \$\left\lfloor\sqrt[4]{2^{31}-1}\right\rfloor=215\$.  Even if you move to <code>unsigned long long int</code>, a 64-bit (or greater) unsigned type, \$\left\lfloor\sqrt[4]{2^{64}-1}\right\rfloor=65\,535\$.  Floating-point types wouldn't get you any further: only the mantissa bits are of value because of the precision needed.  (If you have access to a 128-bit type, that would suffice, as \$\left\lfloor\sqrt[4]{2^{128}-1}\right\rfloor=4\,294\,967\,295\$.)</p>

<p>If native types won't fully suffice, you will need a 'big number library' that handles such values.  A word of warning: having to call out to a library will most likely incur a performance hit.</p>

<p>All that said, it may still be possible to write the code <em>mostly</em> with native types (under 128 bits) in such a way as to add and compare with only the lower bits, but you would have to be very careful, and you have the possibility of false-positives.  At that point you could call in the 'big number library' to verify the find.</p>
    </div>