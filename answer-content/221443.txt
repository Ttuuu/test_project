<div class="s-prose s-prose__disable-spoiler-hover js-post-body" itemprop="text">
<p>I don't have the time to analyse all the code. I suggest fixing these issues mentioned here and then reposte the improved version. Then we could take a look at your logic. </p>

<ol>
<li><p><strong>Don't use <code>using namespace std</code></strong> It is considered bad practice. See:
    <a href="https://stackoverflow.com/questions/1452721/why-is-using-namespace-std-considered-bad-practice">https://stackoverflow.com/questions/1452721/why-is-using-namespace-std-considered-bad-practice</a></p></li>
<li><p><strong>Use a namespace.</strong> You should wrap your functions and classes in a namespace to
prevent name clashes if you use other libraries. Like this:</p>

<pre><code>namespace tetris {
    // youre classes and functions
}
</code></pre></li>
<li><strong>One class per File:</strong> You currently put everything into one file. This
way your separation of functions and classes doesn't help at all.
It's recommended to put one class per file.</li>
<li><strong>Separate declarations and implementations.</strong> Separate
your code in header and implementation files. In the header only
declare and include the minimum required. To speed up compilation
use forward declaration.</li>
<li><p><strong>Return as boolean</strong>: This:</p>

<pre><code>bool Table::checkIfPlayerLost()
{
    for (short i = 0; i &lt; 4; i++)
    {
        if (table[actualTile.getcoordX(i)][actualTile.getcoordY(i)] == 1)
        {
            return 0;
        }
    }

    return 1;
}
</code></pre>

<p>Should be this:</p>

<pre><code>bool Table::checkIfPlayerLost()
{
    for (short i = 0; i &lt; 4; i++)
    {
        if (table[actualTile.getcoordX(i)][actualTile.getcoordY(i)] == 1)
        {
            return false;
        }
    }

    return true;
}
</code></pre></li>
<li><p><strong>Use <code>constexpr</code> for constants</strong>. This:</p>

<pre><code>#define numberOfColumns 11 
</code></pre>

<p>Should be this (we are not in C anymore):</p>

<pre><code>static constexpr auto numberOfColumns{11}
</code></pre></li>
<li><strong>Don't use global variables</strong>. They are considered a maintenance hazard.
Try to encapsulate them into a class;</li>
<li><strong>Don't use <code>float</code> or <code>short</code></strong>. by default you should use <code>double</code> and <code>int</code>.
Heres a bit about it:
<a href="https://stackoverflow.com/questions/24371077/when-to-use-short-over-int">https://stackoverflow.com/questions/24371077/when-to-use-short-over-int</a></li>
<li><p><strong>Don't comment whats clear.</strong> For example this:</p>

<pre><code>#define numberOfColumns 11               // number of lines and columns for the game table
#define numberOfLines 21
</code></pre>

<p>Do you see any benefit in this comment? I don't.</p></li>
<li><strong>public before private</strong>. In C++ it's usually common to put the public
 members before the private ones.</li>
<li><strong>Omit <code>return 0</code> in main.</strong> Unlike in old C in C++ <code>return 0</code> is
 automatically generated by the compiler at the end of main.</li>
<li><p><strong>Use C++ container.</strong> This:</p>

<pre><code> class Table : public Drawable           // class that represents the game table 
 {
 private:
    short **table;
    ....
 }

 Table::Table()
 {
    ...
        table[i] = new short[numberOfColumns];
    ...
 }

 Table::~Table()
 {
    for (short i = 0; i &lt; numberOfLines; i++)
    {
        delete[] table[i];
    }
    delete[] table;
 }
</code></pre>

<p>That is so so C. First of all why allocate dynamic arrays here?
 You want a fixed array. So you could just declare a two dimensional
 C array. Since we are in c++ it would be more wise to use
 <code>std::array</code> or <code>std::vector</code> to use as the table representation.
 If you really need to allocate dynamically (here you don't) then
 use smart pointer like <code>std::unique_ptr</code> or <code>std::shared_pointer</code>
 not naked new/delete. They release the memory safely for you</p></li>
<li><p><strong>Use a better random engine.</strong> Since C++11 you should not use this:</p>

<pre><code>     srand((unsigned)(time(&amp;t)));
</code></pre>

<p>Instead use the better random generator from <code>&lt;random&gt;</code> Why? 
 <a href="https://channel9.msdn.com/Events/GoingNative/2013/rand-Considered-Harmful" rel="nofollow noreferrer">https://channel9.msdn.com/Events/GoingNative/2013/rand-Considered-Harmful</a></p></li>
</ol>
    </div>