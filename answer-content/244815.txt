<div class="s-prose s-prose__disable-spoiler-hover js-post-body" itemprop="text">
<h2>Algorithm</h2>
<h3>Correctness</h3>
<p>Due to a small problem in <code>GetBranchPrecedents</code> this algorithm does not actually work. The case that all parents might already be present in the complete order. E.g. take the graph with the edges (C,A), (D,A), (E,A), (D,B), (E,B). In this case, A has the most prerequisites and will be treated first. This puts all nodes but B into the order. Since B has more than one prerequisite, the branch using <code>GetBranchPrecedents</code> is used, where no parent will be evaluated because they are all already in the complete order.</p>
<p>This can easily be fixed by treating this special case inside <code>GetBranchPrecedents</code> or by making the function better honor its name and adding the final node for the project in question outside of it.</p>
<h3>Design and Documentation</h3>
<p>The design of the algorithm seems to be a bit convoluted. This seems to partly originate in a lack of documentation of <code>NonBranchingPath</code>'s purpose. As far as I can see, it is simply a performance optimization to avoid merging single element lists of ancestor paths. This would also explain the switch from a recursive approach to the inclusion of iterative parts. The algorithm itself could have been written entirely without special-casing single parents.</p>
<h3>Performance</h3>
<p>The asymptotic complexity of this algorithm is rather bad. It is at least never better than <code>O(V^2)</code> but might as well only be <code>O(V^3)</code>, where <code>V</code> is the number of projects (vertices); I have not performed a thorough analysis.</p>
<p>The first problem is that the check whether a project already exists in the final order is performed by a <code>Contains</code> on the list containing the final order. Each of these checks is an <code>O(V)</code> operation. By maintaining a <code>HashSet</code> of the already sorted projects, this could be essentially reduced to <code>O(1)</code>.</p>
<p>The second problem is that <code>MergePaths</code> may have to revisit the same nodes a lot and that the <code>Contains</code> check here is on a linked list. The check could be optimized by maintaining a <code>HashSet</code> again. However, there is no easy solution for the other problem. E.g. take a chain of <code>n</code> nodes one depending on the next; let the last one depend on <code>n</code> other nodes, which all depend on one final node. All descendant paths for the final node will contain the first <code>n</code> nodes. Thus, this step is at least quadratic in the number of nodes, even when the number of edges is linear in the number of nodes.</p>
<p>Finally, sorting the elements at the start is not really necessary and leads to a minimum complexity of <code>O(V*log(V))</code>, no matter how few edges there are.</p>
<h3>Alternatives</h3>
<p>There is an alternative approach to this problem, which is also known as topological sorting, that is a bit easier to follow and at the same time achieves an asymptotic complexity of <code>O(V+E)</code>, where <code>V</code> is the number of projects and <code>E</code> the number of prerequisites. I do not want to spoil the answer to how it works here, though. (You can just search for topological sort, if you do not want to figure it out yourself.) I will just give the hint that you should think about which nodes you can add at the start or the build order and what you have to maintain to let the problem look the same, just for a smaller list of projects, after you have added the first element.</p>
<h2>API</h2>
<p>To me, the API is a bit confusing, i.e. the publicly accessible features to not follow a clear line and impose some restrictions, which are not really needed.</p>
<p>The first thing that confused me a bit was that you have a separate class for the dependency edges, while the projects already contains that information. In addition, your functionality takes in both projects and dependencies at the same time. This is confusing because it is not clear which of the dependency information will be taken into account.</p>
<p>I see two ways to make this clearer: either remove the dependency input entirely or remove the dependencies from the projects. In both cases, only one source of dependencies remains ant the API is clearer. In the latter case, you could maintain the dependencies of project information in a dictionary.</p>
<p>You <code>Project</code> classes expose a bit much functionality to the public. All they really need to expose regarding the dependencies is an <code>IReadOnlyCollecion&lt;Project&gt;</code> and a method <code>AddDependency</code> or an <code>ICollection&lt;Project&gt;</code>, if you want to allow deleted as well. There is really no value in the order of the dependencies here. Should that be important for some other external reason, at least consider using the interface <code>IList</code> instead of fixing the concrete implementation.</p>
<p>On a similar note, the constructor for <code>ProjectBuildOrder</code> could just take <code>IEnumerable&lt;T&gt;</code> instances since you just iterate over them once.</p>
<p>In addition, the whole class <code>ProjectBuildOrder</code> would probably be better off as a function or as a strategy class with a single function taking in the current constructor parameters as its parameters. There is no real benefit here in maintaining any information on the class level, except maybe convenience. If information was passed around in a more functional way, it would be possible to use this algorithm on multiple threads in parallel.</p>
<p>Finally, the return type of <code>GenerateBuildOrder</code> could be an <code>IList&lt;Project&gt;</code> and should probably be better names <code>BuildOrder</code>. In general, when naming methods, procedures should be verbs describing what they do and functions and properties should be nouns describing the result.</p>
<h2>General</h2>
<p>I will not write too much in this category, since the review is already long enough. However, I would like to point out that the naming of variables could be improved a bit. In general, it tries to state what the things are, but then slips a bit, which can become confusing. One example of this is the loop variable <code>path</code> in <code>MergePaths</code>, which really should be <code>pathIndex</code> because <code>ll</code> is the actual path. Moreover, using <code>ll</code> for the linked lists everywhere wastes the opportunity to state what the linked list represents. In general, name things after what they represent, not after what they technically are.</p>
    </div>