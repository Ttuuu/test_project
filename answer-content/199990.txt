<div class="s-prose s-prose__disable-spoiler-hover js-post-body" itemprop="text">
<p>Lists are linear in terms of performance. You are iterating original list, which cannot be avoided. But, for each item in original you are iterating the new list looking for a match. This is bad for performance.</p>

<p>You should just add all the new data to a HashSet. Then iterate the original list and check if the HashSet contains that pair.</p>

<p>To use a HashSet, the main thing is the hash function. If the person class can be made to have a hashCode only relating the firstName and the lastName, then you can go with that option. </p>

<p>If not just use a Pair. Its a standard tuple, and one should be available in some of the collections already in your project classpath.</p>

<pre><code>public class PersonsMain {
    public static void main(String[] args) {
        ArrayList&lt;Person&gt; originalPeople = new ArrayList&lt;&gt;();
        ArrayList&lt;Person&gt; newPeople = new ArrayList&lt;&gt;();

        originalPeople.add(new Person("William", "Tyndale", 30));
        originalPeople.add(new Person("Jonathan", "Edwards", 31));
        originalPeople.add(new Person("Martin", "Luther", 32));

        newPeople.add(new Person("Jonathan", "Edwards", 33));
        newPeople.add(new Person("James", "Tyndale", 34));
        newPeople.add(new Person("Roger", "Moore", 35));

        //Prepare
        HashSet&lt;Person&gt; newGuys = new HashSet&lt;&gt;();
        for(Person newPerson:newPeople) {
            newGuys.add(newPerson);
        }

        //Results
        for(Person originalPerson:originalPeople) {
            if(!newGuys.contains(originalPerson)) {
                System.out.println("This person is not in the new list: " 
                        + originalPerson.getFirstName() + " " 
                        + originalPerson.getLastName() );
            }
        }
    }

    static class Person {

        private final String firstName;
        private final String lastName;
        //Extra field age to remind you that it should not be included in hashCode and equals
        private final int age;

        Person(String firstName, String lastName, int age) {
            this.firstName = firstName;
            this.lastName = lastName;
            this.age = age;
        }

        String getFirstName() {
            return firstName;
        }

        public String getLastName() {
            return lastName;
        }


        public int getAge() {
            return age;
        }

        @Override
        public int hashCode() {
            //Auto-generated by Eclipse.
            //Important that this hash code use only the name fields.

            final int prime = 31;
            int result = 1;
            result = prime * result + ((firstName == null) ? 0 : firstName.hashCode());
            result = prime * result + ((lastName == null) ? 0 : lastName.hashCode());
            return result;
        }

        @Override
        public boolean equals(Object obj) {
            //Auto-generated by Eclipse.
            //Important that this hash code use only the name fields.

            if (this == obj)
                return true;
            if (obj == null)
                return false;
            if (getClass() != obj.getClass())
                return false;
            Person other = (Person) obj;
            if (firstName == null) {
                if (other.firstName != null)
                    return false;
            } else if (!firstName.equals(other.firstName))
                return false;
            if (lastName == null) {
                if (other.lastName != null)
                    return false;
            } else if (!lastName.equals(other.lastName))
                return false;
            return true;
        }

    }
}
</code></pre>
    </div>