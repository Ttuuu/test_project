<div class="s-prose s-prose__disable-spoiler-hover js-post-body" itemprop="text">
<p>Other answers correctly point out that using primitive types and not mixing them with Objects (=<code>int</code> instead of <code>Integer</code>), reducing visibility wherever possible (=adding <code>private</code> modifier to <code>position</code> and <code>list</code>) and preventing popping from empty stack are good practices. There are a few more subtleties which can be improved:</p>

<ol>
<li>Rename <code>INCREMENTSIZE</code> to <code>INCREMENT_SIZE</code>. It's customary, when naming constants using full caps, to separate words with underscores.</li>
<li>Consider growing a stack by multiplying current size and start small, e.g. instead having new size be current+increment, make it current*factor, where factor can be 1.5 or 2, or even decreased as the stack grows. If you're implementing a general purpose stack, you don't know how small or large the user will want it to be—incrementing by a constant might be an overkill or too small, while starting small and growing it in multiples will conserve memory if user needs a small stack, and will grow it in large enough increments later on if user needs to store many elements. The two approaches can be mixed and fine-tuned for best performance.</li>
<li>Consider generifying the stack class so it can be a stack of anything, not just Integers. It's a small cost, but can be of large benefit.</li>
<li>If you do store arbitrarily typed objects, beware of memory leaks! The <code>pop</code> function as it stands won't free memory if a user decides to empty the stack. It's a merely unconservative approach when dealing with primitives or small, usually pooled <code>Integer</code>s. It can be a real problem when storing something heavyweight—your stack will keep a reference to something which the user has popped and prevent the garbage collector from collecting it (also see Effective Java 3rd ed., Item 7). To prevent this, when popping an element, set the value of the popped element in array to <code>null</code>; additionally when a considerable proportion of the array is empty, deallocate a portion of it (e.g. using the <code>Arrays.copyOf</code> with a smaller second argument).</li>
<li>Guard against overflows. At some point, <code>list.length + INCREMENTSIZE</code> will overflow, and you'll get <code>NegativeArraySizeException</code> from <code>Arrays#copyOf</code>. Unfortunately, you can't have arrays which are indexed by <code>long</code>s, so best you can do is use <code>Integer.MAX_VALUE</code> as the new size, and throw an exception (e.g. <code>IllegalStateException</code> with a helpful message) if the caller wants to add more items to stack after it's grown to MAX_VALUE. You can see how <code>ArrayDeque#grow(int)</code> and <code>ArrayDeque#newCapacity(int, int)</code> are implemented by OpenJDK <a href="https://github.com/AdoptOpenJDK/openjdk-jdk11/blob/master/src/java.base/share/classes/java/util/ArrayDeque.java#L141" rel="noreferrer">here</a>.</li>
</ol>
    </div>