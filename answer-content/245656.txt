<div class="s-prose s-prose__disable-spoiler-hover js-post-body" itemprop="text">
<p>First issue with this design is that it is going to be slow and non-optimizable. <code>std::function</code> has a couple of features that hide type and implementation and neither is easy to optimize nor cheap. If you make complex functions that run in milliseconds than it is of no problem at all but otherwise consider a different more efficient approach.</p>
<p>Second issue, is that if a function returns <code>std::optional</code> and composed with function that accepts <code>std::optional</code> and does something non-trivial when <code>std::nullopt</code> is supplied then the <code>Maybe</code> composition will change output. I don't think that this is what uses desires.</p>
<p>Also, the naming isn't good <code>Maybe</code>... come up with something more meaningful and intuitive.</p>
<hr>
<p>To deal with the first issue, first look for an inspiration to <code>std::bind</code> as one can see in the <a href="https://en.cppreference.com/w/cpp/utility/functional/bind" rel="nofollow noreferrer">cppreference</a> it doesn't return a <code>std::function</code> but an unspecified type. Why?</p>
<p>One possible implementation is that it returns a lambda that calls the function with the given arguments. That's it. And in this way it is a see-through method which is easily convertible to <code>std::function</code> and other function/method wrappers. (To implement placeholders feature its complexity raises beyond that of just generating a trivial lambda function that forwards arguments.)</p>
<p>Imagine what <code>std::bind</code> would generate if supplementing each argument was done via an operator and converting to a <code>std::function</code> each time - instead of the variadic template approach? That would be a disaster I assure you.</p>
<p>For instance, <code>boost::format</code> uses operators to fill arguments while <code>fmt::format</code> relies on variadic template approach... and as a result <code>fmt::format</code> is considerably faster both in performance and in compilation time. (Can't blame <code>boost::format</code> as it was implemented and designed way before C++11)</p>
<p>So it would be much better if you wrote a template function that generates a callable from a sequence of callable:</p>
<pre><code>template&lt;typename... Collables&gt;
auto compose_callables(Callables...){...}
</code></pre>
<p>This will also allow you to address the second issue about how to properly implement the "optional" feature: suppose you compose <code>f</code> with <code>g</code> to make <code>f(g)</code>. And input type of <code>f</code> is <code>Arg</code> and function <code>g</code> returns output <code>std::optional&lt;Arg&gt;</code> then abort the execution whenever the optional has no value. However, forward the argument as is when the function <code>f</code> accepts the same type that <code>g</code> returns even if it is an <code>std::optional</code> of something.</p>
<p>To implement this properly you'll need to stretch some muscles with template meta programming and SFINEA. This is quite challenging for most C++ programmers. Wish you luck if you attempt to.</p>
    </div>