<div class="s-prose s-prose__disable-spoiler-hover js-post-body" itemprop="text">
<p>If you do not need report progress then the <a href="https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpcontent.loadintobufferasync?view=netcore-3.1" rel="nofollow noreferrer">LoadIntoBuffer</a> <a href="https://github.com/microsoft/referencesource/blob/aaca53b025f41ab638466b1efe569df314f689ea/System/net/System/Net/Http/HttpContent.cs#L276" rel="nofollow noreferrer">source code</a> + <a href="https://docs.microsoft.com/en-us/dotnet/api/system.net.http.httpcontent.copytoasync?view=netcore-3.1" rel="nofollow noreferrer">CopyToAsync</a> <a href="https://github.com/microsoft/referencesource/blob/aaca53b025f41ab638466b1efe569df314f689ea/System/net/System/Net/Http/HttpContent.cs#L276" rel="nofollow noreferrer">source code</a> combo could be handy.</p>
<p>All you need to prevent the concurrent call of the <code>LoadIntoBuffer</code> method. (You can call it n times it does not matter, because the <code>IsBuffered</code> flag will short-cut the method.) This can be done by using a <code>Monitor</code> or a <code>Semaphore</code> for mutual exclusion. Or you can simply use signalling primitives as well, like <code>AutoResetEvent</code>, <code>CountdownEvent</code>.</p>
<p>With <code>CopyToAsync</code> each thread can have its own copy of the stream, so there won't be a shared resource.</p>
    </div>