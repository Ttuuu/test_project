<div class="s-prose s-prose__disable-spoiler-hover js-post-body" itemprop="text">
<p>Based on the code that you've supplied, here's my take on some small changes in responsibility.</p>

<p>First of all, the <code>NSManagedObject</code> subclass. </p>

<p>You can write this by hand (as I think you have done) but I prefer to have Xcode generate this subclass automatically from the <code>xcdatamodeld</code> file (this option is found in the 'Editor' menu). </p>

<p><em>Note that in the latest version of Xcode, this file isn't added to your project, but actually added to the 'DerivedData' folder so unless you go looking for it you'll probably never see it.</em></p>

<p>If you find it and open it up, it will probably look something like this this: </p>

<pre><code>import Foundation
import CoreData

@objc(User)
public class User: NSManagedObject {

    @NSManaged public var name: String?
    @NSManaged public var email: String?
    @NSManaged public var authToken: String?
}
</code></pre>

<p>Second, an extension that contains some methods that are specific to working with JSON objects.</p>

<p>Instead of a class function to create a <code>User</code> object, I'd use a failiable initializer <code>init?()</code> that returns nil if an instance could not be created.</p>

<p>I'd also create some way to reference your string keys so that you're not typing them by hand each time. This could be a struct, or just a bunch of <code>static let</code> statements. I prefer the struct because it puts all the keys in a similar namespace that helps organize your code, but also helps with auto completion when you're typing out the keys.</p>

<pre><code>import SwiftyJSON

extension User {

    // prevent accidental typos when working with string keys
    struct Keys {
        static let name = "name"
        static let email = "email"
        static let authToken = "auth_token"
        static let user = "user"
    }

    // convenience initalizer for making `User` from a JSON object
    convenience init?(in context: NSManagedObjectContext, with json: JSON?) {
        guard let json = json else { return nil }

        email = json[Keys.email].stringValue
        authToken = json[Keys.authToken].stringValue
    }

    // updating existing instance with data from a JSON object
    func update(from json: JSON?) {
        guard let json = json[Keys.user] else { return }

        name = json[Keys.name].stringValue
        email = json[Keys.email].stringValue

    }
}
</code></pre>

<p>Finally, I'd remove any code that calls <code>save()</code> on your context from within the <code>User</code> object, and have this in the controller. I'd <em>probably</em> also remove the code that fetches a <code>User</code> and also have this moved into  the view controller.</p>

<p>Personally, I'd also not call <code>save()</code> on the object when it's newly created, and instead defer that until some later time (such as when the view controller is exiting). </p>

<pre><code>import UIKit

class ViewController: UIViewController {

    var context: NSManagedObjectContext?

    func someMethodThatCreatesUser() {

        guard let context = context else { return }

        let json: JSON?  // ... grab json
        guard let user = User(in: context, with: json) else { return }

        // do something with the user...
    }

    func someMethodThatGetsExistingUser() -&gt; User? {

        guard let context = context else { return nil }

        let request: NSFetchRequest&lt;User&gt; = User.fetchRequest() 
        // `fetchRequest()` is auto generated by Xcode, if you create
        // your own managed object subclasses you'll need to do some
        // additional work here.

        let users = try? context.fetch(request)
        return users?.first

    }

    deinit {
        guard let context = context else { return }
        context.perform {
            try? context.save()
        }
    }

}
</code></pre>
    </div>