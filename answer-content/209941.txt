<div class="s-prose s-prose__disable-spoiler-hover js-post-body" itemprop="text">
<p>To add to @Errorsatz's comment at the bottom of his answer</p>

<blockquote>
  <p>In terms of the data itself, there's only so far you can compress that, but the map images (r1-r9) could all be generated by a single function.</p>
</blockquote>

<p>Any time you find yourself hard coding repetitious, complicated things like with the variables <code>r1</code>-<code>r9</code>, you should take a step back and consider writing code to automate it for you. What if you want to change the size later, or add some other detail? Do you really want to have to edit every room?</p>

<p>Here's some code that does just that. I chose to break it down quite far and opt for a verbose version, but I feel that will help readability and understanding. Don't worry, we'll walk through the code in detail after. </p>

<pre><code>room_wall = "|"
spot_template = "[ ]"
position_indicator = "^"

def room_template(width, height):
    row = [room_wall + spot_template * width + room_wall]

    return "\n".join(row * height)

def generate_room(width, height, pos_x, pos_y):
    template = room_template(width, height)

    spot_width = len(spot_template)
    wall_width = len(room_wall)
    row_width = spot_width * width + wall_width * 2 + 1 # + 1 to account for newline
    replace_index = 1 + wall_width + pos_y * row_width + pos_x * spot_width

    return template[:replace_index] \
               + position_indicator \
               + template[replace_index + 1:] 

def generate_rooms(room_width, room_height):
    return [generate_room(room_width, room_height, x, y)
            for x in range(room_width)
            for y in range(room_height - 1, -1, -1)]
</code></pre>

<p>And an example of its use:</p>

<pre><code>&gt;&gt;&gt; for r in generate_rooms(3, 3):
        print(r + "\n")

|[ ][ ][ ]|
|[ ][ ][ ]|
|[^][ ][ ]|

|[ ][ ][ ]|
|[^][ ][ ]|
|[ ][ ][ ]|

|[^][ ][ ]|
|[ ][ ][ ]|
|[ ][ ][ ]|

|[ ][ ][ ]|
|[ ][ ][ ]|
|[ ][^][ ]|

|[ ][ ][ ]|
|[ ][^][ ]|
|[ ][ ][ ]|

|[ ][^][ ]|
|[ ][ ][ ]|
|[ ][ ][ ]|

|[ ][ ][ ]|
|[ ][ ][ ]|
|[ ][ ][^]|

|[ ][ ][ ]|
|[ ][ ][^]|
|[ ][ ][ ]|

|[ ][ ][^]|
|[ ][ ][ ]|
|[ ][ ][ ]|
</code></pre>

<hr>

<h1>So, how does it work?</h1>

<pre><code>room_wall = "|"
spot_template = "[ ]"
position_indicator = "^"
</code></pre>

<p>First, at the top I defined several variables holding the bare-bones of what's going to be generated. This makes it easier to change things later, and makes it clearer what the characters actually represent. <code>spot_template</code> represents the basic structure of an empty "cell" in a room. The <code>^</code> will be plugged in later when necessary.</p>

<hr>

<pre><code>def room_template(width, height):
    row = [room_wall + spot_template * width + room_wall]

    return "\n".join(row * height)
</code></pre>

<p><code>room_template</code> returns a simple, empty-celled room. <code>row</code> ends up being, with dimensions of 3x3, <code>["|[ ][ ][ ]|"]</code>; a string representing a row enclosed in a list. I put a list around it because later on I need <code>row * height</code> to multiply lists, not strings directly. I need each row separate so I can join them with a newline before it's all returned:</p>

<pre><code>&gt;&gt;&gt; room_template(3, 3)
'|[ ][ ][ ]|\n|[ ][ ][ ]|\n|[ ][ ][ ]|'

&gt;&gt;&gt; print(room_template(3, 3))
|[ ][ ][ ]|
|[ ][ ][ ]|
|[ ][ ][ ]|
</code></pre>

<hr>

<p><code>generate_room</code>'s math got a little messy unfortunately. There's a few nit-picky details that need to be taken into consideration though.</p>

<p>Here's the idea of how it works: take the returned template room, figure out the index of the empty space character in the selected <code>"[ ]"</code> that needs to be replaced, then replace it with a <code>"^"</code>.</p>

<pre><code>spot_width = len(spot_template)
wall_width = len(room_wall)
row_width = spot_width * width + wall_width * 2 + 1 # + 1 to account for newline
replace_index = 1 + wall_width + pos_y * row_width + pos_x * spot_width
</code></pre>

<p>This whole chunk is figuring out the exact index in the template string that needs to be replaced. Basically, I just sat down with a pen and paper and figured the math out by manually finding the indices for a 3x3 room, and thinking out what math would lead to that. Then I expanded it to other dimensions, and fixed a couple bugs. I originally figured it out without the <code>"|"</code> walls for simplicity, then accounted for them after.</p>

<p>Here are the major parts:</p>

<pre><code>row_width = spot_width * width + wall_width * 2 + 1 # + 1 to account for newline
</code></pre>

<p>This is how many characters long each "row" of the string is. Each <code>"[ ]"</code> cell is 3 characters long, so the whole row is the length of <code>"[ ]"</code> * the width of the room + the length of <code>"|"</code> * 2. Then + 1 to account for the newline at the end of each row.</p>

<pre><code>replace_index = 1 + wall_width + pos_y * row_width + pos_x * spot_width
</code></pre>

<p>This is based on an old equation that's useful in many scenarios. If you have a 2D list/matrix being represented by a normal, 1D list (like <code>[1, 2, 3, 4, 5, 6, 7, 8, 9]</code> representing a 2D array of <code>[[1, 2, 3], [4, 5, 6], [7, 8, 9]]</code>), and you wanted to figure out the index of the cell at position (1, 2), what's the equation? It's simply</p>

<pre><code>i = row_width * y + x
i = 3 * 2 + 1
i = 7
</code></pre>

<p>The element at index 7 is <code>8</code>, which if this were a 2D array, would be the element at (1, 2).</p>

<p>This is the basic idea here. If you squint a bit, you can see <code>row_width * y + x</code> in there. The + 1 is to account for the first <code>"["</code>, and I have to + <code>wall_width</code> to account for the walls on each end.</p>

<pre><code>return template[:replace_index] \
           + position_indicator \
           + template[replace_index + 1:]
</code></pre>

<p>This is just "replacing" the character at index <code>replace_index</code> of the <code>template</code> string. See <a href="https://stackoverflow.com/a/41752999/3000206">@Willem's answer here</a> for an in-depth explanation of what's going on. It basically just cuts the string in two pieces at the calculated index, puts the <code>"^"</code> in there, then glues it all back together.</p>

<pre><code>&gt;&gt;&gt; generate_room(3, 3, 1, 2)
'|[ ][ ][ ]|\n|[ ][ ][ ]|\n|[ ][^][ ]|'

&gt;&gt;&gt; print(generate_room(3, 3, 1, 2))
|[ ][ ][ ]|
|[ ][ ][ ]|
|[ ][^][ ]|
</code></pre>

<hr>

<p>Finally, <code>generate_rooms</code> goes through each x,y position, in the order you had before, and creates a room with an indicator at the given position.</p>

<p>The whole thing is just a list comprehension split over a few lines.</p>

<pre><code>for x in range(room_width)
for y in range(room_height - 1, -1, -1)
</code></pre>

<p>This generates each x,y position starting from the bottom left. It then passes the generated <code>x</code>,<code>y</code> values to <code>generate_room</code>, generates a room, and adds it to the list. The list is then returned. This function is basically a more succinct version of:</p>

<pre><code>def generate_rooms_verbose(room_width, room_height):
    rooms = []

    for x in range(room_width):
        for y in range(room_height - 1, -1, -1):
            rooms.append(generate_room(room_width, room_height, x, y))

    return rooms
</code></pre>

<p>Which may make more sense.</p>

<hr>

<p>Hopefully this helps. This code certainly isn't very short, but it shows how this problem can be approached, and that it can be automated.</p>

<p>Now, you can create rooms of any dimensions:</p>

<pre><code>&gt;&gt;&gt; print(generate_room(4, 10, 2, 7))
|[ ][ ][ ][ ]|
|[ ][ ][ ][ ]|
|[ ][ ][ ][ ]|
|[ ][ ][ ][ ]|
|[ ][ ][ ][ ]|
|[ ][ ][ ][ ]|
|[ ][ ][ ][ ]|
|[ ][ ][^][ ]|
|[ ][ ][ ][ ]|
|[ ][ ][ ][ ]|
</code></pre>

<p>Without ever needing to manually write each of the possible 40 rooms of that size.</p>

<hr>

<hr>

<p>Looking back, I could/should have broken <code>generate_room</code> down further. The math calculating the index could go in its own function, and I could have also created a function to return a string with the character at a given <code>i</code> replaced with a <code>replacement</code> character. Something like:</p>

<pre><code>def spot_index_in_template(template_width, x, y):
    spot_width = len(spot_template)
    wall_width = len(room_wall)
    row_width = spot_width * template_width + wall_width * 2 + 1

    return 1 + wall_width + y * row_width + x * spot_width

def replace_at_index(s, i, replacement):
    return s[:i] + replacement + s[i + 1:]

def generate_room(width, height, pos_x, pos_y):
    template = room_template(width, height)
    i = spot_index_in_template(width, pos_x, pos_y)

    return replace_at_index(template, i, position_indicator)
</code></pre>
    </div>