<div class="s-prose s-prose__disable-spoiler-hover js-post-body" itemprop="text">
<ol>
<li><p>Declaring <code>ini_set('display_errors', 1);</code> while in the development stage is fine, but when you move to production, you mustn't be presenting error messages to the end user.</p>
</li>
<li><p><code>if (!$_GET)</code> isn't of much use given the following expression.<br>Just use <code>if (empty($_GET['path']))</code>.</p>
</li>
<li><p><code>ctype_alnum()</code> is locale specific and can possibly let you down. (Here's <a href="https://stackoverflow.com/a/55992883/2943403">a demo I prepared a little while back</a>.)  <code>\p{L}</code> will match your multibyte letters and <code>\p{N}</code> will match your multibyte numbers.  You can bake the required length of the string into a single regex pattern as well.  <code>/^[\p{L}\p{N}]{6}$/u</code><br><br>This means your entire validation check can be done in one hit.<br></p>
<pre><code> if (empty($_GET['path']) || !preg_match('/^[\p{L}\p{N}]{6}$/u', $_GET['path'])) {
     die("Missing/Invalid path value");
 }
</code></pre>
</li>
<li><p>If you aren't going to move your database connection credentials into a separate config / .env file, then I don't see any advantage in declaring single-use variables either.  Just write the literal strings into your pdo connection call.</p>
</li>
<li><p>I think you should try to avoid using ALLCAPS variable names so that they are instantly differentiated from constants. (Yes, of course, the dollar sign is another clue, but this is still my advice for improved readability.)  Conversely, you should always use ALLCAPS when you using sql keywords this will improve readability as well.</p>
</li>
<li><p>Assuming the <code>id</code> column of the <code>cache</code> table is the Primary/Unique Key, there is no benefit in declaring <code>LIMIT 1</code>.</p>
</li>
<li><p>Your row "freshness" condition can be written into your sql instead of checking the <code>timestamp</code> in php.</p>
</li>
<li><p><code>doSQL()</code> looks like unfinished noise.  You should remove it until it is something that you are going to finish and incorporate.</p>
</li>
<li><p>In <code>buildBody()</code>, I think the argument should be named <code>$attrs</code> since it is an array of attributes. You might even like to signify the data type with some typehinting.  As for the building of the new html, I think using <code>sprintf()</code> will go a long way to clean up the syntax and make the code easier to read/maintain.</p>
</li>
<li><p><code>if(!$html || empty($html))</code>, again, can be simplified to <code>if (!$html))</code> -- the variable will always be set, so you only need to check if it is <em>falsey</em>.</p>
</li>
<li><p>I despise the use of <code>@</code> (error suppressor / "stfu" operator) in code and cringe whenever I see them.  There are ways to handle errors generated by invalid html being passed to DOMDocument. For instance: <code>libxml_use_internal_errors(true);</code></p>
</li>
<li><p><s>Using XPath to compliment DOMDocument is going to allow you to express all of your requirements in a tidy expression so that you don't need to iterate non-qualifying nodes.</s> I overlooked what you were extracting from the DOM.  Just use <code>get_meta_tags()</code> for the cleanest extraction.</p>
</li>
<li><p>I don't think I would bother to declare the empty strings in <code>$data</code>.  You are already making <code>empty()</code> checks later in the code, so if these keys are not set, then <code>empty()</code> will handle things just fine.</p>
</li>
<li><p>If I am not mistaken, your <code>$metaTags</code> loop is only expecting to find one match.  So that your loop is not performing unnecessary iterations, I recommend that your <code>case</code> statements <code>break 2</code> so that the loop is killed.  <s>That said, if you set up XPath properly, you won't need a loop or <code>break 2</code> -- your code will either find 0 or 1 qualifying node.</s></p>
</li>
<li><p><code>if(empty($data) || empty($data['url']))</code> can be simplified to <code>if (empty($data['url']))</code> because if the <code>url</code> key is set and truthy, then of course <code>$data</code> is not empty.</p>
</li>
<li><p>Finally, as a general rule, whenever your script's intention is to write to the database, then the script's incoming data should come from <code>$_POST</code>.  Scripts that merely intend to read from the database should be relying on <code>$_GET</code> data.  If you have a valid overriding reason to do it your way, okay, but this is a line that I toe in my own projects.</p>
</li>
</ol>
    </div>