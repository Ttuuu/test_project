<div class="s-prose s-prose__disable-spoiler-hover js-post-body" itemprop="text">
<p>After my initial disappointment with the performance of the previous implementation below, I got to thinking. Now that we have a generator function why do allocation at all?</p>

<p>The other good answers allocate memory to the triangle as a necessity, this enables back referencing to calculate future values. If you have a generator function, you don't need to back reference the triangle and therefore it is no longer necessary to store the previous values to calculate the next (except for the one, immediately previous in the row.)</p>

<p>When it comes to performance, the allocation of bytes becomes quite expensive. If you don't need to access values out of sequence this approach avoids the allocation overhead. Further note, that any given row can be generated by calling the <code>Row</code> function directly.</p>

<pre><code>public static class JodrellMk2Pascal
{
    public static IEnumerable&lt;IEnumerable&lt;int&gt;&gt; Triangle(int n)
    {
        for (var i = 0; i &lt; n; i++)
        {
            yield return Row(i);
        }
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static IEnumerable&lt;int&gt; Row(int n)
    {
        var last = 1;
        yield return last;

        for (var k = 0; k &lt; n; k++)
        {
            yield return last = last * (n - k) / (k + 1);
        }
    }
}
</code></pre>

<hr>

<p>If performance is your goal you'd be better off with an identity function and better memory management.</p>

<p>The additional benefit here, is that you can jump to the 53rd line <code>Line(52)</code> without having to calculate the preceding triangle.</p>

<pre><code>public static class Pascal
{
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ReadOnlySpan&lt;long[]&gt; Triangle(int n)
    {
        if (n &lt; 1)
        {
            return ReadOnlySpan&lt;long[]&gt;.Empty;
        }

        Span&lt;long[]&gt; triangle = new long[n][];

        for (var r = 0; r &lt; n; r++)
        {
            triangle[r] = Line(r).ToArray();
        }

        return triangle;
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ReadOnlySpan&lt;long&gt; Line(int n)
    {
        if (n &lt; 0)
        {
            return ReadOnlySpan&lt;long&gt;.Empty;
        }

        if (n == 0)
        {
            return (ReadOnlySpan&lt;long&gt;)new long[]
            {
                1L
            };
        }

        Span&lt;long&gt; result = new long[n + 1];

        result[0] = 1L;
        for (var k = 0; k &lt; n; k++)
        {
            result[k + 1] = result[k] * (n - k) / (k + 1);
        }

        return result;
    }
}
</code></pre>
    </div>