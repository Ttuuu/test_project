<div class="s-prose s-prose__disable-spoiler-hover js-post-body" itemprop="text">
<p>I think there are two flaws with this function; the first is in conception, and the second is in implementation.</p>

<p>The conception problem is this: What does <code>genuine_apply</code> really do? You pass it a callable and an argument. If the argument is a tuple-like object, you expand it and pass its elements as separate arguments to the callable. If you pass it a non-tuple-like argument, you pass the argument directly to the callable. What are the circumstances in which you want that behavior? Think of <code>apply</code> as an aid to generic programmers; they know whether they're passing a tuple-like argument to <code>apply</code> because <em>they construct the argument</em>. Typically, you wouldn't pass user-provided arguments directly to <code>apply</code>, you'd construct the argument yourself from the user-provided arguments. Here, you'll get different behavior based on whether the user passes a <code>vector</code> or a <code>tuple</code>. In short, it makes it very difficult for a reader of your code to understand exactly what is going to happen.</p>

<p>The error in implementation is that <code>is_tuple_like</code> is incorrect. It does not accept <code>std::pair</code> nor any user-defined type or future standard type that supports <code>std::get</code> and <code>std::tuple_size</code>. Presumably instead of checking for membership in a list of types, you should check whether <code>std::get&lt;0&gt;(declval(T))</code> and <code>std::tuple_size&lt;T&gt;::value</code> are defined.</p>
    </div>