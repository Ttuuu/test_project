<div class="s-prose s-prose__disable-spoiler-hover js-post-body" itemprop="text">
<p>Looks pretty good to me.  There are a few shortcuts you could add if you don't mind using the Tupelo Clojure library.  One of them is <a href="https://cljdoc.org/d/tupelo/tupelo/0.9.190/api/tupelo.core#vals-%3Emap" rel="nofollow noreferrer">vals-&gt;map</a>
and <a href="https://cljdoc.org/d/tupelo/tupelo/0.9.190/api/tupelo.core#with-map-vals" rel="nofollow noreferrer">with-map-vals</a>.  </p>

<p>Called with a list of symbols like <code>(vals-&gt;map a b c)</code> returns a map like <code>{:a a :b b :c c}</code>:</p>

<pre><code>(let [a 1
      b 2
      c 3]
  (vals-&gt;map a b c))  ;=&gt;  {:a 1 :b 2 :c 3} }
</code></pre>

<p>Given a map like <code>{:a 1 :b 2 :c 3}</code> (such as generated by <code>(vals-&gt;map a b c)</code>), performs safe let destructuring using <code>grab</code> like:</p>

<pre><code>   (let [some-map  {:a 1 :b 2 :c 3} } ]
     (with-map-vals some-map [a b c]
        (+ a b c)))  ;=&gt;  6
</code></pre>

<p><code>with-map-vals</code> is safe for typos since <code>grab</code> will throw if the requested key is not present. See vals-&gt;map for simple creation of labeled data maps.</p>

<p>For default values, I think the simplest way is like this:</p>

<pre><code>  (let [defaults {:a 1 :dir :up :name "joe"}
        v1       {:a 2}
        v2       {:a 9 :dir :left :name "sally"}]
    (spyx (into defaults v1))
    (spyx (glue defaults v2))
</code></pre>

<p>There is also the pure clojure way:</p>

<pre><code>; Pure clojure way
(let [{:keys [a dir name ] } v1]
  (spyx :pure-1 (vals-&gt;map a dir name)) )

; can't use `defaults` here, need map with keyword =&gt; symbol
(let [{:keys [a dir name] :or {a 1 dir :up name "joe"}} v1] 
  (spyx :pure-2 (vals-&gt;map a dir name)))

(let [{:keys [a dir name ] :or {a 1 dir :up name "joe"}} v2] 
  (spyx :pure-1 (vals-&gt;map a dir name)) )
</code></pre>

<p>See also <a href="https://clojure.org/guides/destructuring" rel="nofollow noreferrer">Clojure Destructuring</a>.</p>

<hr>

<p>Lastly, instead of <code>concat</code> I like to use <a href="https://github.com/cloojure/tupelo#gluing-together-like-collections" rel="nofollow noreferrer">glue</a>.</p>

<pre><code>; Glue together like collections:
(is (= (glue [ 1 2] '(3 4) [ 5 6] )       [ 1 2 3 4 5 6 ]  ))   ; all sequential (vectors &amp; lists)
(is (= (glue {:a 1} {:b 2} {:c 3} )       {:a 1 :c 3 :b 2} ))   ; all maps
(is (= (glue #{1 2} #{3 4} #{6 5} )      #{ 1 2 6 5 3 4 }  ))   ; all sets
(is (= (glue "I" " like " \a " nap!" )   "I like a nap!"   ))   ; all text (strings &amp; chars)

; If you want to convert to a sorted set or map, just put an empty one first:
(is (= (glue (sorted-map) {:a 1} {:b 2} {:c 3})   {:a 1 :b 2 :c 3} ))
(is (= (glue (sorted-set) #{1 2} #{3 4} #{6 5})  #{ 1 2 3 4 5 6  } ))
</code></pre>

<hr>

<p>Lastly, I wouldn't bother with <code>defn-</code>  It just makes testing harder and provides little value.  If you have non-public functions that you don't want in the documentation (via the <code>lein-codox</code> plugin), you can add metadata to the function like:</p>

<pre><code>(defn ^:no-doc my-helper-fn
  ...)
</code></pre>
    </div>