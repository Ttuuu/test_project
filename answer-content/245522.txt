<div class="s-prose s-prose__disable-spoiler-hover js-post-body" itemprop="text">
<blockquote>
<p>Boxing from value <code>PathNode</code> to reference <code>IPathNode</code> causes another half of allocations. But making <code>PathNode</code> a class instead of struct makes things worse! There are thousands of <code>PathNode</code>'s! And I have to provide a reference to a parent to each node: otherwise there will be no way to track final path through nodes.</p>
</blockquote>
<p>It's normally good software engineering practice to have the interface, probably, but for this situation I recommend removing it. Boxing should be avoided, not by switching to classes, but by removing the boxing. So let's work around needing a reference to a node.</p>
<p>There are other ways to remember the "parent" information, that do not involve a reference to a node. For example, a <code>Dictionary&lt;Vector2Int, Vector2Int&gt;</code>, or <code>Vector2Int[,]</code>, or <code>Direction[,]</code>, there are many variants. When at the end of A* the path is reconstructed, the nodes are mostly irrelevant: only the positions matter, so only the positions need to be accessible, and they still are with these solutions.</p>
<blockquote>
<p>85% of memory allocations are happening inside <code>GenerateFrontierNodes()</code> method. Half of that caused by <code>SortedSet.Add()</code> method. Nothing I can do there?</p>
</blockquote>
<p>There is something that can be done: use a binary heap. Actually <code>SortedSet</code> is not that good to begin with, it has decent asymptotic behaviour, but its contant factor is poor. A binary heap is great for this use. It's simple to implement, low-overhead, low-allocation. It doesn't keep the collection completely sorted but A* does not require that.</p>
<p>Then "the update problem" needs to be solved. Currently, it is solved by <code>frontier.Remove</code> and <code>frontier.Add</code> to re-add the node with the new weight. A binary heap is not searchable (not properly), but a <code>Dictionary&lt;Vector2Int, int&gt;</code> can be maintained on the side to record the index in the heap of a node with a given location. Maintaining that dictionary is not a great burden for the heap, and allows an O(log n) "change weight" operation.</p>
    </div>