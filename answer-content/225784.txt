<div class="s-prose s-prose__disable-spoiler-hover js-post-body" itemprop="text">
<h1>Use a perfect hash function</h1>

<p>What you want is to implement a <a href="https://en.wikipedia.org/wiki/Perfect_hash_function" rel="nofollow noreferrer">perfect hash function</a>. This is any function that for any of the valid input values, results in a unique value into to the hash table. Despite the name, there is more than one way to make such a function. Also, it's easier to make if you allow the hash table to be bigger than the number of valid items. There are tools available that, given a set of inputs, can create a perfect hash function for you. One example is <a href="https://www.gnu.org/software/gperf/manual/gperf.html" rel="nofollow noreferrer">GNU gperf</a>, unfortunately it expects the set of inputs to be strings.</p>

<p>Another option is to find try to find a suitable mapping yourself. For example, the smallest difference between two values of kbch is 360, and the minimum value is 14208. So a possible perfect (but not minimal) hash function is:</p>

<pre><code>unsigned int hashOf(unsigned int kbcd) {
    return (kcbd - 14208) / 360;
}
</code></pre>

<p>The maximum output value of this function is 122, so you have to make an array of 123 elements, even though only 28 elements will have a useful entry.</p>

<p>28 possible values is a small number, so writing something by hand might outperform a function generated by a generic tool. If you want to know what is faster, benchmark your code.</p>

<h1>Don't use <code>__attribute__((packed))</code> unless you really need strict packing</h1>

<p>Why is <code>dvbS2xRecord</code> packed? You may think this is faster because it might use fewer cache lines for <code>dvbS2xRecordTable[]</code>, but now the CPU has to do unaligned reads from the <code>dvbS2xRecord</code>s, which might slow things down, or result in undefined behavior on CPU architectures that do not support unaligned access.</p>
    </div>