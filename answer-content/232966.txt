<div class="s-prose s-prose__disable-spoiler-hover js-post-body" itemprop="text">
<p>For testing purposes I created a <code>main()</code>. I used Visual Studio 2019 for the testing, and used C++17. Note that the posted code did not compile in C++11.</p>
<pre><code>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;cstdlib&gt;
#include "JSONParser.h"

int main(int argc, char* argv[])
{
    std::string jsonFile;

    if (argc &gt; 1)
    {
        jsonFile = argv[1];
    }
    else
    {
        std::cout &lt;&lt; "Please enter a JSON file name." &lt;&lt; std::endl;
        std::cin &gt;&gt; jsonFile;
    }

    JSONParser jsonParser;
    try
    {
        jsonParser.parseFile(jsonFile);
    }
    catch (std::runtime_error ex)
    {
        std::cerr &lt;&lt; ex.what() &lt;&lt; std::endl;
        return EXIT_FAILURE;
    }

    return EXIT_SUCCESS;
}
</code></pre>
<p>I discovered several possible issues during testing, some are not listed here because I ran out of time to debug.</p>
<h2>Error Checking</h2>
<p>There is no test for if the input file containing the JSON was found or not, this can cause the program to terminate abnormally. Since the user has to indicate what file to open somewhere, there needs to be tests to see if the file can be opened and if the file can be read from. When there is no input file the function <code>std::vector&lt;std::string&gt; JSONParser::lexer(std::string fileName)</code> returns an empty list of strings that causes the program to terminate in the processing of the empty list rather than in the input itself.</p>
<p>One possible alternative implementation of <code>lexor</code> is :</p>
<pre><code>std::vector&lt;std::string&gt; JSONParser::lexer(std::string fileName) {
    char piece;
    std::string capture = "";
    std::string conversion;
    std::vector&lt;std::string&gt; capture_list;

    std::ifstream configfile(fileName);

    piece = configfile.get();
    if (configfile.bad() || configfile.fail())
    {
        std::string emsg("Can't read json from file: ");
        emsg += fileName;
        throw std::runtime_error(emsg);
    }

    while (configfile.good()) {
        if (checkDeliminator(piece)) {
            conversion = piece;
            if (capture != "") {
                capture_list.push_back(capture);
                capture_list.push_back(conversion);
                capture = "";
            }
            else {
                capture_list.push_back(conversion);
            }
        }
        else {
            capture += piece;
        }
        piece = configfile.get();
    }

    configfile.close();

    return capture_list;
}
</code></pre>
<p><em>Note the change of the input for <code>lexor</code>: The ifstream configfile is only used within the function <code>lexor</code> so it is better to instantiate the configfile variable within the body of <code>lexor</code>. This also permits better error messages by passing the file name.</em></p>
<h2>Possible Syntax Errors or Typos</h2>
<p>There are several if statements in <code>void JSONParser::fsm(std::string value)</code> that may not return the proper results, instead of using the <code>logical</code> operators <code>&amp;&amp;</code> and <code>||</code> the bit wise operators <code>|</code> and <code>&amp;</code> were used. This may cause a program using the parser to fail when it should pass, or pass when it should fail. It should also be noted that the function name <code>fsm</code> is not clear to anyone that needs to maintain the code.</p>
<h2>Algorithm</h2>
<p>Fast lexical analyzers (such as those generated by <a href="https://en.wikipedia.org/wiki/Lex_(software)" rel="nofollow noreferrer">lex</a> or <a href="https://en.wikipedia.org/wiki/Flex_(lexical_analyser_generator)" rel="nofollow noreferrer">flex</a>) are generally implemented as state machines using tables. Parsers generally accept a single token at a time from the lexical analyzer. Parser generators such as <a href="https://en.wikipedia.org/wiki/Yacc" rel="nofollow noreferrer">YACC</a> or <a href="https://en.wikipedia.org/wiki/GNU_Bison" rel="nofollow noreferrer">Bison</a> generate push down automata which as state machines using tables coupled with a stack. To improve performance it might be better to implement the lexer and the parser this way.</p>
<p>If you want to experiment with these compiler development tools you can find <a href="https://github.com/westes/flex" rel="nofollow noreferrer">flex here</a> and <a href="https://www.gnu.org/software/bison/" rel="nofollow noreferrer">bison here</a>.</p>
    </div>