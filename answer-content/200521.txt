<div class="s-prose s-prose__disable-spoiler-hover js-post-body" itemprop="text">
<ol>
<li><code>malloc</code> and <code>realloc</code> live in <code>cstdlib</code>. <code>malloc.h</code> is not a standard header, neither in C++ nor in C, and should not be relied on in any case. </li>
<li>Also, you're missing <code>#include &lt;utility&gt;</code> for <code>std::move</code>.</li>
<li>Legacy C functionality, as everything else from the standard library, lives in the <code>std</code> namespace, if you include the corresponding <code>&lt;cheader&gt;</code> files. While you can also include the C standard headers via <code>&lt;header.h&gt;</code>, this is highly discouraged. With the first option, names may also exist in the global namespace, but this is not guaranteed and should not be relied on.</li>
<li>Your <code>malloc</code> and <code>realloc</code> functions need not be <code>inline</code>. In fact, <code>inline</code> does nothing here; remove it.</li>
<li>You don't need to check for null pointers when <code>free</code>ing memory. Passing a null pointer to <code>free</code> is always well defined and does nothing.</li>
<li>You don't need to move out all the data members from <code>other</code> in your move constructor. All of those members are trivial to copy, and have no special move behavior.</li>
<li>The move assignment operator invokes undefined behavior. You cannot just call the destructor of an object and then write to its members. Calling the destructor completely ends the lifetime of the object; afterwards, there's nothing there to write to. Furthermore, this is a kind of anti-pattern; in almost all cases, the move assignment operator should be implemented via the <a href="https://stackoverflow.com/questions/3279543/what-is-the-copy-and-swap-idiom">copy-and-swap idiom</a>.</li>
<li><code>push_back</code> is broken. You call <code>change_capacity</code> with the result of <code>std::min(m_capacity * 2, 1)</code>, which is either 0 or 1, in any case. Most likely, you'd want to use <code>std::max</code> instead.</li>
<li><code>if (m_size + 1 &gt; m_capacity)</code> looks strange to my eyes. I would just write <code>if (m_size &gt;= m_capacity)</code>.</li>
<li><code>pop_back</code> should definitely return a value. It's not very useful otherwise. </li>
<li>Since you're going for what seems to be a std-like container interface, you should add a little more functionality. For one, you're missing some of the usual type definitions, such as <code>iterator</code> and <code>const_iterator</code>. Furthermore, some sort of <code>emplace</code> mechanism would be appropriate, as well as some way to clear the container and some functionality to shrink it, as well as some other things.</li>
<li>You should make sure that memory is properly initialized. As a user, I would expect that it's safe to access every element in bounds; however, you are not initializing memory at all, leaving that job to the user. I'd expect memory to be default- or zero-initialized; making use of <code>std::calloc</code> should do the trick (alternatively, you can also just <code>std::memset</code> the area). </li>
<li>I would make your <code>malloc</code> and <code>realloc</code> functions a little bit more useful. As of right now, the onus of checking whether allocation succeeded is put on the user of those functions, but in my opinion it would be much cleaner and safer to lift those functions to a "C++-safe" level, i.e. make them check the return value of the underlying allocation call directly and convert that into an exception directly.</li>
<li><code>std::is_pod</code> is being deprecated, in accordance with the standard library moving away from the term POD as a whole. Also, the requirement that <code>T</code> must be a POD type is too strict; your vector will still work correctly if <code>T</code> is <a href="https://en.cppreference.com/w/cpp/types/is_trivial" rel="nofollow noreferrer">trivial</a>.</li>
</ol>
    </div>