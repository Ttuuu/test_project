<div class="s-prose s-prose__disable-spoiler-hover js-post-body" itemprop="text">
<p>The code does just a <em>tad more</em> then a standard sieve. Of course the inner loop of the sieve starts with <code>i*i</code> whereas your code starts with <code>i*2</code>; still we can expect that it should scale nicely with <span class="math-container">\$O(n \log \log n)\$</span> time complexity. Considering that a sieve over 200000000 completes in a matter of seconds, the difference must come from the work the sieve does not.</p>
<p>This <em>tad more</em> is that while sieve crosses out the compound numbers, you <code>push_back</code> them to the lists. And this is a performance killer.</p>
<p>You push back every factor of every integer. The number of <code>push_back</code>s performed <a href="https://en.wikipedia.org/wiki/Divisor_function#Growth_rate" rel="nofollow noreferrer">grows approximately</a> as <span class="math-container">\$N\log{N}\$</span> (the Dirichlet estimate). I expect that the factors lists amasses about 4G entries; as each entry (having an <code>int</code> value and two pointers) is of 24 byte (on a 64-bit system), the total memory consumed is about 90 GB (how much exactly we don't know; you are at the mercy of the standard library implementors). This is by itself a very impressive number. What's worse, elements of these lists are scattered all over the place, and the code accesses them pretty much randomly, in a <em>very</em> cache-unfriendly manner. In other words, most of the time is spent thrashing the cache.</p>
<p>To be honest, I don't know how to speed up your code. I have some ideas based on the entirely different approaches, by I don't expect an order of magnitude improvements. Factorizing is hard.</p>
<hr>
<p>I don't understand why do you want a timer thread. It is perfectly OK to query <code>std::chrono::system_clock::now();</code> before the processing, and at any moment you want to know how much time elapsed.</p>
<hr>
<p><code>Validating results</code> section is very sloppy. A visual inspection of a few primes is far from enough. You should take a small, yet representative (say, 10000 strong), set of numbers, compute their factors the hard way, and compare the results.</p>
    </div>