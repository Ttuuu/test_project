<div class="s-prose s-prose__disable-spoiler-hover js-post-body" itemprop="text">
<p><strong>Short answer:</strong> </p>

<p>Don't create a DTO per entity. Use the <a href="http://www.expojo.com/exposedDomainModel.htm" rel="nofollow noreferrer">exposed domain model</a> pattern instead. </p>

<p><strong>Very long answer:</strong></p>

<p>When you say "send to the client," as it is a webapp, this really means render to the browser (or mobile app) in the servlet tier. In which case, it's typically your own teams code and there is little or no value to copying entities into DTOs. There is overhead to copying into DTOs which is a reason not to do it. The <a href="http://www.expojo.com/exposedDomainModel.htm" rel="nofollow noreferrer">exposed domain model</a> pattern considers copying to DTOs as an anti-pattern. The <em>POJOs In Action</em> book by <a href="http://www.manning.com/crichardson/" rel="nofollow noreferrer" title="Richardson">Chris Richardson</a> is old, but still excellent and covers the exposed domain model pattern. The library versions in the sample code are now very out of date as it is many years later but the design and implementation approaches described in detail are IMHO timeless.</p>

<p>There is a use for some DTOs when writing code with entities. The canonical use is a search results screen which is, say, a grid with many columns which come from many entities. An example would be a summary of customer orders. That would have each row be taken from entities such as customers, addresses, products, orders etc. In such a case it is wasteful and slow to load all the entities to memory to render them in the flat search results screen. In that case you can create a DTO which represents a row on the screen and use JPA <code>select new</code> syntax as described in this <a href="https://stackoverflow.com/a/2359214/329496">answer</a> to join across entities which is translated into a database join query that is efficiently loaded into the DTO object.</p>

<p>We should note that the DTO described above models the search result screen not the business domain. That's an important distinction. The DTO may change completely if the screen changes or be deleted if the screen is deleted. What you really want to do is model the business problem as entities and mature that model carefully and keep DTOs to an absolute minimum. Screens which work closely with a few entities in detail should work with root entities that control other entities directly. </p>

<p>I would strongly recommend putting as much business logic as you can into entities as public methods, and try to have all the code which creates and connects entities default/package protected and as hidden as possible. When you do that you get better OO design. An example would be the <code>Order</code> entity has a method <code>getOrderItems</code> to list the <code>OrderItem</code> entities but a <code>protected</code> <code>setOrderItems</code> method. The client would invoke a public method on the <code>Order</code> called <code>addItem</code> which took all the fields needed to construct the <code>OrderItem</code> entry internally using a <code>protected</code> constructor and add it into its list of order items. The <code>Order</code> becomes a "root/aggregate entity" which manages the relations and business logic of subordinate entities. This is a more naturally OO design than having "behaviourless" DTOs with the business logic entirely in service classes; or worse spread out across UI code. Have the service classes that query and load root entities then call method on the root entities that contain the business logic. That way different service class methods that work with the same root entities won't duplicate logic as the logic will be within the entities that are shared. </p>

<p>If your entities are dumb with no logic then they are just DTOs which is the <a href="http://www.martinfowler.com/bliki/AnemicDomainModel.html" rel="nofollow noreferrer">Anemic Domain Model</a> anti-pattern. If your entities are strong with business logic then copying the entities to DTOs would make no way for a client to use that business logic.</p>

<p>Given all this advice, it may seem strange that so much j2ee code still copies all entities into DTOs. One reason for this may be that the original "Core J2EE Design Patterns" book published by Sun had DTOs as a core pattern. That was required reading for a decade at the turn of the century. It's still around on the <a href="http://www.oracle.com/technetwork/java/dataaccessobject-138824.html" rel="nofollow noreferrer">Oracle site</a>, but that version makes it clear that it's to abstract over JDBC or LDAP and clearly JPA is the modern and standards compliant way of abstracting over a database; therefore, that page is obsolete. </p>

<p><em>Edit</em> I have created a <a href="https://github.com/simbo1905/root-objects" rel="nofollow noreferrer">sample project on GitHub</a> that demonstrates some of the ideas in this answer. </p>
    </div>