<div class="s-prose s-prose__disable-spoiler-hover js-post-body" itemprop="text">
<p>Inspector! Why did you allow Gregory Arstotzkaya, a Kolechian spy, into our glorious nation? Or Ilyana Dbrova, whose documents were perfect forgeries, except for a gender mismatch in her ID card? And why did you fail to apprehend Karl von Oskowitz?</p>

<ul>
<li>Treating documents as a single piece of text and just checking whether they contain certain words is problematic. Instead, parse each document into a dictionary, which makes it easy to look at relevant fields only. This also simplifies your code, because you no longer need to have parsing code all over the place.</li>
<li>Similarly, using string comparisons for dates is not a good idea. Parse dates into a <code>datetime</code> object and compare those instead.</li>
<li>You're making things more difficult for yourself by splitting on spaces rather than commas:

<ul>
<li>Today it's just a single hack for the United Federation, tomorrow Antegria splits up into North Antegria and the Republic of South Antegria...</li>
<li>Why hard-code the names of any country (except for the motherland, of course)? If someone claims to be from Nonexististan, well, non-existing countries aren't on our whitelist, so they'll be rejected anyway. And why should you ignore a bulletin that tells you to allow people from a newly formed country?</li>
<li>If you're having difficulties isolating specific parts of a sentence, for simple cases you could use slicing: <code>string[start:end]</code> gives you a new string that only contains the specified part of the original string. Negative offsets count from the end of the string, left-out offsets default to the start/end of the string.</li>
</ul></li>
<li>Parsing bulletins would be much easier with the help of a few well-chosen regular expressions. Consider creating a list of pattern-function tuples, such as <code>('Allow citizens of (?P&lt;countries&gt;.+)', allow_citizens)</code>, where <code>allow_citizens</code> is a function that takes a <code>match</code> object. You can fetch the countries with <code>match.groups('countries')</code>, which can then easily be split on commas. Be sure to <code>strip()</code> leading and trailing spaces from each individual country name. Now, for each line in a bulletin, your <code>receive_bulletin</code> function would walk through this list, calling <code>re.match</code> for each pattern until it finds a match, which it passes on to the associated function. To handle the similarities between document and vaccination instructions, you could order the patterns from most to least specific, or use look-behind assertions, or perform additional checks in the associated function.</li>
<li>It's probably easier to store document and vaccination requirements per country, rather than per document type. That means that once you know where someone is from, you immediately know which documents are required, instead of having to check every document type for the person's country.</li>
<li>For requirements, I would use a <code>defaultdict</code>, from the <code>collections</code> module, with the <code>set</code> function as default factory. This means you don't need to worry about initialization: you can just do <code>required_documents[country].add(document)</code> without having to check whether <code>required_documents</code> even contains that <code>country</code> key.</li>
<li>In <code>inspect</code>, you're calling a lot of functions twice. First to see if the entrant should be detained or rejected, then again for the actual response. That's a waste of work. Just call these functions once and store their result in a local variable, then check that variable and return it if necessary.</li>
</ul>

<p>Most nested functions are reasonably named, which makes it easy to get an idea of <em>what</em> your code does. However, a lot of them depend on local state in their 'parent' function, which makes it difficult to understand <em>how</em> they work. There's also a fair amount of (almost) duplicated code and special-case handling that could be removed with more robust general-case code.</p>

<p>A function that takes all of its input via arguments, and returns its output, without modifying any other state - a 'pure' function - is easier to understand and easier to (re)use. For example, compare <code>check_documents_expiration_date()</code> with <code>is_document_expired(document, current_date)</code>: with the former, it's not immediately clear which documents it inspects, or against which expiry date. The latter clearly checks the given document against the given date. It's doing less, but can be used as a building block for other functions, or in small expressions like <code>expired_documents = [doc for doc in documents if is_document_expired(doc, current_date)]</code>.</p>
    </div>