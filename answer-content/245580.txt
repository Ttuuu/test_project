<div class="s-prose s-prose__disable-spoiler-hover js-post-body" itemprop="text">
<p>I've read the comments and am a bit torn by the discussion... yes, this code is not runnable; yes, you assume background knowledge; but you do that because 90% of Django starter code is not relevant to this discussion, but is essential to a Django project, so I think this is worth a shot.</p>
<p>For starters, it's worth pointing out that which of these solutions you choose <em>has no impact on the code you write</em>, since you will always refer to URL's by their name rather than by their path. This is solely a matter of beauty for how your capabilities are exposed to users and external services.</p>
<p>For this case, I would suggest a refactor that separates the front-end (paths) from the back-end (functionality). Have an app each for <code>support</code>, <code>blog</code>, and <code>store</code>, each of which implement their own models, serializers, utility functions, Celery tasks, etc. Then, have an app each for <code>panel</code> and <code>administration</code> that implements the paths, views, and user-facing logic about how people interact with those underlying concepts. You end up with some internal dependencies, but they're bipartite (only apps in the "frontend" group depend on only apps in the "backend" groups) and acyclic, so that's not a big deal.</p>
<p>If designed this way, you get the best of both worlds. You can keep the logical separation you show above among isolated logical components, but can use clean path construction and view implementation designed around how the users interact with your system. The downside is a larger number of apps and some internal dependencies, but those dependencies become explicit and you avoid the apps needing to implicitly know about each other and knowing how to avoid path conflicts.</p>
    </div>