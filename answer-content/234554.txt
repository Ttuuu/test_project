<div class="s-prose s-prose__disable-spoiler-hover js-post-body" itemprop="text">
<p>First of all, thanks to all the answers, I learned something new from all those answers. </p>

<p>Now coming back to the problem-statement, as no answer gave me an exact way of solving the problem in an efficient manner, so I did some research about the way the binary addition is performed, and I found that the algorithm described is known as <strong>No-Carry Adder</strong> in digital-logic, and the name is because there is no carry generated in the process.  </p>

<p>Algorithm for <strong>No Carry Adder</strong>:</p>

<pre><code>function no_carry_adder(A,B)
    while B != 0:
        X = A XOR B, Bitwise-XOR of A,B.
        Y = A AND B, Bitwise-AND of A,B.
        A = X
        B = Y &lt;&lt; 1, Multiplying Y by 2.
    return A
</code></pre>

<p>As you can see, the <code>while</code> loop executes those four instructions again and again until <code>B = 0</code>, and when <code>B = 0</code>, binary number stored in <code>A</code> is the answer.
Now the question was to find out how many times the <code>while</code> loop will execute before <code>B = 0</code> or <code>B</code> becomes zero.  </p>

<p>If I have gone for the naive way i.e write the algorithm as it is described in any programming language like in <code>Python</code> it will give me an answer but it will be time-consuming if the number of bits in the binary string <code>A</code> and <code>B</code> is <code>&gt; 500</code>.</p>

<p>So when you analyze some of cases, for example:  </p>

<ul>
<li><strong>Case 1:</strong> When both <code>A = B = 0</code>.<br>
       In this case the number of times the loop iterates <code>= 0</code> as <code>B = 0</code>.</li>
<li><strong>Case 2:</strong> When <code>A != 0</code> and <code>B = 0</code>.<br>
       In this case the number of times the loop iterates <code>= 0</code> as <code>B = 0</code>.  </li>
<li><strong>Case 3:</strong> When <code>A = 0</code> and <code>B != 0</code>.<br>
       In this case, the number of times the loop iterates <code>= 1</code> because after the first iteration, the value of <code>X = B</code> as when you do the <code>bitwise XOR</code> of any binary number with <code>0</code> the result is the number itself. The value of <code>Y = 0</code> because <code>bitwise AND</code> of any number with <code>0</code> is <code>0</code>. So, you can see <code>Y = 0</code> then <code>B = 0</code> as <code>Y &lt;&lt; 1 = 0</code>.</li>
<li><strong>Case 4:</strong> When <code>A = B</code> and <code>A != 0</code> and <code>B != 0</code>.<br>
       In this case, the number of times the loop iterates <code>= 2</code> because in first iteration the value <code>A = 0</code>, why because <code>bitwise XOR</code> of two same numbers is always <code>0</code> and value of <code>Y = B</code> because <code>bitwise AND</code> of two same numbers is the number itself and then <code>B = Y &lt;&lt; 1</code>, after the first iteration, this case becomes <strong>Case-3</strong>. So, the number of iteration will always be <code>2</code>.  </li>
<li><strong>Case-5:</strong> When <code>A != B</code> and <code>A != 0</code> and <code>B != 0</code>.<br>
In this case, the number of times the loop iterates <code>= length of the longest carry-chain</code>.  </li>
</ul>

<p><strong>Algorithm to calculate the longest carry-chain:</strong>  </p>

<ul>
<li><p>First make both the binary strings <code>A</code> and <code>B</code> of equal length if they are not of equal length.</p></li>
<li><p>As we know the length of the largest carry sequence will be the answer, I just need to find the maximum carry sequence length I have occurred till now.</p></li>
<li><p>I will iterate from left to right i.e. LSB to MSB and:  </p>

<ul>
<li><code>if carry + A[i] + B[i] == 2</code> means that bit marks the start of carry-sequence, so <code>++curr_carry_sequence</code> and <code>carry = 1</code>.  </li>
<li><code>if carry + A[i] + B[i] == 3</code> means the carry which was forwarded by previous bit addition is consumed here and this bit will generate the new carry and length of carry-sequence will reset to 1 i.e. <code>curr_carry_sequence = 1</code> and <code>carry = 1</code>.  </li>
<li><code>if carry + A[i] + B[i] == 1 or 0</code> means carry generated by the previous bit resolves here and it will mark the end of the carry-sequence, so the length of the sequence will reset to 0. i.e. <code>curr_carry_sequence = 0</code> and <code>carry = 0</code>.</li>
</ul></li>
<li><p>Now if <code>curr_carry_seq</code> length is <code>&gt;</code> than <code>max_carry_sequence</code>, then you update the <code>max_carry_sequence</code>.  </p></li>
<li><p>Answer would be <code>max_carry_sequence + 1</code>.  </p></li>
</ul>

<p><strong>Solution source-code in C</strong>  </p>

<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;string.h&gt;
#include&lt;stdbool.h&gt;
#include&lt;assert.h&gt;

#define MAX_STRING_LENGTH 100001

static int compute_loop_iteration(const char *const, const char *const);
static bool check_all_zeroes(const char *const);

int main(void) {
    int test;
    scanf("%d", &amp;test);
    assert(test &gt; 0 &amp;&amp; test &lt; 100001);
    while(test--) {
        char a[MAX_STRING_LENGTH],b[MAX_STRING_LENGTH];
        scanf("%s%s", a,b);
        const size_t len_a = strlen(a), len_b = strlen(b);
        char *binary_string_A, *binary_string_B;
        binary_string_A = binary_string_B = NULL;
        if(len_a &lt; len_b) {
            binary_string_A = calloc((len_b + 1), sizeof(char));
            memset(binary_string_A, '0', (sizeof(char) * (len_b - len_a)));
            memmove(&amp;binary_string_A[len_b - len_a], a, (sizeof(char) * len_a));
            binary_string_B = calloc((len_b + 1), sizeof(char));
            snprintf(binary_string_B,len_b + 1, "%s", b);
        } else if(len_a &gt; len_b) {
            binary_string_B = calloc((len_a + 1), sizeof(char));
            memset(binary_string_B, '0', (sizeof(char) * (len_a - len_b)));
            memmove(&amp;binary_string_B[len_a - len_b], b, (sizeof(char) * len_b));
            binary_string_A = calloc((len_a + 1), sizeof(char));
            snprintf(binary_string_A,len_a + 1, "%s", a);
        } else {
            binary_string_A = calloc((len_a + 1), sizeof(char));
            snprintf(binary_string_A,(len_a + 1), "%s", a);
            binary_string_B = calloc((len_b + 1), sizeof(char));
            snprintf(binary_string_B,(len_b + 1), "%s", b);
        }
        int loop_count = 0;
        if(check_all_zeroes(binary_string_B)) {
            loop_count = 0;
        } else if(check_all_zeroes(binary_string_A)) {
            loop_count = 1;
        } else if(!strcmp(binary_string_A,binary_string_B)) {
            loop_count = 2;
        } else {
            loop_count = compute_loop_iteration(binary_string_A, binary_string_B);
        }
        printf("%u\n", loop_count);
        free(binary_string_A);
        free(binary_string_B);
    }
    return EXIT_SUCCESS;
}

static bool check_all_zeroes(const char *const binary_string) {
    bool is_zeroes = true;
    for(unsigned int i = 0; '\0' != binary_string[i]; ++i) {
        if('0' != binary_string[i]) {
            is_zeroes = false;
            break;
        }
    }
    return is_zeroes;
}

static int compute_loop_iteration(const char *const binary_string_A, const char *const binary_string_B) {
    const size_t limit = strlen(binary_string_A);
    int carry, current_carry_seq_len, max_carry_seq_len;
    carry = current_carry_seq_len = max_carry_seq_len = 0;
    for(int i = limit - 1; i &gt;= 0; --i) {
        carry += (binary_string_A[i] - '0') + (binary_string_B[i] - '0');
        switch(carry) {
            case 3:
                current_carry_seq_len = 1;
                carry -= 2;
                break;
            case 2:
                --carry;
                ++current_carry_seq_len;
                break;
            default:
                carry = current_carry_seq_len = 0;
                break;
        }
        if (current_carry_seq_len &gt; max_carry_seq_len) {
            max_carry_seq_len = current_carry_seq_len;
        }
    }
    return max_carry_seq_len + 1;
}
</code></pre>
    </div>