<div class="s-prose s-prose__disable-spoiler-hover js-post-body" itemprop="text">
<h1><code>skip_list.h</code></h1>

<pre><code>#include &lt;map&gt;          // std::pair
#include &lt;random&gt;       // generation of the levels
#include &lt;vector&gt;       // for head implementation
</code></pre>

<p>You're missing quite a few includes for some of the stuff you use in your implementation. While trying to keep the number of includes down is commendable, you have cut it down a bit too far. Your code may "work" on one compiler because their standard library happens to be laid out in a way that everything you need ends up included by these three headers, but that won't be true for all. I'd bet big money that this won't compile on at least a few of the major standard library implementations.</p>

<p>If I take a list of all the <code>std</code> elements in the header:</p>

<ul>
<li><code>vector</code> (<code>&lt;vector&gt;</code>)</li>
<li><code>pair</code>/<code>make_pair</code> (<code>&lt;utility&gt;</code>)</li>
<li><code>size_t</code> (<code>&lt;cstddef&gt;</code>, <code>&lt;cstdlib&gt;</code> and a bunch of others)</li>
<li><code>conditional</code> (<code>&lt;type_traits&gt;</code>)</li>
<li><code>move()</code> (<code>&lt;utility&gt;</code>)</li>
<li><code>ostream</code> (<code>&lt;ostream&gt;</code>; can't just use <code>&lt;iosfwd&gt;</code> because we need <code>std::ostream</code>'s implementation)</li>
<li><code>mt19937</code> (<code>&lt;random&gt;</code>)</li>
<li><code>random_device</code> (<code>&lt;random&gt;</code>)</li>
<li><code>aligned_alloc()</code> (<code>&lt;cstdlib&gt;</code>)</li>
<li><code>free()</code> (<code>&lt;cstdlib&gt;</code>)</li>
<li><code>for_each()</code> (<code>&lt;algorithm&gt;</code>)</li>
<li><code>begin()</code>/<code>end()</code> (<code>&lt;iterator&gt;</code>)</li>
</ul>

<p>then the minimal list of headers you'll need is:</p>

<pre><code>#include &lt;algorithm&gt;
#include &lt;cstdlib&gt;
#include &lt;iterator&gt;
#include &lt;ostream&gt;
#include &lt;random&gt;
#include &lt;type_traits&gt;
#include &lt;utility&gt;
#include &lt;vector&gt;
</code></pre>

<p>Note that you don't need <code>&lt;map&gt;</code>. Including it just for <code>std::pair</code> is massive overkill.</p>

<p>If you're really concerned about compile times, you can cut out <code>&lt;iterator&gt;</code> by using <code>head.begin()</code> and <code>head.end()</code> rather than <code>std::begin(head)</code> and <code>std::end(head)</code>. The <code>begin()</code>/<code>end()</code> free functions are the right thing to use by default, and in generic code. But in this case, you know that <code>head</code> is a vector, and if <em>that</em> changes, a whole hell of a lot more is going to have to change in your code than just the begin/end iterator functions. (And if you <em>do</em> make that change, and the new type of <code>head</code> doesn't have a <code>begin()</code>/<code>end()</code>, it will be a noisy fail - it won't compile - so you'll know to fix it easily.)</p>

<p>Another header possibly worth removing is <code>&lt;algorithm&gt;</code>. Using <code>std::for_each()</code> is absolutely the right thing to do normally. But if you are concerned about compile times, you can replace it easily with a <code>for</code> loop and a comment that it's just doing <code>for_each()</code>. <code>&lt;algorithm&gt;</code> is a particularly heavyweight header - it has <em>tons</em> of template functions, many of which have multiple static-dispatch optimized versions - so it's worth removing if you can manage it. (I wouldn't recommend removing <code>&lt;algorithm&gt;</code> if you were using more complicated algorithms... but <code>for_each()</code> is hard to screw up.)</p>

<p>Note that I'm not saying you <em>should</em> remove <code>&lt;iterator&gt;</code> and <code>&lt;algorithm&gt;</code>... realistically speaking, sooner or later most every non-trivial translation unit is going to need those anyway. I'm just saying that if you're concerned about compile times, you <em>could</em>.</p>

<p>But that's about the limit of what you can safely remove and still be portably compilable.</p>

<pre><code>template&lt;typename IT, bool is_const&gt;
class iterator_base {
</code></pre>

<p>It is unwise to use something like <code>IT</code> as an identifier. All caps (or "screaming snake case") is conventionally assumed to be the domain of the preprocessor. (Granted, anyone defining macros with names like <code>IT</code> deserves whatever grief they get.)</p>

<p>You could use <code>It</code> instead. But <code>IT</code>/<code>It</code> is not a very helpful name here. That parameter <em>really</em> represents the iterator's value type. So you could use <code>ValueType</code>.</p>

<p>Just as a suggestion, since you're declaring the <code>const</code>-ness with the value type, you don't really need the <code>is_const</code> parameter. That's really just duplicating information. You could do:</p>

<pre><code>template &lt;typename ValueType&gt;
class iterator_base {
    using value_type = ValueType;
    using node_type = std::conditional_t&lt;std::is_const_v&lt;ValueType&gt;, Skip_node const, Skip_node&gt;;

    // ...

};

using iterator       = iterator_base&lt;value_type&gt;;
using const_iterator = iterator_base&lt;value_type const&gt;;
</code></pre>

<p>and then you wouldn't have to worry about what <code>iterator_base&lt;value_type const, false&gt;</code> is.</p>

<pre><code>iterator_base()
    : curr{ nullptr }
{
};
</code></pre>

<p>I think you've got a stray semi-colon there (and in the next constructor).</p>

<p>If you'd set <code>curr</code> to <code>nullptr</code> as an aggregate initializer (in other words, define <code>node_type* curr = nullptr;</code> in the class), then you could just use <code>= default;</code> here.</p>

<p>Something you really should consider doing for all the functions in your iterator class is adding <code>noexcept</code> and <code>constexpr</code> whenever possible. The reasoning is that a fairly normal workload for a container is to be filled up with data once, then searched many, many times during the run of the program, then cleared out at the end. Even if the container's elements are constantly being added and removed, it's probably still true that you're going to be iterating <em>way</em> more than anything else you might be doing with the container.</p>

<p>Thus, you want to make your iterators as <em>fast</em> and as flexible as possible. There's no reason either of the constructors can't be both <code>constexpr</code> and <code>noexcept</code>. (They should be in any case, because you use them in <code>noexcept</code> <code>begin()</code>/<code>end()</code> functions in <code>Skip_list</code>.) In fact, pretty much every function in the iterator can be both! (Except <code>operator++</code> can't be <code>constexpr</code> because it uses <code>vector</code>'s <code>operator[]</code>, which isn't <code>constexpr</code>... yet!)</p>

<pre><code>explicit iterator_base(node_type* pos)
    : curr{ pos }
{
};
</code></pre>

<p>This probably shouldn't be part of the public interface. You should look into making this private, or otherwise accessible only by <code>Skip_list</code>.</p>

<pre><code>iterator_base&amp; operator=(const iterator_base&amp; other)        // copy assignment
{
    curr = other.curr;
    return *this;
}
</code></pre>

<p>You don't need this - it's just the default, implicitly-generated implementation. And in fact, defining it breaks stuff. Once you define copy assignment <em>or</em> copy construction <em>or</em> the destructor, you suppress the move ops.</p>

<p>The iterator class doesn't need <em>any</em> of the implicitly generated operations customized <em>except</em> default construction (and even that could be defaulted if you used an in-class initializer for <code>curr</code>). So don't customize any of them.</p>

<pre><code>bool operator&gt;(const iterator_base&amp; b) const {
    ////assume nullptr is the biggest element
    if (curr != nullptr &amp;&amp; b.curr != nullptr)
        return curr-&gt;value.first &gt; b.curr-&gt;value.first;
    else if (curr == nullptr &amp;&amp; b.curr != nullptr)
        return true;
    else    // (curr != nullptr &amp;&amp; b == nullptr)
        return false;
}
</code></pre>

<p>I'm about to dive into a detailed bit about iterators, but before I do, I think the logic in the above function is broken. If I'm reading it right, you are saying that iterators compare greater than if what they <em>point</em> to compares greater than?</p>

<p>In other words, if you have a two-element list with contents <code>{ 100, 5 }</code>, and <code>it1</code> points to the first element (it's what you get from <code>begin()</code>) while <code>it2</code> points to the second element... then even though <code>(++it1) == it2</code>, you're saying that <code>it1 &gt; it2</code>. So <code>it2</code> is after <code>it1</code>, but <code>it1 &gt; it2</code> (because <code>100 &gt; 5</code>). Am I understanding that correctly?</p>

<p>That logic seems a bit broken to me: an iterator should be greater than another iterator if it is after it... regardless of what the two iterators point to. If you want to compare what the iterators point to, that should be <code>*it1 &gt; *it2</code>.</p>

<p>In any case, I'd say that you shouldn't bother fixing this function... because you shouldn't have it at all. To explain why... well, let's get into iterator categories.</p>

<h2>Iterator categories</h2>

<p>So you're making an iterator type. Awesome. But there's more to an iterator type than just naming it <code>iterator</code> and returning it from <code>begin()</code> and <code>end()</code>.</p>

<p>You need to start by looking at the <a href="https://en.cppreference.com/w/cpp/named_req/Iterator" rel="nofollow noreferrer">basic iterator requirements</a>. They are:</p>

<ol>
<li>CopyConstructible</li>
<li>CopyAssignable</li>
<li>Destructible</li>
<li>Swappable</li>
<li><code>std::iterator_traits&lt;It&gt;</code> has member typedefs <code>value_type</code>, <code>difference_type</code>, <code>reference</code>, <code>pointer</code>, and <code>iterator_category</code></li>
<li>Dereferenceable (generally) - that is, <code>*r</code> works</li>
<li>Incrementable - that is, <code>++r</code> works</li>
</ol>

<p>Your <code>iterator_base</code> type supports 1-3 by default, no problem (the implicitly generated operations all work fine). Since the type is movable, it's swappable, so that covers 4. You've implemented <code>operator*</code> and <code>operator++</code>, so that covers 6 and 7. That leaves 5.</p>

<p><code>iterator_base</code> has <code>value_type</code>. That just leaves <code>difference_type</code>, <code>reference</code>, <code>pointer</code>, and <code>iterator_category</code>.</p>

<p><code>difference_type</code> can just be <code>std::ptrdiff_t</code>, unless you have a reason to make it something else. You'll need to include <code>&lt;cstddef&gt;</code> to get it, but that's a trivial header.</p>

<p><code>pointer</code> and <code>reference</code> can just be <code>value_type*</code> and <code>value_type&amp;</code> respectively. No problems there.</p>

<p>That just leaves <code>iterator_category</code>. <em>This</em> is the one you should give the most thought to.</p>

<p>Every C++ programmer should familiarize themselves with the iterator categories, so let's review. The standard iterator categories are:</p>

<ul>
<li>InputIterator/OutputIterator

<ul>
<li>ForwardIterator

<ul>
<li>BidirectionalIterator

<ul>
<li>RandomAccessIterator</li>
</ul></li>
</ul></li>
</ul></li>
</ul>

<p>So which iterator category is right for <code>Skip_list</code>?</p>

<p>This a design decision you have to make, but you'll usually be constrained by practical considerations. If I have an iterator to some element in the middle of a <code>Skip_list</code> is it <em>practical</em> to go <em>backwards</em>? If no, then you don't have a BidirectionalIterator - at best you have ForwardIterator. If I have an iterator pointing to the start of a skip list, can I copy it, then increment <em>both</em> iterators separately, and have <em>both</em> point to the same element (in other words, if <code>it1 == it2</code> (and both are valid and not past-the-end), then <code>++it1 == ++it2</code>)? Seems so. So it sounds like the natural iterator category for <code>Skip_list</code> is ForwardIterator.</p>

<p>Okay, assuming your iterator is a ForwardIterator, what are the requirements? They are (ignoring dereferencing):</p>

<ol>
<li>DefaultConstructible</li>
<li>multipass</li>
<li><code>reference</code> <em>must</em> be <code>value_type&amp;</code> (or <code>value_type const&amp;</code>)</li>
<li>equality and inequality comparison defined over the whole sequence (but not necessarily between different sequences)</li>
<li><code>it++</code></li>
<li>From InputIterator/OutputIterator:

<ol>
<li>EqualityComparable</li>
<li><code>it1 != it2</code></li>
<li><code>++it</code></li>
<li>From Iterator

<ol>
<li>(already covered above)</li>
</ol></li>
</ol></li>
</ol>

<p>So <code>iterator_base</code> needs:</p>

<ul>
<li>default constructor =&gt; (you've got this already)</li>
<li>multipass capable =&gt; (you've got this already)</li>
<li>(in)equality defined over whole sequence =&gt; (you've got this already)</li>
<li><code>value_type</code> =&gt; (you've got this already)</li>
<li><code>difference_type</code> =&gt; <code>std::ptrdiff_t</code></li>
<li><code>reference</code> =&gt; <code>value_type&amp;</code></li>
<li><code>pointer</code> =&gt; <code>value_type*</code></li>
<li><code>iterator_category</code> =&gt; <code>std::forward_iterator_tag</code></li>
<li><code>operator==</code> =&gt; (you've got this already)</li>
<li><code>operator!=</code> =&gt; (you've got this already)</li>
<li><code>operator++</code> (prefix) =&gt; (you've got this already)</li>
<li><code>operator++</code> (postfix) =&gt; missing! (but trivial to implement as just <code>auto temp = *this; ++(*this); return temp;</code>)</li>
</ul>

<p>What's important to note is which operations are <em>NOT</em> there:</p>

<ul>
<li><code>operator&gt;</code></li>
<li><code>operator&lt;</code></li>
<li><code>operator&gt;=</code></li>
<li><code>operator&lt;=</code></li>
<li><code>operator+=</code></li>
<li><code>operator+</code></li>
</ul>

<p>Since your iterator is only going to be a forward iterator, defining those operations is just a waste of time. No algorithm is going to use them.</p>

<p>You see, understanding the iterator categories is not just important for knowing which functions your iterator needs... it's also important for understand which functions your iterator <em>doesn't</em> need.</p>

<p>So basically, and I know this sucks, I'm suggesting that you throw out every function in <code>iterator_base</code> except:</p>

<ul>
<li><code>iterator_base()</code></li>
<li><code>iterator_base(node_type*)</code> (though this shouldn't be part of the public interface; up to you whether it's worth hiding or not)</li>
<li><code>operator==</code></li>
<li><code>operator!=</code></li>
<li><code>operator++</code></li>
<li><code>operator*</code></li>
<li><code>operator-&gt;</code></li>
</ul>

<p>and then <em>adding</em>:</p>

<ul>
<li>a typedef for <code>difference_type</code> (set to <code>std::ptrdiff_t</code>)</li>
<li>a typedef for <code>reference</code> (set to <code>value_type&amp;</code>)</li>
<li>a typedef for <code>pointer</code> (set to <code>value_type*</code>)</li>
<li>a typedef for <code>iterator_category</code> (set to <code>std::forward_iterator_tag</code>)</li>
<li><code>operator++(int)</code></li>
</ul>

<p>and all that will make <code>iterator_base</code> a standard-library conforming iterator.</p>

<p>Note that if you think you can implement <code>iterator_base</code> with an <code>operator--</code>, then maybe you could make it a bidirectional iterator. Maybe even random access. But if you <em>can't</em> do those things, don't bother. In particular, the way you've implemented <code>operator+</code>/<code>operator+=</code>, it's really just looping over <code>operator++</code>, which is not the point of <code>operator+</code>/<code>operator+=</code>. I can do that myself with <code>std::next()</code> or <code>std::advance()</code>.</p>

<p>Alright, that's enough iterator evangelizing, back to the code....</p>

<pre><code>iterator_base&amp; operator++()
// if next element is empty dont increase more
{
    if (curr == nullptr)
        return *this;

    curr = curr-&gt;next[0];
    return *this;
}
</code></pre>

<p>That <code>if</code> test bothers me, because you're testing something that should literally <em>never</em> happen, and quietly hiding a critical logic error. The right thing to do here is to either assert, or rely on contracts, or just throw/terminate when it happens. Asserting or using contracts is particularly nice, because once testing is done, that check can go away. And that's important, because, remember, iterators should be <em>fast</em>.</p>

<p>So that's it for <code>iterator_base</code>... now back to <code>Skip_list</code>.</p>

<pre><code>~Skip_list() noexcept                   // destructor
{
    free_all_nodes(head[0]);
}
</code></pre>

<p>You don't need to specify that destructors are <code>noexcept</code>; they are by default. It doesn't hurt, though.</p>

<pre><code>Skip_list(const Skip_list&amp; other)               // copy constructor
{
    try {
        copy_nodes(other);
    }
    catch (...) {                   // if copy constructor fails, clean up mess and re-throw
        free_all_nodes(head[0]);
        throw;
    }
}

Skip_list&amp; operator=(const Skip_list&amp; other)        // copy assignment
{
    auto backup = std::move(head);  // keep backup to provide better exception guarantee

    try {
        copy_nodes(other);
    }
    catch (...) {
        free_all_nodes(head[0]);
        head = std::move(backup);
        throw;
    }

    free_all_nodes(backup[0]);

    return *this;
}
</code></pre>

<p>All of the above is correct (assuming <code>copy_nodes()</code> works). However, you've got a bit of code duplication going on.</p>

<p>Whenever you're writing a type that manages resources, there are really only two patterns for handling the copy ops:</p>

<ol>
<li>Write the copy constructor, then write copy assignment using the copy-and-swap idiom. This is safer, but less efficient.</li>
<li>Write the copy assignment, then write copy construction as default-construct-and-assign. This is more efficient, but dangerous.</li>
</ol>

<p>Deciding which one to use is fairly easy:</p>

<ol>
<li>If your type can reuse memory <strong><em>AND</em></strong> you can implement reusing that memory safely, use option 2. (For example, <code>std::vector</code> and <code>std::string</code> can reuse existing capacity when copying.)</li>
<li>Otherwise, use option 1.</li>
</ol>

<p><code>Skip_list</code> can reuse memory. So the big question is... can you do the copy while reusing memory <em>safely</em>?</p>

<p>The way I see it, that depends on two things:</p>

<ol>
<li>The source list is <em>smaller</em> than the destination list (you are copying a smaller list into a bigger one) or the same size. If the source list is bigger, the vectors may need to reallocate for resizing, which could throw.</li>
<li>The <code>value_type</code> is nothrow copy assignable (<code>std::is_nothrow_copy_assignable</code>).</li>
</ol>

<p>So here's your design decision: You can take the easy path and just write a good copy constructor, then use copy-and-swap for your copy assignment. Or you can take the hard path for maximum performance, and write a badass copy assignment operator that falls back to copy-and-swap if the destination list has less capacity or <code>value_type</code> is not nothrow copy assignable, but otherwise does an in-place copy that reuses the existing capacity.</p>

<p>If you take the latter option, your code might look something like this:</p>

<pre><code>Skip_list(Skip_list const&amp; other) :
    Skip_list{}
{
    *this = other;
}

auto operator=(Skip_list const&amp; other) -&gt; Skip_list&amp;
{
    // If the value_type isn't nothrow copy assignable, don't even
    // bother.
    if constexpr (!std::is_nothrow_copy_assignable&lt;value_type&gt;)
    {
        copy_and_swap_with_(other);
    }
    else
    {
        // ??? should either be size() or some way to determine
        // capacity
        if (??? &gt;= other.size())
        {
            copy_in_place_(other, head); // this should never throw
        }
        else
        {
            copy_and_swap_with_(other);
        }
    }

    return *this;
}

static auto copy_and_swap_with_(Skip_list const&amp; other)
{
    auto temp_head = std::vector&lt;Skip_node*&gt;(other.head.size(), nullptr);

    copy_in_place_(other, temp_head);

    // By the time we get here, the dangerous copying is done.
    std::swap(head, temp_head);
}

static auto copy_in_place_(Skip_list const&amp; other, std::vector&lt;Skip_node*&gt;&amp; head)
{
    // An algorithm that tries to reuse any existing vector
    // capacity and allocated nodes as it copies from other.head
    // to head. If other's contents can fully fit in head and its
    // descendants, then there should be no allocations at all.
}
</code></pre>

<p>That's complicated stuff! But it could be worth the performance gain if you're bold. Otherwise, the easy option is:</p>

<pre><code>Skip_list(Skip_list const&amp; other)
{
    try
    {
        // You might as well implement copy_nodes() right here,
        // because you won't need it anywhere else.
        copy_nodes(other);
    }
    catch (...)
    {
        free_all_nodes(head[0]);
        throw;
    }
}

auto operator=(Skip_list const&amp; other) -&gt; Skip_list&amp;
{
    using std::swap;

    auto temp = other;
    swap(temp, *this);
    return *this;
}
</code></pre>

<p>On to the move ops....</p>

<pre><code>    Skip_list(Skip_list&amp;&amp; other) noexcept                       // move constructor
        :head{ std::move(other.head) }
    {
        other.head.assign(1, nullptr);
    }

    Skip_list&amp; operator=(Skip_list&amp;&amp; other) noexcept            // move assignment
    {
        if (this != &amp;other) {
            free_all_nodes(head[0]);
            head = std::move(other.head);
            other.head.assign(1, nullptr);
        }

        return *this;
    }
</code></pre>

<p>The move constructor is fine, but the move assignment operator concerns me.</p>

<p>The problem with it is that freeing all the nodes is an expensive operation - especially if the list is really large. That defeats the whole purpose of move ops. When I move something, I expect it to be as fast as computerly possible. Waiting for a massive list to get freed level by level, node-by-node, with all the attendant locking that a multi-thread-aware free store will require... it's not something I want to sit around waiting for if I'm moving something.</p>

<p>The smart way to implement move ops for most complex types is to first implement swapping:</p>

<pre><code>friend auto swap(Skip_list&amp; a, Skip_list&amp; b) noexcept
{
    using std::swap;
    swap(a.head, b.head);
}

Skip_list(Skip_list&amp;&amp; other) noexcept :
    Skip_list{}
{
    using std::swap;
    swap(*this, other);
}

auto operator=(Skip_list&amp;&amp; other) -&gt; Skip_list&amp; noexcept
{
    using std::swap;
    swap(*this, other);
    return *this;
}
</code></pre>

<p>That pattern is pretty universal, and it's almost impossible to beat the efficiency even before optimization. If you look carefully, you'll notice that your existing implementations were really just swapping already, more or less.</p>

<pre><code>size_type size() const noexcept         // return count of nodes
{
    Skip_list&lt;Key, T&gt;::size_type counter = Skip_list&lt;Key, T&gt;::size_type{};

    for (auto index = head[0]; index != nullptr; index = index-&gt;next[0], ++counter);

    return counter;
}
</code></pre>

<p>Just really technical and nitpicky note: Your <code>size()</code> function is O(n). The standard library generally expects <code>size()</code> to be O(1). I know that it's a bit of a silly requirement, but that's how it is. That's why <code>std::forward_list</code> doesn't have <code>size()</code> (even though it does have <code>resize()</code> and <code>max_size()</code>, go figure).</p>

<p><em>Technically</em> to be standards-conformant, what you'd have to do is keep a size member to keep track of the size (and maybe while you're at it, a capacity member to keep track of the capacity). But frankly, I wouldn't sweat it.</p>

<pre><code>size_type max_size() const noexcept
{
    return size_type{ static_cast&lt;size_type&gt;(-1) };
}
</code></pre>

<p>While getting the max value of an unsigned type this way "works", it's kinda hacky. For clarity you should really do <code>return std::numeric_limits&lt;size_type&gt;::max();</code>.</p>

<pre><code>// ------------element access
mapped_type&amp; operator[] (const key_type&amp; key)
{
    return find(key)-&gt;second;
}
mapped_type&amp; operator[] (key_type&amp;&amp; key)
{
    return find(key)-&gt;second;
}
</code></pre>

<p>Given the stated intention of matching the mapping interface, shouldn't these functions insert the key and a value-initialized value if the find fails?</p>

<pre><code>// ------------modifiers
std::pair&lt;iterator, bool&gt; insert(const value_type&amp; value);
size_type erase(const key_type&amp; key);   // search for an element and erase it from the skip list
</code></pre>

<p>I'd say you're missing some very important overloads:</p>

<pre><code>// *very* important for efficient insertions
auto insert(value_type&amp;&amp;) -&gt; std::pair&lt;iterator, bool&gt;;

// *very* important for efficient removals
auto erase(const_iterator) -&gt; iterator;
auto erase(iterator) -&gt; iterator;
</code></pre>

<p>and quite a few existing functions can be implemented efficiently using these.</p>

<p>Whew, that takes us to the end of the <code>Skip_list</code> declaration.</p>

<p>On to the externally-defined functions!</p>

<pre><code>template&lt;typename Key, typename T&gt;
std::pair&lt;typename Skip_list&lt;Key,T&gt;::iterator, bool&gt; Skip_list&lt;Key,T&gt;::insert(const value_type&amp; value)
</code></pre>

<p>The first concern I have with this function is that it's <em>way</em> too complicated. Surely the logic can be broken up into smaller components. It seems to me that insertion is a matter of first calling <code>lower_bound()</code> (in the <code>std::map</code> interface), then if the returned iterator isn't <code>end()</code> and the its key equals the key of <code>value</code> replacing <code>second</code>... otherwise doing an actual insert before the iterator. Granted I'm simplifying because <code>std::map</code> has bidirectional iterators - you'd need a slightly different interface. But the point is: one function, one task. Right now <code>insert()</code> is doing two tasks: 1) finding the insert position; and 2) doing the insert.</p>

<p>The second concern is that its semantics are... weird. <code>std::map</code>'s <code>insert()</code> either inserts a new key/value pair or does nothing. <em>This</em> insert can insert a new key/value pair, do nothing, <em>or</em> update a value, depending on, it looks like, a flip of a coin. If that's intentional, that's fine... but it probably means you have to give up masquerading as a <code>std::map</code>. How do I distinguish between the three cases, anyway? The <code>bool</code>, if <code>true</code>, tells me that the value's been updated... but it doesn't tell me whether the key was already in the list or not (which is what <code>std::map</code>'s <code>bool</code> tells me). You may need a different return value - perhaps a custom type that has the iterator and an enumeration that describes what actually happened.</p>

<p>The third concern is that you have some leakage issues. Just take a look at the first few lines:</p>

<pre><code>const auto insert_level = generate_level();     // top level of new node
const auto insert_node = allocate_node(value, insert_level);
Skip_list::Skip_node* old_node = nullptr;

while (head.size() &lt; insert_level) {
    head.push_back(nullptr);
}
</code></pre>

<p><code>allocate_node()</code> allocates the node - <em>looooong</em> before you even know if you need it, by the way - and then you do <code>push_back()</code> on head. <code>push_back()</code> might throw, and if it does, you leak the node.</p>

<p>Even if you fix that issue, there's a larger issue that you allocate this node even though there are paths where it's not needed. The logic of when/if the new node is used is buried within <code>if</code>s within <code>if</code>s within loops.</p>

<p>I think the first step of working out a function like this is to figure out exactly which operations can throw. <em>Most</em> of what you're doing in this function is just integer and pointer compares, pointer swapping, and constructing/assigning <code>pair</code>s (of <code>iterator</code> and <code>bool</code>) and <code>iterator</code>s, which is all <code>noexcept</code>. The things that might throw are:</p>

<ul>
<li>changing the size of the <code>head</code> vector</li>
<li>allocating a new node</li>
<li><code>node-&gt;value.first &gt; value.first</code> and <code>node-&gt;value.first == value.first</code></li>
<li><code>node-&gt;value.second = value.second</code></li>
<li>some stuff in <code>generate_level()</code> can also technically throw, but if it does, your whole program is crashing, so it's not really a concern, but we'll consider it anyway</li>
</ul>

<p>Your goal should be do absolutely nothing to the <code>Skip_list</code> data structure until you're past all that dangerous stuff, so that if any of it throws, the <code>Skip_list</code> itself remains unchanged - this is the strong exception guarantee.</p>

<p>So keeping all that in mind, your plan should be something like this:</p>

<ol>
<li>Generate your insert level. This shouldn't throw (if it does, your program terminates), but even if it does, no harm, because you haven't changed anything yet.</li>
<li>Search through the list for where you'll be inserting/replacing the node. If anything throws here, no harm, because you haven't changed anything. After this phase, you should never need to use <code>node-&gt;value.first &gt; value.first</code> or <code>node-&gt;value.first == value.first</code> again (so you'll probably need a flag saying whether you found the key exactly or not).</li>
<li>If you found the key exactly, and its level is higher than your insert level, do <code>node-&gt;value.second = value.second</code>, and then return. If the assignment throws, no harm (assuming the value type's <code>operator=</code> implements the strong exception guarantee - if it doesn't, there's nothing you can do about it anyway).</li>
<li>Allocate the new node. If this fails, no harm, because you haven't changed anything. Put the new node in a smart pointer (I'll explain how below).</li>
<li>Resize your head to the right number of levels. If this fails, it will cause the allocated node to be freed (because you would be using a smart pointer).</li>
<li>At this point, you have done every operation that might throw. Now just insert the node... this can't fail.</li>
</ol>

<p>That gets you the strong exception guarantee, with no leakage.</p>

<p>A few details to mention:</p>

<pre><code>while (head.size() &lt; insert_level) {
    head.push_back(nullptr);
}
</code></pre>

<p>Repeated <code>push_back()</code> is something you want to avoid when you can. Vectors have plenty of functions to assist. For example:</p>

<pre><code>if (head.size() &lt; insert_level)
    head.resize(insert_level, nullptr);
</code></pre>

<p>Now, here is a major code smell:</p>

<pre><code>const auto insert_node = allocate_node(value, insert_level);

// ...

free_node(insert_node);
</code></pre>

<p>Although it's disguised by custom functions, this is basically nothing more than:</p>

<pre><code>const auto insert_node = new Skip_node{value, insert_level, nullptr};

// ...

delete insert_node;
</code></pre>

<p>and that's simply unacceptable in modern C++.</p>

<p>The <em>right</em> way to do this is with smart pointers:</p>

<pre><code>const auto insert_node = std::unique_ptr&lt;Skip_node&gt;{new Skip_node{value, insert_level, nullptr}};
// should be make_unique, but I'm making a larger point, so bear with me

// ...

// automatic cleanup
</code></pre>

<p>But of course, you can't do that, because this would clean up <code>insert_node</code> with <code>delete insert_node;</code>, and you need it to clean up with <code>free_node(insert_node);</code>. But this is exactly why <code>unique_ptr</code> has a deleter:</p>

<pre><code>// probably should be defined in Skip_list
class Skip_node_deleter
{
public:
    explicit Skip_node_deleter(Skip_list&amp; owner) noexcept :
        _owner{&amp;owner}
    {}

    auto operator(Skip_node* p) const noexcept
    {
        if (p)
            _owner-&gt;free_node(p);
    }

private:
    Skip_list* _owner;
};

const auto insert_node = std::unique_ptr&lt;Skip_node, Skip_node_deleter&gt;{
    allocate_node(value, insert_level),
    Skip_node_deleter{*this}
};

// ...

// automatic cleanup
</code></pre>

<p>Even better would be if <code>allocate_node()</code> returned <code>std::unique_ptr&lt;Skip_node, Skip_node_deleter&gt;</code>, as it probably should:</p>

<pre><code>auto insert_node = allocate_node(value, insert_level);
// note: Dropped the const. You'll see why shortly.

// ...

// automatic cleanup
</code></pre>

<p>Okay, but there are still some complications. Sometimes you <em>don't</em> want to delete the node. Sometimes the node you want to delete is not the one you got from <code>allocate_node()</code> (it's the old node).</p>

<p>No problem:</p>

<pre><code>auto insert_node = allocate_node(value, insert_level);

// Pure insertion case:
insert_node-&gt;next[index] = next[index];
next[index] = insert_node.release(); // note the added ".release()"

// Replacing old node case:
auto const old_node = std::unique_ptr&lt;Skip_node, Skip_node_deleter&gt;{node, Skip_node_deleter{*this}}; // store the old node in a unique ptr to be cleaned up
insert_node-&gt;next[index] = node-&gt;next[index];
next[index] = insert_node.release(); // note the added ".release()"
// OR, for a little less typing (although a little less clarity), you can reuse insert_node:
insert_node-&gt;next[index] = node-&gt;next[index];
next[index] = insert_node.release(); // note the added ".release()"
insert_node.reset(node); // store the old node in the unique_ptr, so it gets cleaned up
</code></pre>

<p>(It may also be worthwhile to cut down on the verbiage with a helper function <code>to_unique_ptr(Skip_node* p, Skip_list&amp; o)</code> that returns <code>unique_ptr&lt;Skip_node, Skip_node_deleter&gt;{p, Skip_node_deleter{o}}</code>. That would make the <code>old_node</code> line above simplify to <code>auto const old_node = to_unique_ptr(node, *this);</code>.)</p>

<p>Basically, I suggest you treat <code>free_node()</code> like <code>delete</code>; anywhere you see it being called (except in the unique pointer's deleter class) is a code smell.</p>

<p>On to <code>erase()</code>!</p>

<pre><code>template&lt;typename Key, typename T&gt;
typename Skip_list&lt;Key,T&gt;::size_type Skip_list&lt;Key,T&gt;::erase(const key_type&amp; key)
</code></pre>

<p>Much of the commentary about <code>insert()</code> applies here, too. In this, the danger ops (the ones that might throw) are <code>next[link_index]-&gt;value.first &gt; key</code> and <code>next[link_index]-&gt;value.first == key</code>, so you don't want to <em>touch</em> anything until you're done with those.</p>

<p>In this function, you continue to iterate through the list <em>after</em> finding the node you want to erase (and removing it). Is there a reason for that? Couldn't you just <code>break</code> after the node is removed?</p>

<p>If there's some reason you have to keep iterating through the list after finding the node, then you can't do the erase until you're done iterating (more specifically, comparing). So you'd have to store the link index you want to remove, and do the actual removal after the iterating (and comparing) is done.</p>

<pre><code>template&lt;typename Key, typename T&gt;
typename Skip_list&lt;Key,T&gt;::const_iterator Skip_list&lt;Key,T&gt;::find(const key_type&amp; key) const
template&lt;typename Key, typename T&gt;
typename Skip_list&lt;Key,T&gt;::iterator Skip_list&lt;Key,T&gt;::find(const key_type&amp; key)
</code></pre>

<p>You're concerned about the duplication, and it's a legitimate concern, but it seems to me you have a trivial way out of it. Just have a private <code>const</code> <code>_find()</code> function that returns a pointer, or null. Even in a <code>const Skip_list</code>, while <code>head</code> may be a <code>const vector</code>, it's still a <code>const vector</code> of <code>Skip_node*</code>. Note, not <code>const Skip_node*</code>. From that pointer you can construct an <code>iterator</code> or a <code>const_iterator</code>.</p>

<p>I'll skip <code>debug_print()</code>, because it's just for debugging.</p>

<p><code>generate_level()</code> and <code>next_level()</code> are both cool.</p>

<pre><code>    template&lt;typename Key, typename T&gt;
    typename Skip_list&lt;Key,T&gt;::Skip_node* Skip_list&lt;Key, T&gt;::allocate_node(value_type value, size_type levels)
    {
        const auto node_size = sizeof(Skip_node) + (levels - 1) * sizeof(Skip_node*);
#ifdef _MSC_VER         // Visual Studio doesnt support  aligned alloc yet ( new in C++ 17)
        const auto node = _aligned_malloc(node_size, alignof(Skip_node));
#else
        const auto node = std::aligned_alloc(alignof(skip_node), node_size);
#endif
        new(node) Skip_node{ value, levels, nullptr };

        return reinterpret_cast&lt;Skip_node*&gt;(node);
    }
</code></pre>

<p>You have another potential memory leak here. After the allocation, you call placement <code>new</code>. That might throw, leaking the allocated memory. You should use a smart pointer. More on that in a second.</p>

<p>I'm not really sure there's any call for <code>aligned_alloc()</code> here. If you weren't concerned about supporting older compilers, then meh. But the fact that you need conditional compilation here screams out for help. If you really, <em>really</em> needed <code>aligned_alloc()</code>, then fine, you'd have to grit your teeth and live with it. But... do you? What are you <em>really</em> gaining here? <code>Skip_node</code> already contains a pointer member, and pointers are quite often the maximally-aligned type. When they're not, they're very close to. On my machine, <code>aligned_alloc()</code> <em>might</em> save you 8 bytes, or 0, so an average of 4 bytes per allocation. Personally, I'd say it's just not worth it for the added maintenance hassle of conditional compilation. Might as well just use <code>malloc()</code>.</p>

<p>(To really make the point that conditional compilation is a <em>massive</em> headache: I can tell you only tried compiling on MSVC, because didn't you notice the typo?)</p>

<p>You're also missing an opportunity to use <code>std::move()</code> with <code>value</code>.</p>

<p>And I would suggest that this function should return a smart pointer. It makes the intention of the function super clear - there's no ambiguity over who owns the returned pointer, or how it should be freed (no chance of someone using <code>std::free()</code> when they should be using <code>_aligned_free()</code>) - and it makes client code smarter and easier to write safely.</p>

<p>So putting it all together:</p>

<pre><code>template&lt;typename Key, typename T&gt;
auto Skip_list&lt;Key, T&gt;::allocate_node(value_type value, size_type levels)
    // expects levels &gt; 0
{
    const auto node_size = sizeof(Skip_node) + (levels - 1) * sizeof(Skip_node*);

    auto const free = [](auto p) { std::free(p); };
    auto node = std::unique_ptr&lt;std::byte*, decltype(free)&gt;{std::malloc(node_size), free};

    new(node.get()) Skip_node{std::move(value), levels, nullptr};

    return to_unique_ptr(reinterpret_cast&lt;Skip_node*&gt;(node.release()), *this);
}
</code></pre>

<p>It could be made even simpler if you used <code>new</code> rather than <code>malloc</code> for the allocation. It would also make it okay to not check for <code>nullptr</code> if the allocation fails (which you currently don't).</p>

<pre><code>class Skip_node_deleter
{
public:
    auto operator(Skip_node* p) const noexcept
    {
        if (p)
        {
            p-&gt;~Skip_node();

            auto raw_p = reinterpret_cast&lt;std::byte*&gt;(p);
            delete[] raw_p;
        }
    }
};

template&lt;typename Key, typename T&gt;
auto Skip_list&lt;Key, T&gt;::allocate_node(value_type value, size_type levels) -&gt;
    std::unique_ptr&lt;Skip_node*, Skip_node_deleter&gt;
    // expects levels &gt; 0
{
    const auto node_size = sizeof(Skip_node) + (levels - 1) * sizeof(Skip_node*);

    auto node = std::make_unique&lt;std::byte[]&gt;(node_size);

    new(node.get()) Skip_node{value, levels, nullptr};

    return {reinterpret_cast&lt;Skip_node*&gt;(node.release())};

    // Or better yet, define: using node_ptr = std::unique_ptr&lt;Skip_node*, Skip_node_deleter&gt;;
    // then just do:
    // return node_ptr{reinterpret_cast&lt;Skip_node*&gt;(node.release())};
}

// This function is no longer necessary.
template&lt;typename Key, typename T&gt;
void Skip_list&lt;Key,T&gt;::free_node(Skip_node* node);
</code></pre>

<p>Now, the next function is <code>copy_nodes()</code>. At this point I've made many recommendations - about how to do copying, using smart pointers for nodes, and cautions about looking for the throwing functions - that I'd just be repeating here. So I'm just going to point out the trouble spots:</p>

<pre><code>head.assign(other.head.size(), nullptr);
</code></pre>

<p>I think working with <code>head</code> directly like this is a mistake. There are a lot of things in this function that could throw, and if they do, they leave the skip list in a weird state.</p>

<p>I think what you should do is either work on a <em>new</em> head vector, then move it into <code>head</code> once the dust settles...</p>

<p>... <strong><em>OR</em></strong> if copying the values and keys is <code>noexcept</code> <em>and</em> <code>this-&gt;size()</code> is greater than or equal to <code>other.size()</code>, then trying to do all the copying with no allocations.</p>

<p>This is basically choosing between copy-and-swap and a strategy that reuses capacity. You need at least copy-and-swap; the capacity-reusing strategy can be an optimization when possible.</p>

<pre><code>for (auto node = other.head[0]; node != nullptr; node = node-&gt;next[0]) {
    const auto copy_node = allocate_node(node-&gt;value, node-&gt;levels);
</code></pre>

<p>Before this loop, there are a couple of dangerous allocations for the two vectors, but they are not problematic (other than for the fact that you're using <code>head</code> directly, rather than a temporary) - if they fail, <code>*this</code> is untouched.</p>

<p>In the loop you start allocating nodes, and once the first one succeeds, if any further iterations fail, you get leaks.</p>

<p>The way to handle this is with smart pointers. Assuming you modify <code>allocate_node()</code> to return smart pointers, what you could do is allocate a vector for all the nodes you'll need. Something like this:</p>

<pre><code>template&lt;typename Key, typename T&gt;
void Skip_list&lt;Key,T&gt;::copy_nodes(const Skip_list&amp; other)
    // precondition: head isn't owner of any nodes
{
    // ...

    auto nodes = std::vector&lt;node_ptr&gt;{};
    nodes.reserve(other.size());

    for (auto node = other.head[0]; node != nullptr; node = node-&gt;next[0]) {
        nodes.push_back(allocate_node(node-&gt;value, node-&gt;levels));

        for (auto i = 0u; i &lt; copy_node-&gt;levels; ++i) {
            *tail[i] = nodes.back().get();
            tail[i] = &amp;nodes.back()-&gt;next[i];
        }
    }

    // ...

    // once the dust has settled, there's no need for us to manage
    // the nodes anymore:
    for (auto&amp;&amp; node : nodes)
        node.release();

    // ...
}
</code></pre>

<p>And that's it for the review! But before wrapping up, there's one more thing I think I should mention.</p>

<h1>Testing</h1>

<p>While I commend that you're actually <em>testing</em> your code, I'm a little concerned about how you're doing it. Your testing code is <em>huge</em>, and insanely complex (for testing code). And even worse, to check whether tests passed or not, you have to manually read through a bunch of output.</p>

<p>You <em>really</em> need to adopt a testing framework. They take care of the vast majority of the boilerplate (so you don't need to worry about testing your testing code). And using a test framework is good practice in any case, so it's not like you're wasting your time familiarizing yourself with a test framework.</p>

<p>I'll just give a very, very brief example using the Google Test Framework, because that's one of the more popular options.</p>

<p>The first thing you need to do is get the Google Test Frame work. No problem. Just clone the <a href="https://github.com/google/googletest" rel="nofollow noreferrer">git repository</a>, then <code>cd</code> into the <code>scripts</code> directory, and run <code>./fuse_gtest_files.py output</code>. That will produce a directory <code>output</code>, and within that directory is another directory called <code>gtest</code>. You can copy that directory into any project you want to do testing in.</p>

<p>Then all you need to do is create a source file(s) for your tests and add that and <code>gtest/gtest-all.cc</code> to the project sources.</p>

<p>In your case, your test file might look like this:</p>

<pre><code>#include "gtest/gtest.h"

#include "skip_list.h"

// your tests go here

int main(int argc, char* argv[]) {
    ::testing::InitGoogleTest(&amp;argc, argv);
    return RUN_ALL_TESTS();
}
</code></pre>

<p>So what exactly would you test? Well, let's start at the top:</p>

<pre><code>template&lt;typename Key,typename T&gt;
class Skip_list {
private:
    struct Skip_node;                                                       // forward declaration because iterator class needs to know about the node
    std::vector&lt;Skip_node*&gt; head = std::vector&lt;Skip_node*&gt;(1, nullptr);     // element before first element containg pointers to all the first elements of each level
public:
    using key_type = Key;
    using mapped_type = T;

    using value_type = std::pair&lt;const key_type, mapped_type&gt;;
    using size_type = std::size_t;
</code></pre>

<p>Ignore the private section - you shouldn't test private stuff - so let's start by testing the types. Let's make sure that when we do <code>Skip_list&lt;Foo, Bar&gt;</code>, <code>key_type</code> is <code>Foo</code>, <code>mapped_type</code> is <code>Bar</code>, <code>value_type</code> is <code>std::pair&lt;const Foo, Bar&gt;</code>, and <code>size_type</code> is <code>std::size_t</code>.</p>

<p>Let's start with <code>key_type</code>. How would we test that?</p>

<p>Well, it could be as simple as:</p>

<pre><code>TEST(SkipListTest, KeyTypeIsCorrect)
{
    EXPECT_TRUE((std::is_same_v&lt;typename Skip_list&lt;int, std::string&gt;::key_type, int&gt;));
}
</code></pre>

<p>That's it. The same idea goes for the other types:</p>

<pre><code>TEST(SkipListTest, MappedTypeIsCorrect)
{
    EXPECT_TRUE((std::is_same_v&lt;typename Skip_list&lt;int, std::string&gt;::key_type, std::string&gt;));
}

TEST(SkipListTest, ValueTypeIsCorrect)
{
    EXPECT_TRUE((std::is_same_v&lt;typename Skip_list&lt;int, std::string&gt;::key_type, std::pair&lt;int const, std::string&gt;&gt;));
}

TEST(SkipListTest, SizeTypeIsCorrect)
{
    EXPECT_TRUE((std::is_integral_v&lt;typename Skip_list&lt;int, std::string&gt;::size_type&gt;));
    EXPECT_TRUE((std::is_unsigned_v&lt;typename Skip_list&lt;int, std::string&gt;::size_type&gt;));
}
</code></pre>

<p>Note that in the last case we don't test <em>specifically</em> for <code>std::size_t</code>. That's because the requirement for <code>size_type</code> in containers is just an unsigned integral type. So that's what we test.</p>

<p>Each test should test <em>one</em> thing, should be as simple as possible, generally with only a single assertion at the end. (If you have multiple assertions, as in the last test above, it's because you're testing multiple aspects of one thing.) The general pattern is "arrange -&gt; act -&gt; assert": set up the scenario, do the action being tested, then check that the effects of the action are correct.</p>

<p>Here's a more involved test:</p>

<pre><code>TEST(SkipListTest, EraseActuallyErases)
{
    // ASSEMBLE the scenario.
    auto list = Skip_list&lt;int, std::string&gt;{};
    list.insert(std::pair&lt;int, std::string&gt;{42, "foo"});

    // Guard assertion (not *really* necessary because you should
    // be testing insert() separately, but a common practice).
    ASSERT_TRUE(list.find(42) != list.end());

    // ACT.
    list.erase(42);

    // ASSERT the effects.
    ASSERT_TRUE(list.find(42) == list.end());
}
</code></pre>

<p>Now, this is all fine... but you can do even better using parameterized tests.</p>

<p><code>Skip_list</code> is a template. The type tests above only test <code>Skip_list&lt;int, string&gt;</code>. But what if you'd accidentally done <code>using key_type = int;</code>. The key type test above would pass! But the key type would still be <code>int</code> even in <code>Skip_list&lt;string, float&gt;</code>.</p>

<p>What you <em>really</em> want to do is try a <em>bunch</em> of different types for <code>K</code> in <code>Skip_list&lt;K, V&gt;</code>, and verify that <code>key_type</code> is always <code>K</code>. Here's how to do that, but, fair warning, Google Test is a bit clunky for this kind of thing.</p>

<p>First, you need to define a testing class that is a template:</p>

<pre><code>template &lt;typename T&gt;
class SkipListTypesTest : public ::testing::Test {};
</code></pre>

<p>This is necessary so we can vary the type of <code>T</code>.</p>

<p>Next, we need to declare that this is a typed test:</p>

<pre><code>TYPED_TEST_CASE_P(SkipListTypesTest);
</code></pre>

<p>Next, we need to write the tests. For type-parameterized tests you use the <code>TYPED_TEST_P</code> macro rather than <code>TEST</code>. In each test, <code>T</code> is <code>TypeParam</code>.</p>

<p>Now, there's one little complication here, and that's that we don't just want a single type. <code>Skip_list</code> requires <em>two</em> template types. And then on top of that, we'd need the expected result type. How do we fit 3+ types into <code>T</code>?</p>

<p>Simple, with a <code>tuple</code>.</p>

<p>To do the type tests above, we need a tuple with:</p>

<ol>
<li>the given key type</li>
<li>the given value type</li>
<li>the expected <code>key_type</code></li>
<li>the expected <code>mapped_type</code></li>
<li>the expected <code>value_type</code></li>
</ol>

<p>So <code>T</code>, and thus <code>TypeParam</code>, is a 5-tuple.</p>

<p>The key type test becomes:</p>

<pre><code>TYPED_TEST_P(SkipListTypesTest, KeyTypeIsCorrect)
{
    using K = std::tuple_element_t&lt;0, TypeParam&gt;;
    using V = std::tuple_element_t&lt;1, TypeParam&gt;;
    using expected = std::tuple_element_t&lt;2, TypeParam&gt;;

    EXPECT_TRUE((std::is_same_v&lt;typename Skip_list&lt;K, V&gt;::key_type, expected&gt;));
}
</code></pre>

<p>And the other type tests are similar.</p>

<p>Unfortunately, we're not done with Google Test yet, because now we have to manually register all the tests:</p>

<pre><code>REGISTER_TYPED_TEST_CASE_P(SkipListTypesTest,
    KeyTypeIsCorrect,
    MappedTypeIsCorrect,
    ValueTypeIsCorrect,
    SizeTypeIsCorrect
);
</code></pre>

<p>Don't forget to add any other tests you create there.</p>

<p>And now we have to actually create the test types:</p>

<pre><code>using SkipListTypesTestTypes = ::testing::Types&lt;
    //          K            V           key_type     mapped_type  value_type
    std::tuple&lt;int,         int,         int,         int,         std::pair&lt;int const, int&gt;&gt;,
    std::tuple&lt;std::string, int,         std::string, int,         std::pair&lt;std::string const, int&gt;&gt;,
    std::tuple&lt;int,         std::string, int,         std::string, std::pair&lt;int const, std::string&gt;&gt;
&gt;;
</code></pre>

<p>You can add as many more test case data sets there as you please.</p>

<p>And finally Google Test requires us to manually instantiate everything:</p>

<pre><code>INSTANTIATE_TYPED_TEST_CASE_P(TypeTest, SkipListTypesTest, SkipListTypesTestTypes);
</code></pre>

<p>And <em>now</em> your tests will run.</p>

<p>Here's what it looks like all put together:</p>

<pre><code>#include "gtest/gtest.h"

#include "skip_list.h"

// Member type tests -----------------------------------------------
template &lt;typename T&gt;
class SkipListTypesTest : public ::testing::Test {};

TYPED_TEST_CASE_P(SkipListTypesTest);

TYPED_TEST_P(SkipListTypesTest, KeyTypeIsCorrect)
{
    using K = std::tuple_element_t&lt;0, TypeParam&gt;;
    using V = std::tuple_element_t&lt;1, TypeParam&gt;;
    using expected = std::tuple_element_t&lt;2, TypeParam&gt;;

    EXPECT_TRUE((std::is_same_v&lt;typename Skip_list&lt;K, V&gt;::key_type, expected&gt;));
}

TYPED_TEST_P(SkipListTypesTest, MappedTypeIsCorrect)
{
    using K = std::tuple_element_t&lt;0, TypeParam&gt;;
    using V = std::tuple_element_t&lt;1, TypeParam&gt;;
    using expected = std::tuple_element_t&lt;3, TypeParam&gt;;

    EXPECT_TRUE((std::is_same_v&lt;typename Skip_list&lt;K, V&gt;::mapped_type, expected&gt;));
}

TYPED_TEST_P(SkipListTypesTest, ValueTypeIsCorrect)
{
    using K = std::tuple_element_t&lt;0, TypeParam&gt;;
    using V = std::tuple_element_t&lt;1, TypeParam&gt;;
    using expected = std::tuple_element_t&lt;4, TypeParam&gt;;

    EXPECT_TRUE((std::is_same_v&lt;typename Skip_list&lt;K, V&gt;::value_type, expected&gt;));
}

TYPED_TEST_P(SkipListTypesTest, SizeTypeIsCorrect)
{
    using K = std::tuple_element_t&lt;0, TypeParam&gt;;
    using V = std::tuple_element_t&lt;1, TypeParam&gt;;

    EXPECT_TRUE((std::is_integral_v&lt;typename Skip_list&lt;K, V&gt;::size_type&gt;));
    EXPECT_TRUE((std::is_unsigned_v&lt;typename Skip_list&lt;K, V&gt;::size_type&gt;));
}

REGISTER_TYPED_TEST_CASE_P(SkipListTypesTest,
    KeyTypeIsCorrect,
    MappedTypeIsCorrect,
    ValueTypeIsCorrect,
    SizeTypeIsCorrect
);

using SkipListTypesTestTypes = ::testing::Types&lt;
    //          K            V           key_type     mapped_type  value_type
    std::tuple&lt;int,         int,         int,         int,         std::pair&lt;int const, int&gt;&gt;,
    std::tuple&lt;std::string, int,         std::string, int,         std::pair&lt;std::string const, int&gt;&gt;,
    std::tuple&lt;int,         std::string, int,         std::string, std::pair&lt;int const, std::string&gt;&gt;
&gt;;

INSTANTIATE_TYPED_TEST_CASE_P(TypeTest, SkipListTypesTest, SkipListTypesTestTypes);

// any other tests you like ----------------------------------------
TEST(SkipListTest, EraseActuallyErases)
{
    auto list = Skip_list&lt;int, std::string&gt;{};
    list.insert(std::pair&lt;int, std::string&gt;{42, "foo"});

    ASSERT_TRUE(list.find(42) != list.end());

    list.erase(42);

    ASSERT_TRUE(list.find(42) == list.end());
}

// Main ------------------------------------------------------------
int main(int argc, char* argv[]) {
    ::testing::InitGoogleTest(&amp;argc, argv);
    return RUN_ALL_TESTS();
}
</code></pre>

<p>And so on for all the other tests you'd like to run. Each member of the class should get its own test, and the iterators need to be tested too. You'll end up with a <em>bunch</em> of tiny tests - and some tests will be type-parameterized (like above, where you can run the same test with a bunch of different types), others will be value-parameterized (so you have a single test run with a bunch of different data), but not all need to be.</p>

<p>The one headache you'll have to deal with is that your code is basically all written, and now you're writing the tests after the fact. That's bad. The <em>right</em> way to do it is to write the test <em>first</em>. It will fail, of course... but you <em>want</em> that. When you see it fail, you know for sure the test is actually being tested. Only after you see the test failing do you write the code in your class to make it pass. Then once it passes, you know you're done.</p>

<p>Writing tests after the fact is a pain in the ass, because you have to be careful to make sure the test is actually running. Always write the test <em>first</em>. Found a bug? Write a test case that catches it... <em>then</em> go to fix the bug - the bug is fixed when the bug test case passes.</p>

<p>And that's finally it for the review! Hope this helped!</p>
    </div>