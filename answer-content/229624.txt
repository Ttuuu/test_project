<div class="s-prose s-prose__disable-spoiler-hover js-post-body" itemprop="text">
<p>I found a few issues, here they are (in order in which they were found). The list may seem long, but this does not mean that you did a bad job. Instead, it means that the feedback is detailed ;)</p>

<p>If some issue starts with <strong>[major]</strong>, it means that it would stop me from using your class.</p>

<ul>
<li><strong>[major]</strong> There is zero documentation.</li>
<li>The <code>Thread</code> struct is not really a thread. In fact, it just stores a single <code>std::function</code> member. Why did you name it like that?</li>
<li>The <code>Threadpool</code> has a virtual destructor. This is not necessary, because it does not make sense to inherit from it. I suggest you make it non-virtual.</li>
<li>The prefix <code>get</code> usually indicates that you return something from it. However, <code>getThread</code> does not return anything. Even though <code>t</code> is passed by reference, you do not change it. Maybe <code>addTask</code> is a better name.</li>
<li><strong>[major]</strong> If the thread pool is full, <code>getThread</code> blocks until one of the threads is free. This is bad. In addition, you use an active loop to block, which means that waiting takes 100% of one CPU core. This is really bad. The whole point of threads and thread pools is that the user does not need to wait. I suggest that you copy or move the task (your <code>std::function</code>) into the pool and execute it as soon as some thread is free. This way, <code>getThread</code> can return immediately.</li>
<li><strong>[major]</strong> The thread pool currently creates one <code>std::thread</code> for each task that is added. However, creating threads has some overhead and this will make a big difference if you have many small tasks. I suggest that you create <code>m_capacity</code> worker threads that grab the tasks from some container. This transforms your problem into a typical <em>producer-consumer problem</em> (adding a task is <em>producing</em> work, which is then <em>consumed</em> by the threads).</li>
<li><strong>[major]</strong> You are using <code>std::function&lt;void(Args...)&gt;</code> to store a single task. This means that the thread pool does not support return values. A common pattern is that <code>addTask</code> returns a <code>std::future</code> which will receive the return value after some thread completed the task. Additionally, thread pool users can use the <code>std::future</code> to check whether the task completed and they can use it to wait for completion.</li>
<li><strong>[major]</strong> The <code>getThread</code> function uses references of <code>t</code>. This means that problems will occur if <code>t</code> is destroyed while the thread is still running. This is bad, because <code>t</code> is passed by the user, so the pool has no control over its lifetime. The non-existing documentation would have been a good place to mention that <code>t</code> must not be destroyed before the task is finished :) Typically, you would <code>std::move</code> the task, which transfers the control to the pool.</li>
<li>If I understand <code>m_mutex</code> correctly, it guards <code>m_threads</code> against race conditions. This means that you want to lock the mutex whenever you use <code>m_threads</code>. Since reading from a variable while another thread modifies it is undefined behavior, you need to lock the mutex in some more places. There are some usages of <code>m_thread</code> or of its elements where the mutex is not locked (and I do not mean constructor/destructor).</li>
<li>The <code>ThreadPoolElement</code> has a <code>volatile bool</code>. Depending on compiler and platform, <code>volatile</code> may do what you think it does. However, you can not rely on that. You should use <code>std::atomic&lt;bool&gt;</code> instead.</li>
<li><code>Threadpool</code> has a lower case <code>p</code>, but <code>ThreadPoolElement</code> has an upper case <code>P</code>.</li>
</ul>

<p>I suggest that you refactor the <code>Threadpool</code> such that you do not need to create a new <code>std::thread</code> object for each task. Typically, a thread pool has a queue with pending tasks and a fixed number of worker threads. The worker threads grab tasks from the queue and complete them. This way, it is possible to add many tasks without the overhead of creating new threads.</p>

<p>You may want to look into the <code>std::packaged_task</code> and <code>std::future</code> classes, since they can simplify your implementation. You can probably get rid of the <code>Thread</code> and <code>ThreadPoolElement</code> classes.</p>
    </div>