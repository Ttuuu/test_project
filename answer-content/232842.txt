<div class="s-prose s-prose__disable-spoiler-hover js-post-body" itemprop="text">
<p>If one wants abstraction, then the interface (the menu) should be in a different file then the linked-list implementation, and should expose only function prototypes which are necessary in a header file, (the rest can be <a href="https://stackoverflow.com/questions/572547/what-does-static-mean-in-c">static</a>.) The one with <code>main</code> should drive your linked list; the linked list should have no <code>main</code>. That way, code would be interchangeable into other, more complicated programmes. In practice, one should do an <a href="https://en.wikipedia.org/wiki/Software_testing" rel="nofollow noreferrer">automated test</a> in another file to see if the, edge cases in particular, (<em>eg</em>, empty list, which is not robust,) do what one expects them to.</p>

<p>I would question this use as a <a href="https://en.wikipedia.org/wiki/Singleton_pattern" rel="nofollow noreferrer">singleton</a>, but maybe it's the way it's supposed to work. To break out of this pattern, I would accept another parameter to all functions, (except the constructor, in this case <code>newnode</code>.) In a sense, a linked-list is a tricky thing to abstract because, by definition, it's a recursive data structure, so how can one tell the middle of a list from the head? I suggest the looking at <a href="https://en.wikipedia.org/wiki/Linked_list" rel="nofollow noreferrer">Wikipedia</a>, <a href="https://en.cppreference.com/w/cpp/container/forward_list" rel="nofollow noreferrer">C++</a>, <a href="https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/LinkedList.html" rel="nofollow noreferrer">Java</a>, and <a href="https://docs.microsoft.com/en-us/dotnet/api/system.collections.generic.linkedlist-1?view=netframework-4.8" rel="nofollow noreferrer">C#</a> for existing implementations.</p>

<p>One should turn up the warnings on ones compiler: in particular, <code>#include &lt;stdio.h&gt;</code> is necessary for <code>printf</code>. (However, one should consider not using this function to make it more abstract.)</p>

<p>Beware of the effects of <code>typedef</code> on <a href="https://www.codeproject.com/Tips/1172783/Gems-for-typedef-and-namespace-in-C" rel="nofollow noreferrer">namespace</a>; the <a href="https://www.kernel.org/doc/html/v4.10/process/coding-style.html#typedefs" rel="nofollow noreferrer">Linux kernel coding style</a> would frown upon such usage. In particular, the naming of <code>q_9</code> and <code>node</code> is problematic when one gets into more complex programmes. Maybe <code>struct int_node</code> or even <code>struct int_list_node</code>?</p>

<p>When using, eg, <code>int main()</code>, beware that one is <a href="https://stackoverflow.com/questions/41803937/func-vs-funcvoid-in-c99">not using prototypes</a> and subverting the compiler's ability to type-check. One should really use <code>int main(void)</code>.</p>

<p>One doesn't check the return value of <a href="https://pubs.opengroup.org/onlinepubs/009695399/functions/malloc.html" rel="nofollow noreferrer">malloc</a>. This is bad because the function can return null and then the code has <code>temp-&gt;null=x</code>, which is potentially dereferencing a null pointer.</p>

<p>For example, <code>void count()</code> is fine for printing out the lists count on <code>stdout</code>, but maybe this should be <code>int count(void)</code>, (or even <code>size_t count(void)</code>,) the user, (of the abstract file, probably yourself,) should be able to decide what they want to do with this information. Same with the print memory freed, one doesn't want to do this all the time.</p>
    </div>