<div class="s-prose s-prose__disable-spoiler-hover js-post-body" itemprop="text">
<p>This looks very slick! I've tried it on a few things, and it speeds up <em>very</em> slow commands quite a bit. Less-slow commands, as you've noticed, are still a bit expensive.</p>

<p>A few preliminary thoughts (I'll likely add more to this post as I spend more time looking at this):</p>

<ul>
<li>The largest lag time in reading from the cache in a given shell is the time spent reading from the filesystem. Would it be possible to implement a two-teired cache that stores things in memory as a first resort, and the filesystem otherwise? Things could be pushed out of memory if they were too big or too old (memory-as-MRU). This would also make cache use between shells simpler. <code>/dev/shm</code>-type shared memory handles this for you, somewhat, with swap. However, as you've pointed out, that directory can be quite volatile and isn't present on all systems.</li>
<li>Your backgrounded <code>&amp;</code> commands should be <code>disown</code>ed; otherwise, users shells might warn them that there are backgrounded jobs when they exit, if cleanup is still running. You use subshells for these commands, but I suspect there are cases where that won't be enough to fully detach them. I may be wrong though.</li>
<li>When reading the cache and checking staleness, you can reduce subshell and command count by replacing the <code>cat</code> commands with a native Bash file-read (<code>while...do; ...; done &lt;$file</code>). Relatedly, could you replace the <code>mtime</code>-checking <code>find</code> command with a simple <code>stat</code>? It looks as though the path might be predictable enough that you don't need to search the filesystem. </li>
<li>I think you could save yourself a subshell and some complexity if you used a predictably-named cache location rather than a <code>mktemp</code>'d one. For a per-user cache shared across multiple shells, you could name it <code>someuniqueconstant-$USER</code>. To prevent shell-sharing, you could provide an option that qualified the name with <code>$$</code> as well (if you do this, beware of PID-wraparound-caused issues and fail if the PID-named temp dir exists when you first want it).</li>
<li>Larger ideas: I think you could save yourself time and subshells by abandoning <code>find</code> in favor of one of the following:

<ul>
<li><code>sqlite</code>: this is <em>almost</em> as ubiquitous as <code>find</code>, and very easy for even non-privileged users to install and use if it's not present. It's likely much faster at deletion, though it would probably impose a slight penalty on cache reads (this is where the two-tiered cache design would probably help a lot). Additionally, because of its memory mapping, SQLite could potentially yield an immense performance benefit in cases where cache values were near-simultaneously accessed from two shells at once. This would also prevent hassles encountered while writing to multiple files to out/err/exit.</li>
<li>A Bash implementation of <code>find</code> would likely be faster for very small/shallow directories without too many cached things. Since that sounds like the use case you're targeting, consider trying that out. More info can be seen at these SE questions: <a href="https://unix.stackexchange.com/questions/186767/search-for-matching-files-with-wildcards-without-using-find-in-a-bash-script">1</a> <a href="https://stackoverflow.com/questions/28711063/implementing-a-simple-version-of-find-in-a-bash-script">2</a>.</li>
</ul></li>
</ul>
    </div>