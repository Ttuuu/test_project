<div class="s-prose s-prose__disable-spoiler-hover js-post-body" itemprop="text">
<p>The time complexity is <span class="math-container">\$O(\text{listLength} * \text{numberOfLists}^2)\$</span> because the check of <em>which node is the smallest?</em> is looking at one element of each list every iteration (so each iteration's complexity is <span class="math-container">\$O(\text{numberOfLists})\$</span>, and there are <span class="math-container">\$\text{listLength} * \text{numberOfLists}\$</span> iterations.</p>

<p>You can get to <span class="math-container">\$O(\text{listLength} * \text{numberOfLists} * \log(\text{numberOfLists}))\$</span> by using a sorted list of the ListNode elements that you are checking in each iteration, instead of the unsorted array <code>listNodes</code>. Let's call this list <code>sortedNodes</code>. You can avoid checking each element of <code>sortedNodes</code> every iteration because you know the first one is the smallest, and once you take this first value into the merged list and advance the node - do a binary search to decide where to move the first element after its value has changed. (Or remove it if it got to a <code>null</code>.)</p>
    </div>