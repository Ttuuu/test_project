<div class="s-prose s-prose__disable-spoiler-hover js-post-body" itemprop="text">
<p>Consider what you are doing here.  You are generating a list of primes less than a number.  You are generating this list in order of increasing size.  One simple optimization is to seed the list with a few primes at the beginning.  In particular, 2 and 3.  Then you iterate to skip over all the even numbers.  That cuts your checks in half.</p>
<p>Now, a second point is that you don't have to divide by all numbers less than half the number.  You only have to divide by primes less than the square root of the number.  And you know what, you have a list of primes smaller than the number.  So use that in your trial division.</p>
<p>So in your prime generation function (what you call <code>storePrimes</code> but which I might call <code>load_primes</code>), call a function that divides by the primes that you already have.</p>
<pre><code>function is_divisible_from(candidate, numbers) {
    for (const n of numbers) {
        if (candidate % n === 0) {
            return true;
        }

        if (n &gt; candidate / n) {
            return false;
        }
    }

    // you should never get here
    return false;
}
</code></pre>
<p>It is quite common to generate both the remainder and the quotient at the same time.  So both <code>candidate % n</code> and <code>candidate / n</code> can be generated by one activity in many parsers.  So this is probably efficient (do timing tests if you want to be sure).  You have to do the division/remainder operation once per loop regardless.  This just uses both results where most alternatives are doing an added square root check (hopefully just once).</p>
<p>This is essentially saying that if you can find some number in the list that divides the candidate, then it is clearly a composite number and not prime.  I call this <code>is_divisible_from</code> as better describing what the function does.  But when you use it, a true result means that the number is not prime and a false result that it is.</p>
<pre><code>function load_primes(upper_bound) {
    let primes = [ 2, 3 ];

    for (let i = 5; i &lt;= upper_bound; i += 2) {
        if (!is_divisible_from(i, primes)) {
            primes.push(i);
        }
    }
}
</code></pre>
<p>There's also another optimization here, but I doubt that it will give enough savings to overcome its increased overhead.  It's possible to skip over all the divisible by three values.</p>
<p>Now you have efficiently created a list of primes in <span class="math-container">\$\mathcal{O}(n \sqrt{n})\$</span> time, where <span class="math-container">\$n\$</span> is your upper bound.  Your original was <span class="math-container">\$\mathcal{O}(n^2)\$</span> in that step.  Your original was also <span class="math-container">\$\mathcal{O}(p^3)\$</span> to use the list where <span class="math-container">\$p\$</span> was the number of primes.  But I believe that it is possible to do this in <span class="math-container">\$\mathcal{O}(p^2)\$</span> time.</p>
<p>It should be obvious that you can calculate the sums in linear time.  So keep adding to the sum until it is too large (greater than the upper bound).  Then subtract the smallest value from it until is both small enough and prime.  It's linear to check if a given number is prime (in the list).  And it's linear to generate the sums, because we don't need to check every pair of indexes.  We iterate over each left once and each right once.</p>
<pre><code>let primes = load_primes(upper_bound);
let left = 0;
let right = 0;
let sum = 2;
let result = {largestSum: sum, termsCount: 0};

while (right &lt; primes.length &amp;&amp; left &lt;= right) {
    if ((right - left &gt; result.termsCount) &amp;&amp; (0 &lt;= primes.indexOf(sum))) {
        result.largestSum = sum;
        result.termsCount = right - left;
    }

    right++;
    sum += primes[right];
    while ((sum &gt; upper_bound) &amp;&amp; (left &lt; right)) {
        sum -= primes[left];
        left++;
    }
}

result.termsCount++;
return result;
</code></pre>
<p>This works because we are looking for consecutive primes.  So we don't need to backtrack or compare most values.  We can move forward through all the possibilities that might be true, looking at a sliding window of values.</p>
    </div>