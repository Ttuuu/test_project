<div class="s-prose s-prose__disable-spoiler-hover js-post-body" itemprop="text">
<h1>The heapRemove algorithm</h1>
<p><code>heapRemove</code> appears to remove the root element from the heap. However, it implements some sort of combination of <a href="https://en.wikipedia.org/wiki/Binary_heap#Insert" rel="nofollow noreferrer">"bubble up"</a> (applied to every element) and <a href="https://en.wikipedia.org/wiki/Binary_heap#Extract" rel="nofollow noreferrer">"bubble down"</a> (also applied to every element). That's extreme overkill, and turns what should be an O(log n) operation into an O(n log n) operation - that's not good.</p>
<p>Maybe the reason your code works that way, is that your solution for removing the root element was shifting every element down by one position. Don't do that, it already costs O(n) time just to do that, and it breaks the heap property to an unncessary degree so it takes a lot of work to restore the heap. The usual (and fast) solution is taking the <em>last</em> element of the heap and drop it into <code>theHeap[0]</code>, then bubble down from the root until the heap property is restored.</p>
<h1><code>readheap</code></h1>
<p><code>readheap</code> mixes IO and algorithms, when possible I recommend separating them, and it is possible here. <code>readheap</code> also mixes tons of bubble up and bubble down, which is again overkill. Pick one strategy and use it, not both. Applying bubble up to each element results in an O(n log n) heap construction algorithm, applying bubble down <a href="https://en.wikipedia.org/wiki/Binary_heap#Building_a_heap" rel="nofollow noreferrer">in a particular way</a> can give you an O(n) heap construction algorithm.</p>
    </div>