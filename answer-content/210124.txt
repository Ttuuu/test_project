<div class="s-prose s-prose__disable-spoiler-hover js-post-body" itemprop="text">
<h1>Review to improve</h1>

<p>Mapping named objects is a pain, makes code overly complex, and increases the chance of typos and bugs.</p>

<p>This review outlines 3 ways to improve. From the most basic to very advanced with a few points in regard to your original code.</p>

<p>You say you would like to locate attribute via a numeric index. This is possible but I can guarantee you will regret that approach very quickly.</p>

<p>Programmers are inherently lazy, we write code because it makes things easier to do. Many beginners miss this point and find themselves writing huge tracts of repeated names, code, tables, and whatnot. As a classic example your code</p>

<pre><code>document.getElementById(attArray[0]).innerHTML = attObj.strength;
document.getElementById(attArray[1]).innerHTML = attObj.dexterity;
document.getElementById(attArray[2]).innerHTML = attObj.stamina;
document.getElementById(attArray[3]).innerHTML = attObj.presence;
document.getElementById(attArray[4]).innerHTML = attObj.manipulation;
document.getElementById(attArray[5]).innerHTML = attObj.composure;
document.getElementById(attArray[6]).innerHTML = attObj.intelligence;
document.getElementById(attArray[7]).innerHTML = attObj.wits;
document.getElementById(attArray[8]).innerHTML = attObj.resolve;
</code></pre>

<p>OMDG thank god for cut and paste, hey...</p>

<p>Good source code is what we call DRY (Don't Repeat Yourself). We use functions, loops, arrays, objects and more to help reduce the amount of repeated source, and thus the amount of characters we must type and the amount of code we must keep in our heads.</p>

<p>In the bottom advanced example you will see that I only named all the attributes once (ignoring the HTML which was generated by a utility app on my part), yet still have a sophisticated interface.</p>

<h2>The simplest improvement</h2>

<p>Your best bet is to rename the elements such that you can prefix or postfix to the existing name (<code>attObj</code> property names) to locate the element</p>

<p>Your HTML would look like</p>

<pre><code>&lt;!-- id is postfixed with El to indicate it is an element--&gt;
&lt;div id="strengthEl"&gt;&lt;/div&gt;
...
&lt;div id="manipulationEL"&gt;&lt;/div&gt;
</code></pre>

<p>Then your code need only the <code>attObj</code> </p>

<pre><code>const playerAtt = {strength: 0, dexterity: 0, stamina: 0, presence: 0, manipulation: 0};
for (const key of Object.keys(playerAtt)) {
    document.getElementById(key + "El").innerHTML = playerAtt[key];
}
</code></pre>

<p><strong>Note:</strong> You should not need to postfix a variable type on a variables name, <code>attObj</code> would be better named <code>attributes</code>.</p>

<p><strong>Note:</strong> The variable is a reference to (points to) the object, thus it can be a constant.</p>

<p><strong>Note:</strong> In your question you mension <code>for in</code> FORGET you ever heard of <code>for in</code> as it has a pile of caveats a mile long and requires additional code to ensure property names belong to the object. Use <code>for of</code> instead</p>

<p>That is a simple fix for your problem</p>

<h2>More improvements</h2>

<p><code>document.getElementById</code> is a node query and is excruciatingly slooowwwww... compared to alternative access methods. The general practice in JavaScript when accessing elements frequently is to store them in javascript variable. You do this as part of the setup or constructing code.</p>

<pre><code>const playerAtt = {strength: 0, dexterity: 0, stamina: 0, presence: 0, manipulation: 0};
const attElement = {};
for (const key of Object.keys(playerAtt)) { 
    attElement[key] = document.getElementById(key + "El");
}

// Then when you make changes you can access elements via the attElement obj
for (const key of Object.keys(playerAtt)) { 
    attElement[key].textContent = playerAtt[key];
}
</code></pre>

<p><strong>Note:</strong> That rather than use <code>innerHTML</code> which forces a parsing, page reflow, and knock out event handlers, use <code>textContent</code> if its only text you are writing to the page. It has no parsing or reflow overheads and is safe to use with a page full of event handlers.</p>

<h2>Advanced version</h2>

<p>This introduces a library type approach, with the complex code of writing and reading values from the object separated from the game code (via a separate JS file, best as a module but snippets here don't do modules).</p>

<p>This may be a little too much, but it is good to have in mind what can be done. There are also various frameworks that use similar approaches to this <a href="https://vuejs.org/" rel="nofollow noreferrer">VUE.js</a> for example (I have not looked at their code so I am guessing their approach)</p>

<h3>A smarter object</h3>

<p>We can improve how the attributes are displayed by creating a more complex attribute object that uses a setter to...</p>

<ol>
<li>Vet the value so that it can only ever hold correct values.</li>
<li>Knows that the value is linked to an element and thus automatically updates the element with any changes.</li>
</ol>

<p>.</p>

<pre><code>const MAX_ATT_VALUE = 5;
function WatchedObj(obj, name) {
    if (!obj) {//Just incase you call the function incorrectly. Only for development.
        throw new ReferenceError("WatchedObj requires a template object.");
    }
    const contElement = name ? document.getElementById(name + "El") : document;
    function addAttribute(obj, key, value) {
        const element = contElement.querySelector("[data-attribute-name=" + key + "]");
        Object.defineProperty(obj, name, {
            enumerable: true, 
            configurable: false, 
            get() { return value },
            set(val) {
                val = isNaN(val) ? 0 : val;
                val = val &lt; 0 ? 0 : val &gt; MAX_ATT_VALUE ? MAX_ATT_VALUE : val; 
                if (value !== val) {
                    value = val;
                    if (element) { element.textContent = value }
                }
            }
        });
    }
    const watched = {};
    for (const [key, value] of Object.entries(obj)) { 
        addAttribute(watched, key, obj);
    }
    return watched;
}
</code></pre>

<p>Now that is a lot of code with some advanced concepts in it, getters, setters, closure, destructuring, and more. The point is that once written the object represent player attributes becomes nearly a no brainer.</p>

<h3>Locating elements</h3>

<p>As it is likely that you will want to display many players, you can not use the same id for more than one element as that will force the page into quirks mode, which has a pile of performance hits. So to solve the problem of locating element we can use a selector string that will find an element based on a data attribute value. eg see HTML below to find strength for player one the following selector can be used <code>document.querySelector("#playerOneEl [data-attribute-name=strength]");</code></p>

<p>So the HTML will look like</p>

<pre><code>&lt;div id="playerOneEl"&gt;
    Strength&lt;span data-attribute-name="strength"&gt;&lt;/span&gt;
    Dexterity&lt;span data-attribute-name="dexterity"&gt;&lt;/span&gt;
    Stamina&lt;span data-attribute-name="stamina"&gt;&lt;/span&gt;
    Presence&lt;span data-attribute-name="presence"&gt;&lt;/span&gt;
    Manipulation&lt;span data-attribute-name="manipulation"&gt;&lt;/span&gt;
    Composure&lt;span data-attribute-name="composure"&gt;&lt;/span&gt;
    Intelligence&lt;span data-attribute-name="intelligence"&gt;&lt;/span&gt;
    Wits&lt;span data-attribute-name="wits"&gt;&lt;/span&gt;
    Resolve&lt;span data-attribute-name="resolve"&gt;&lt;/span&gt;
&lt;/div&gt;
&lt;div id="playerTwoEl"&gt;
    Strength&lt;span data-attribute-name="strength"&gt;&lt;/span&gt;
    Dexterity&lt;span data-attribute-name="dexterity"&gt;&lt;/span&gt;
    Stamina&lt;span data-attribute-name="stamina"&gt;&lt;/span&gt;
    Presence&lt;span data-attribute-name="presence"&gt;&lt;/span&gt;
    Manipulation&lt;span data-attribute-name="manipulation"&gt;&lt;/span&gt;
    Composure&lt;span data-attribute-name="composure"&gt;&lt;/span&gt;
    Intelligence&lt;span data-attribute-name="intelligence"&gt;&lt;/span&gt;
    Wits&lt;span data-attribute-name="wits"&gt;&lt;/span&gt;
    Resolve&lt;span data-attribute-name="resolve"&gt;&lt;/span&gt;
&lt;/div&gt;
</code></pre>

<p>Another approach is to use a <code>&lt;template&gt;</code> and generate the player elements by cloning the template element.</p>

<h3>Defining a player object</h3>

<p>Then in the code you can define an object that is the default template for a players attributes, and a helper function</p>

<pre><code>const DEFAULT_PLAYER_OBJECT = {
    strength: 0, dexterity: 0, stamina: 0, presence: 0, manipulation: 0, 
    composure: 0, intelligence: 0, wits: 0, resolve: 0
};
const CreatePlayer = name =&gt; WatchedObj(DEFAULT_PLAYER_OBJECT, name);
function randomizePlayer(player) {
    const randOf5 = () =&gt; Math.random() * 5 | 0;
    for (const key of player) {
        player[key] = randOf5();
    }
    return player;
}
</code></pre>

<p>Then you need only create the players. All the hard work is done for you.</p>

<pre><code>const playerOne = randomizePlayer(CreatePlayer("playerOne")); 
const playerTwo = randomizePlayer(CreatePlayer("playerTwo")); 
</code></pre>

<p>Now if you change an attribute the HTML is automatically updated as well</p>

<pre><code>playerOne.strength = 5; // value set and HTML for player one strength is set to 5
playerTwo.wit = -5; // as it also vets the value out of range -5 is changed
                    // to 0 and displayed as 0. The -5 is total forgotten 
</code></pre>

<h2>Put it into play</h2>

<p>Making the advanced version a little more complex the example adds a color flash indicating if an attribute as increased or decreased. Yet the code to change an attribute is as basic as can be</p>

<pre><code>playerOne.strength += 1; // If not at max the value is changed and flashes cyan.
</code></pre>

<p></p><div class="snippet" data-lang="js" data-hide="true" data-console="true" data-babel="false">
<div class="snippet-code snippet-currently-hidden">
<pre class="snippet-code-js lang-js prettyprint-override"><code>setTimeout(() =&gt; { // simulate page load using timer

    // create two players
    const playerOne = randomizePlayer(CreatePlayer("playerOne")); 
    const playerTwo = randomizePlayer(CreatePlayer("playerTwo")); 


    // randomly change a player attribute every 200 to 1200 ms
    function randomPlayer(){
        const randPick = array =&gt; array[Math.random() * array.length | 0];
        var attName = randPick(Object.keys(DEFAULT_PLAYER_OBJECT));
        if (Math.random() &lt; 0.5) {
            playerOne[attName] += Math.random() &lt; 0.5 ? -1 : 1;
        } else {
            playerTwo[attName] += Math.random() &lt; 0.5 ? -1 : 1;
        }
        setTimeout(randomPlayer, Math.random() * 1000 + 200);

    }
    randomPlayer();

},0);

/* Library scroll down*/





















// Code below can be in another library js file and common to all pages.


const DEFAULT_PLAYER_OBJECT = {strength: 0, dexterity: 0, stamina: 0, presence: 0, manipulation: 0, composure: 0, intelligence: 0, wits: 0, resolve: 0};
function CreatePlayer(name) { return WatchedObj(DEFAULT_PLAYER_OBJECT, name) }
// to create random settings
function randomizePlayer(player) {
    const randOf5 = () =&gt; Math.random() * 5 | 0;
    for (const key of Object.keys(player)) {
        player[key] = randOf5();
    }
    return player;
}


const MAX_ATT_VALUE = 5;
const FLASH_TIME = 500; // time in ms of flash
const UP_FLASH_CLASS = "upFlash"; // name of class
const DOWN_FLASH_CLASS = "downFlash"; // name of class
function WatchedObj(obj, name) {

    if (!obj) {  // just incase you call the function incorrectly. This is only for development.
        throw new ReferenceError("WatchedObj requires a template object.");
    }
    const containingElement = name ? document.getElementById(name + "El") : document;
    function addAttribute(obj, name, value) {
        var flashTimer, lastFlash = "";
        const element = containingElement.querySelector("[data-attribute-name=" + name + "]");
        const contEl = element.parentElement;
        Object.defineProperty(obj, name, {
            enumerable: true,  
            configurable: false, 
            get() { return value },
            set(val) {
                val = isNaN(val) ? 0 : val;  // max it a number if not already so
                val = val &lt; 0 ? 0 : val &gt; MAX_ATT_VALUE ? MAX_ATT_VALUE : val; // make sure is in range
                if (value !== val) { // only if the new value is different

                    if (element) { // only if the element has been found
                        clearTimeout(flashTimer);
                        if (lastFlash !== ""){
                            contEl.classList.remove(lastFlash);
                        }
                        lastFlash = val &lt; value ? DOWN_FLASH_CLASS : UP_FLASH_CLASS;
                        element.textContent = val;                    
                        contEl.classList.add(lastFlash);
                        flashTimer = setTimeout(() =&gt; contEl.classList.remove(lastFlash), 500);
                    }
                    value = val;
                }
            }
        });
    }
    const watched = {};
    for (const [key, value] of Object.entries(obj)) { // for each key value pair create a property
        addAttribute(watched, key, obj);
    }
    return watched;
}</code></pre>
<pre class="snippet-code-css lang-css prettyprint-override"><code> .player {
    display: inline-grid;
    width : 150px;
    margin-right: 20px;
}
.playerAtt {
}

span {
   text-align: right;
}
.playerAtt span:last-child {
  float: right;
}
.upFlash {
   background : #09F;
   animation-duration: 0.25s;
   transition-timing-function: ease-in;
   animation-fill-mode: both;   
   animation-name: fadeOut;
}
.downFlash {
   background : red;
   animation-duration: 0.25s;
   transition-timing-function: ease-in;
   animation-fill-mode: both;   
   animation-name: fadeOut;
   
}
@keyframes fadeOut {
  0% {}
  100% { background: #FFF; }
}</code></pre>
<pre class="snippet-code-html lang-html prettyprint-override"><code>    &lt;div id="playerOneEl" class="player"&gt;
        &lt;div&gt;Player One&lt;/div&gt;
        &lt;div class="playerAtt"&gt;Strength&lt;span data-attribute-name="strength"&gt;&lt;/span&gt;&lt;/div&gt;
        &lt;div class="playerAtt"&gt;Dexterity&lt;span data-attribute-name="dexterity"&gt;&lt;/span&gt;&lt;/div&gt;
        &lt;div class="playerAtt"&gt;Stamina&lt;span data-attribute-name="stamina"&gt;&lt;/span&gt;&lt;/div&gt;
        &lt;div class="playerAtt"&gt;Presence&lt;span data-attribute-name="presence"&gt;&lt;/span&gt;&lt;/div&gt;
        &lt;div class="playerAtt"&gt;Manipulation&lt;span data-attribute-name="manipulation"&gt;&lt;/span&gt;&lt;/div&gt;
        &lt;div class="playerAtt"&gt;Composure&lt;span data-attribute-name="composure"&gt;&lt;/span&gt;&lt;/div&gt;
        &lt;div class="playerAtt"&gt;Intelligence&lt;span data-attribute-name="intelligence"&gt;&lt;/span&gt;&lt;/div&gt;
        &lt;div class="playerAtt"&gt;Wits&lt;span data-attribute-name="wits"&gt;&lt;/span&gt;&lt;/div&gt;
        &lt;div class="playerAtt"&gt;Resolve&lt;span data-attribute-name="resolve"&gt;&lt;/span&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;div id="playerTwoEl" class="player"&gt;
        &lt;div&gt;Player Two&lt;/div&gt;
        &lt;div class="playerAtt"&gt;Strength&lt;span data-attribute-name="strength"&gt;&lt;/span&gt;&lt;/div&gt;
        &lt;div class="playerAtt"&gt;Dexterity&lt;span data-attribute-name="dexterity"&gt;&lt;/span&gt;&lt;/div&gt;
        &lt;div class="playerAtt"&gt;Stamina&lt;span data-attribute-name="stamina"&gt;&lt;/span&gt;&lt;/div&gt;
        &lt;div class="playerAtt"&gt;Presence&lt;span data-attribute-name="presence"&gt;&lt;/span&gt;&lt;/div&gt;
        &lt;div class="playerAtt"&gt;Manipulation&lt;span data-attribute-name="manipulation"&gt;&lt;/span&gt;&lt;/div&gt;
        &lt;div class="playerAtt"&gt;Composure&lt;span data-attribute-name="composure"&gt;&lt;/span&gt;&lt;/div&gt;
        &lt;div class="playerAtt"&gt;Intelligence&lt;span data-attribute-name="intelligence"&gt;&lt;/span&gt;&lt;/div&gt;
        &lt;div class="playerAtt"&gt;Wits&lt;span data-attribute-name="wits"&gt;&lt;/span&gt;&lt;/div&gt;
        &lt;div class="playerAtt"&gt;Resolve&lt;span data-attribute-name="resolve"&gt;&lt;/span&gt;&lt;/div&gt;
    &lt;/div&gt;</code></pre>
</div>
</div>

    </div>