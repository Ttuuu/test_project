<div class="s-prose s-prose__disable-spoiler-hover js-post-body" itemprop="text">
<p>The use of a singleton will limit your possibilities, as hoffmale's review points out.  It completely prevents concurrent testing.  However, you'll find that getting the Clock instance to the code that needs it can easily add lots of "tramp data" to intermediated method signatures.  I try to limit that by passing a factory/registry interface that allows classes to access the system interactions they need - time, filesystem, network, etc.  In the tests, populate a mock-factory with the necessary mock objects, and in production, pass a concrete-factory that gives out objects with real system access.</p>

<p>One aspect that's missing is that this interface only gives access to <code>now()</code> - it doesn't handle the other clock-related actions that can cause slow tests.  In particular, you'll want sleeps and network- or mutux-related timeouts to respect the mock clock's idea of time.  To achieve that, you'll need to redirect those timeouts to mockable methods.  That's a bigger job, but will give you a much more useful test regime.</p>

<p>I think that when I made something like that (many years ago, and in a different language), I ended up with the <code>MockTime</code> storing an ordered list of future events; whenever control entered its code, it could advance the time to match the next event (which could be the end of a sleep, release of a mutex, or an interrupt from an external (mocked) thread, for example).</p>
    </div>