<div class="s-prose s-prose__disable-spoiler-hover js-post-body" itemprop="text">
<p>Something to look into: data access patterns. You go across all image lines, processing the first few pixels (were the kernel straddles the boundary), then again across all image lines, processing the bulk of the pixels, and then a third time across all image lines, processing the last few pixels. If you combine the outer loops into a single loop, walking over all image lines once, and processing all pixels on the line in order, you access data in the same order in which they are stored, thereby using the cache better. You might not notice the difference on the typical 256x256 test images, because they fit entirely in the cache of modern processors. Try it on a real image, today's cameras produce 10 or 15 million pixels!</p>

<p>Next, if you walk through the image as indicated above, your computation <code>(ii * numCols) + jj</code> increases by one for each pixel that you process, all through the image. Thus you don't need to compute that value, you can just increment a counter (or simply increment a pointer to the pixel). Even when you don't process all pixels in order, I find it usually saves time to pre-compute <code>ii * numCols</code> outside the loop over <code>jj</code>. Sometimes compilers are able to optimize this out, but not always.</p>

<p>And one more thing you could do is write a specialization for symmetric kernels. If <code>k[-x]==k[x]</code> (assuming <code>k[0]</code> is the middle value in the kernel), then you can compute <code>(I[-x]+I[x]) * k[x]</code> instead of <code>I[-x]*k[-x] + I[x]*k[x]</code>, saving you half the multiplications. (I don't know if this is harder to do with SSE instructions, I don't have any experience with those.)</p>
    </div>