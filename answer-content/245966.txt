<div class="s-prose s-prose__disable-spoiler-hover js-post-body" itemprop="text">
<h1>Removing unncessary branches</h1>
<p>Looking at the assembly generated by your code, you indeed managed to get rid of all branches save for the one needed by the loop itself. Nice! But maybe you removed too many? The main issue is the speed of the loop itself. Branches outside the loop do not impact performance much, and they can actually help performance! Consider for example that in the "non-compact" Bresenham implementation, they basically have two specialized loops, and choose which one to use depending on the slope. You could do that as well and perhaps reduce the amount of pre-calculation necessary in each case.</p>
<p>Another issue is the use of multiplications in lines such as these:</p>
<pre><code>int lookx[2] = {xm, xm + (qr * cy * dxA)},
    looky[2] = {ym, ym + (qr * cx * dyA)},
    lookd[2] = {qr * pd, qr * (pd - xym)};
</code></pre>
<p>Here, <code>qr</code>, <code>cx</code> and <code>cy</code> are both booleans. By using a multiplication here, it seems that at least on some CPU architectures, GCC actually generates multiplication instructions, when it could have used fast instructions such as <code>and</code> and conditional moves. Rewriting the above to the following lines seems to get rid of the multiplication instructions:</p>
<pre><code>int lookx[2] = {xm, xm + ((qr &amp; cy) * dxA)},
    looky[2] = {ym, ym + ((qr &amp; cx) dyA)},
    lookd[2] = {qr ? pd : 0, qr ? (pd - xym) : 0};
</code></pre>
<p>Clang seems to see that it can use conditional moves here without having to rewrite it, at least on x86_64. Of course, this is not so important unless you expect to draw many short lines, where the setup cost dominates.</p>
<p>Again, if you allow branches in the setup, you can have specialized init functions for the 8 distinct slope ranges which will be much simpler.</p>
<h1>Branch predictors are awesome</h1>
<p>Branches are bad on GPUs, but on CPUs a lot of effort has been spent optimizing the branch predictors. Conditions that are static during a loop are probably predicted with 100% accuracy and cost basically nothing. But even conditions that change often, like <code>if (px &lt; 0)</code>, might be predicted with a high degree of accuracy if they follow a pattern. And they do in the case of drawing lines using Bresenham's algorithm. It probably works better for some slopes than others though.</p>
<p>The above can very well explain why the "non-compact" version performs just as well. But it will probably also depend a lot on what CPU it is running on, what optimization level is used, and what kind of lines you are drawing (long/short, right angles/arbitrary angles).</p>
<h1>Other possible optimizations</h1>
<p>Assuming you keep the loop the same, you can thing about vectorizing it a little bit. You could group <code>x1</code>, <code>y1</code> and <code>ec</code> together in a single 128-bit register, and also make a single <code>__m128 lookup[2]</code>, so you can just do a single <code>_mm_add_epi32()</code> to add the three components of the lookup table to <code>x1</code>, <code>y1</code> and <code>ec</code> in one go.</p>
    </div>