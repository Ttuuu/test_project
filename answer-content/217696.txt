<div class="s-prose s-prose__disable-spoiler-hover js-post-body" itemprop="text">
<p>I see no problem with a programming challenge that has a low accuracy stopwatch.  I have problems with your particular implementation.  Since one aim of exercise is to be fully aware of state, I am surprised in how it maintains state indirectly and privately based on the value in _start.  A simple stopwatch has a very simple state: its either running or not.  So I would just directly offer a Boolean IsRunning property with public getter and private setter.  This removes any mystery as to what the state is, and it exposes that state clearly and publicly to the consumer of the stopwatch.</p>

<p>I personally would prefer _start to be renamed _startTime, but that's no big deal.  I would have the Start() method do 2 things: (1) sets IsRunning to true, and (2) sets _startTime to DateTime.UtcNow.  Note that UtcNow is not only faster than Now (Now actually calls UtcNow first), but also allows the stopwatch to not have any odd side effects from Daylight Saving Time transitions (really the biggest reason to use UtcNow).</p>

<p>My other big gripe is the Stop() method should just stop the stopwatch.  Your implementation has it stopping and also returning the duration.  I would change Stop() to be void, and then offer a TimeSpan Duration property.  Stop() should set IsRunning to false, and somehow store the duration for later retrieval.</p>

<p>This now gives you flexibility that you did not possess before.  What behavior do you want the stopwatch to exhibit if someone asks for the Duration while its running?  Do you want to throw an exception because Stop() has not been issued first?  Or would you like to return a Duration while running?</p>
    </div>