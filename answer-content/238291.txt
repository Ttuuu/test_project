<div class="s-prose s-prose__disable-spoiler-hover js-post-body" itemprop="text">
<p>Your singleton initialization pattern is unsafe for a logger that you may want to use from other static initializers (that have undefined initialization order) because you cannot guarantee that the initialize function has been executed.</p>

<p>Typically you would use C++11 magic statics for this, but then you can't give a filename to it. Providing a filename as user input is always going to be a problem if you need to log from static initializes that run before <code>main()</code>. Yes, you could read the log filename from a static configuration file, but you might want to log errors from the config parse itself, and at that point the log path could be static as well. In this particular case, I recommend picking a static or generated file path for your logs.</p>

<p>Next up, you will basically keep a whole CPU core busy with polling every 10ns. Use <code>std::condition_variable</code>  to sleep the thread until it had logs to write.</p>

<p>Finally your logging thread never exits; this is a problem depending on the platform: the behaviour of the process when you return from <code>main()</code> with active threads can differ.  For example, read <em><a href="https://devblogs.microsoft.com/oldnewthing/20100827-00/?p=13023" rel="nofollow noreferrer">If you return from the main thread, does the process exit?</a></em> by Raymond Chen. Your logger class should have a destructor that stops the thread's loop, joins the thread and deletes the singleton instance (not necessary if you use magic statics).</p>
    </div>