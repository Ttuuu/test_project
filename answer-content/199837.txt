<div class="s-prose s-prose__disable-spoiler-hover js-post-body" itemprop="text">
<p>So you have a lot of list manipulation, I believe you can reduce that to work with strings and use <a href="https://docs.python.org/2/library/re.html#re.sub" rel="nofollow noreferrer"><code>re.sub</code></a> to fill in the gaps.</p>

<p>Let's start by analyzing the answer:</p>

<p>I see that the result is basically symmetrical vertically and horizontally. Since lines are printed left-to-right, top-to-bottom, we can easily split it into top and bottom halves which are mirrored. This allows us to break apart our approach in only doing half the work, and copying a reflection onto itself.</p>

<p>Once <code>res</code> is populated with the top half of the answer, we want to extend it with the reversed copy of it. A common shorthand for a reversed list by using <a href="https://docs.python.org/2.3/whatsnew/section-slices.html" rel="nofollow noreferrer">extended slices</a>.</p>

<pre><code>res.extend(res[::-1])
</code></pre>

<p>But doing this would copy the middle line twice! Since <code>[::-1]</code> is the same as <code>[n:-1:-1]</code>, removing the last row would result in <code>[n-1:-1:-1]</code>, or simply <code>[n-1::-1]</code>.</p>

<pre><code>res.extend(res[n-1::-1])
</code></pre>

<p>Now the top half of the solution can be broken down as repeated numbers, gradually substituting in decreased values for each row. The key word here is <em>substitution</em>. Creating a list and appending both sides is a way to handle this, but requires multiple modifications to it as you presented:</p>

<pre><code>for x in range(1, n + 1):
    str_x = str(x)
    l = len(res)
    res.insert(0, [str_x] * l)
    res.append([str_x] * l)
</code></pre>

<p>Your approach appends the number to the beginning and end of the string. If you were working with strings, you could essentially create it all in one declaration. We can determine that the number of times <code>n</code> appears in the first line is <code>2n</code> (since it's left-right mirrored) <code>+ 1</code> to account for the <code>0</code> that would be in the center. The starting line is very simple:</p>

<p>res = [str(n) * (n * 2 + 1)]</p>

<p>As mentioned earlier, the subsequent lines build on the previous line by replacing all but the first and last <code>n</code>-values with <code>n-1</code>. I really enjoy utilizing <a href="https://docs.python.org/2/library/re.html#re.sub" rel="nofollow noreferrer"><code>re.sub</code></a>, but you can use string concatenation as well.</p>

<p>Using <code>re</code>, we could build a pattern as <code>/n+/</code> where <code>n</code> is the number to be replaced. Once we find it, we need to replace it with <code>n-1</code> using the same formula described above. But since we need to leave an <code>n</code> on each side, we'll have to subtract 2 from this formula to become <code>2 * n + 1 - 2</code> or simply <code>2 * n - 1</code>.</p>

<pre><code>n_minus_1_str = str(x-1) * (x * 2 - 1)
</code></pre>

<p>With this, we can replace all the middle <code>n</code> values with <code>n_minus_1_str</code> and attach <code>n</code> on both sides to preserve it.</p>

<pre><code>str_x + n_minus_1_str + str_x
</code></pre>

<p>Putting this new line together for <code>re.sub</code>, we get:</p>

<pre><code>new_line = re.sub(str_x + "+", str_x + (str(x-1) * (x * 2 - 1)) + str_x, res[-1])
</code></pre>

<p>You could also implement the above without <code>re.sub</code>, and use regular string concatenation instead to build the string. The slicing gets a bit tricky, but can be accomplished with:</p>

<pre><code>new_line = res[-1][:n-x+1] + str(x-1) * (x * 2 - 1) + res[-1][x-n-1:]
</code></pre>

<p>Finally, we just need a <code>for</code> loop to run backwards from <code>n</code> down to <code>1</code> (not including <code>0</code>, since we are adding <code>n-1</code> in the loop.</p>

<pre><code>for x in xrange(n, 0, -1):
</code></pre>

<p>Using <code>xrange</code>, since the list generated by <code>range</code> is unnecessary.</p>

<p>Putting this all together with <code>'\n'.join(res)</code> we get the following:</p>

<pre><code>from re import sub
def palindrome(n):
    res = [str(n) * (n * 2 + 1)] # First line
    for x in xrange(n, 0, -1): # Append remaining until 0 is in the center
        str_x = str(x)
        res.append(sub(str_x + "+", str_x + (str(x-1) * (x * 2 - 1)) + str_x, res[-1]))
    res.extend(res[n-1::-1]) # Add the flipped version without the last row
    return '\n'.join(res)
print palindrome(8)
</code></pre>

<p>I chose to replace the entire string of <code>x</code> instead of matching only the middle values to save on regex computation.</p>

<p><strong>Edit:</strong> Forgive me, first time posting in Code Review.</p>
    </div>