<div class="s-prose s-prose__disable-spoiler-hover js-post-body" itemprop="text">
<blockquote>
<pre><code>using namespace std;
</code></pre>
</blockquote>

<p>Never do that; certainly not in a header - that inflicts the harm onto <em>every source file that includes the header</em>.</p>

<hr>

<p>Prefer to include your own headers before Standard Library headers.  This can help expose unsatisfied dependencies of your library's headers.</p>

<p>Prefer <code>&lt;cmath&gt;</code> to <code>&lt;math.h&gt;</code> (etc.), as this puts the standard library identifiers into the <code>std</code> namespace, rather than the global namespace.  Why does <code>Utility.h</code> need this header anyway?</p>

<p>WTF is <code>&lt;conio.h&gt;</code>?  It's not a standard library header.  Thankfully, it seems it can be removed.</p>

<p>No need to include <code>&lt;ostream&gt;</code> just for its types - include <code>&lt;iosfwd&gt;</code> instead for faster compilation.  You'll need <code>&lt;ostream&gt;</code> in the implementation files, of course.</p>

<hr>

<p>Be careful with indentation:</p>

<blockquote>
<pre><code>for(int i = 0; i &lt; m; ++i)
    for(int j = 0; j &lt; n; ++j)
    {
        ...
    }
    ...

    cout &lt;&lt; "The Matrix A:" &lt;&lt; endl;
cout &lt;&lt; a &lt;&lt; endl;
</code></pre>
</blockquote>

<p>The first output line is indented as if it's part of the outer loop, but it's not.</p>

<hr>

<p>Use initializers to initialize members.  This allows compilers (e.g. <code>g++ -Weffc++</code>) to spot when you fail to initialise.  Here, we're not even consistent:</p>

<blockquote>
<pre><code>Fraction () : num(0), den(1) {}
Fraction (cpp_int n)
{
    num = n;
    den = 1;
}
Fraction(cpp_int _num, cpp_int _den) : num(_num), den(_den) {}
</code></pre>
</blockquote>

<p>The first and last use initializers; why not the middle one?  These three can actually be combined into a single constructor, by using default arguments:</p>

<pre><code>Fraction(cpp_int num = 0, cpp_int den = 1)
    : num{std::move(num)},
      den{std::move(den)}
{
    simplify();
}
</code></pre>

<p>The <code>std::move()</code> may reduce copying there.</p>

<hr>

<p>With the compiler errors and warnings sorted out, we can move on to the logic of the program.</p>

<h2><code>Fraction</code></h2>

<p>This seems fairly straightforward, but could usefully lose the extraneous parentheses and <code>this-&gt;</code> clutter that's all over the place (we're not writing Python!).</p>

<p>We could do with some tests of <code>Fraction</code> (and I really recommend using a pre-made test framework for this).</p>

<p>The output streaming operator can test for integers with a simple <code>den == 1</code>, since we always keep fractions in their reduced form.  That's much cheaper than using <code>%</code>.</p>

<p>The comparison member functions should be declared <code>const</code>.</p>

<p>I think <code>operator==(int)</code> is broken, because it performs integer division and ignores the remainder.  A more robust version would be (untested):</p>

<pre><code>bool operator==(int n) const
{
    return n * den == num;
}
</code></pre>

<p>It's conventional to write <code>operator!=()</code> in terms of <code>==</code> (i.e. <code>return !(*this == other);</code>); that makes it easier to see the correspondence, and reduce the chance of error.</p>

<p>Many of the operators have overloads that are not required, given that <code>cpp_int</code> has implicit promotion to <code>Fraction</code>.</p>

<p>Some operators are missing: unary <code>+</code> and <code>-</code>, pre- and post- <code>++</code> and <code>--</code>, <code>!</code>, <code>explicit operator bool</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>.  Possibly also <code>%</code>?</p>

<p>When we reimplement <code>std::gcd()</code> to accept <code>cpp_int</code>, let's not give it a gratuitously different name; it should be <code>static</code>, since it doesn't need to access <code>this</code>. The <code>lcf()</code> member (which parallels <code>std::lcd()</code>) is unused.</p>

<p>The arithmetic operators have a lot of duplication.  Implement the non-assigning functions in terms of the assigning ones.  For example:</p>

<pre><code>class Fraction
{
    Fraction&amp; operator+=(const Fraction&amp; fr);
    Fraction operator+(const Fraction&amp; fr) const;
};

Fraction&amp; Fraction::operator+=(const Fraction&amp; fr)
{
    num = num * fr.den + fr.num * den;
    den *= fr.den;
    simplify();
    return *this;
}

Fraction Fraction::operator+(Fraction fr) const
{
    return fr += *this;
}
</code></pre>

<p>Notice the return types (assignment operators always return a reference to the object) and passing by value to <code>operator+()</code>.</p>

<p>With the above changes applied, I get the following refactored (simplified) class:</p>

<pre><code>#include &lt;iosfwd&gt;
#include &lt;utility&gt;

#include &lt;boost/multiprecision/cpp_int.hpp&gt;

class Fraction
{
    using cpp_int = boost::multiprecision::cpp_int;

    static cpp_int gcd(const cpp_int&amp; a, const cpp_int&amp; b);
    void simplify();

public:
    cpp_int num;
    cpp_int den;

    Fraction(cpp_int num = 0, cpp_int den = 1)
        : num{std::move(num)},
          den{std::move(den)}
    {
        simplify();
    }

    Fraction(int num = 0, int den = 1)
        : num{num},
          den{den}
    {
        simplify();
    }

    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Fraction&amp; fr);

    bool operator==(const Fraction&amp; fr) const { return num == fr.num &amp;&amp; den == fr.den; }
    bool operator!=(const Fraction&amp; fr) const { return !(*this == fr); }

    bool operator&lt;(const Fraction&amp; fr) const { return num * fr.den &lt; den * fr.num; }
    bool operator&lt;=(const Fraction&amp; fr) const { return *this == fr || *this &lt; fr; }
    bool operator&gt;(const Fraction&amp; fr) const { return !(*this&lt;=fr); }
    bool operator&gt;=(const Fraction&amp; fr) const { return !(*this&lt;fr); }

    explicit operator bool() const { return num != 0; }

    Fraction operator+() const;
    Fraction operator-() const;

    Fraction&amp; operator++();
    Fraction&amp; operator--();

    Fraction operator++(int);
    Fraction operator--(int);

    Fraction&amp; operator+=(const Fraction&amp; fr);
    Fraction&amp; operator-=(const Fraction&amp; fr);
    Fraction&amp; operator*=(const Fraction&amp; fr);
    Fraction&amp; operator/=(const Fraction&amp; fr);
};

Fraction operator+(Fraction a, const Fraction&amp; b) { return a += b; }
Fraction operator-(Fraction a, const Fraction&amp; b) { return a -= b; }
Fraction operator*(Fraction a, const Fraction&amp; b) { return a *= b; }
Fraction operator/(Fraction a, const Fraction&amp; b) { return a /= b; }
</code></pre>



<pre><code>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Fraction&amp; fr)
{
    os &lt;&lt; fr.num;
    if (fr.den != 1) {
        os &lt;&lt; "/" &lt;&lt; fr.den;
    }
    return os;
}

Fraction::cpp_int Fraction::gcd(const Fraction::cpp_int&amp; a, const Fraction::cpp_int&amp; b)
{
    return b ? gcd(b, a%b) : a;
}

void Fraction::simplify()
{
    // Denominators are always positive
    if (den &lt; 0) {
        num = -num;
        den = -den;
    }

    // Factor out gcd from numerator and denominator.
    auto const n = gcd(abs(num), den);
    num /= n;
    den /= n;
}


Fraction Fraction::operator+() const
{
    return *this;
}

Fraction Fraction::operator-() const
{
    return { -num, den };
}

Fraction&amp; Fraction::operator++()
{
    num += den;
    return *this;
}

Fraction&amp; Fraction::operator--()
{
    num -= den;
    return *this;
}

Fraction Fraction::operator++(int)
{
    auto old = *this;
    ++*this;
    return old;
}

Fraction Fraction::operator--(int)
{
    auto old = *this;
    --*this;
    return old;
}

Fraction&amp; Fraction::operator+=(const Fraction&amp; fr)
{
    num = num * fr.den + fr.num * den;
    den *= fr.den;
    simplify();
    return *this;
}

Fraction&amp; Fraction::operator-=(const Fraction&amp; fr)
{
    return *this += -fr;
}

Fraction&amp; Fraction::operator*=(const Fraction&amp; fr)
{
    num *= fr.num;
    den *= fr.den;
    simplify();
    return *this;
}

Fraction&amp; Fraction::operator/=(const Fraction&amp; fr)
{
    return *this *= { fr.den, fr.num };
}
</code></pre>

<h1><code>Matrix</code></h1>

<p>The first thing I see here is that we use (signed) <code>int</code> for the dimensions.  I think it would be less surprising if we had <code>std::size_t</code> instead, like all the standard containers.</p>

<p>The structure (vector of vectors) has unnecessary overhead, and poor locality of reference.  A simple improvement would be to use a single vector and index into it as a raster (i.e. <code>index = col + row * width</code>).  More advanced versions are possible with the same public interface (e.g. for tile-based or sparse storage).  When making this change, it makes sense for the "utilities" functions to be brought in as private members, rather than passing the storage and its shape to them.</p>

<p>Keep using <code>std::vector</code> for the storage - that's great, because it enables the Rule of Zero; we don't need to implement our own copy/move constructors and assignment.</p>

<p>Some of the review of <code>Fraction</code> operators applies here: assignment operators should return a reference to <code>*this</code>, and comparison operators should be <code>const</code>.  There are a lot of additional functions here that also should be <code>const</code> and/or accept const-ref arguments.</p>

<p>It's not clear why <code>*</code> and <code>*=</code> take a <code>cpp_int</code> - why not a <code>Fraction</code>?</p>

<p>The naming of <code>IDENTITY</code> and <code>CONSTANT</code> is unconventional - most programmers use all-caps for macros, which need special care as they behave differently from functions (e.g. scope rules and muliply-expanded arguments).  Please don't distract from the real macros like that.</p>

<p>I don't see the value of <code>CONSTANT</code> - it seems to merely duplicate the three-argument constructor.  Similarly, <code>resize()</code> is redundant - we can just assign a new matrix of the required size.</p>

<p>Also on naming, <code>transpose()</code> sounds like a mutator, but it actually creates a transposed <em>copy</em> of the matrix.  I'd call that <code>transposed()</code> instead (and mark it <code>const</code>).</p>

<p>The comparison operator is over-complicated.  We can simply compare the members, since <code>std::vector</code> provides a memberwise equality operator:</p>

<pre><code>bool Matrix::operator==(const Matrix&amp; mx) const
{
    return height == mx.height
        &amp;&amp; width == mx.width
        &amp;&amp; data == mx.data;
}
</code></pre>

<p>Or even, with a rasterised <code>data</code> (since vector compare tests the lengths):</p>

<pre><code>bool Matrix::operator==(const Matrix&amp; mx) const
{
    return width == mx.width
        &amp;&amp; data == mx.data;
}
</code></pre>

<p>Element access using <code>operator()</code> needs to have <code>const</code> and non-<code>const</code> overloads.  I find it helps the implementation to have a private <code>at(x,y)</code> method (it's easier to type when applied to <code>this</code>).</p>

<p>Here's what I'd expect from the interface:</p>

<pre><code>#ifndef MATRIX_H_INCLUDED
#define MATRIX_H_INCLUDED

#include "Fraction.h"

#include &lt;vector&gt;
#include &lt;iosfwd&gt;
#include &lt;assert.h&gt;

class Matrix
{
    std::size_t height = 0;
    std::size_t width = 0;

    std::vector&lt;Fraction&gt; data = {};

    Fraction&amp; at(std::size_t r, std::size_t c)
    { return data[r * width + c]; }

    const Fraction&amp; at(std::size_t r, std::size_t c) const
    { return data[r * width + c]; }


public:
    Matrix()
        : Matrix{0, 0}
    {}

    Matrix(std::size_t height, std::size_t width, Fraction n = 0)
        : height{height},
          width{width},
          data(width * height, n)
    {}

    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Matrix&amp; mx);

    bool operator==(const Matrix&amp; mx) const;
    bool operator!=(const Matrix&amp; mx) const;

    Matrix&amp; operator+=(const Matrix&amp; mx);
    Matrix&amp; operator-=(const Matrix&amp; mx);
    Matrix&amp; operator*=(const Matrix&amp; mx);
    Matrix operator*(const Matrix&amp;) const;

    // scalar multiplication
    Matrix&amp; operator*=(const Fraction&amp; n);

    Fraction&amp; operator()(std::size_t r, std::size_t c)
    { return at(r, c); }

    const Fraction&amp; operator()(std::size_t r, std::size_t c) const
    { return at(r, c); }

    std::size_t size() const
    { return height * width; }

    std::size_t rows() const
    { return height; }

    std::size_t cols() const
    { return width; }

    static Matrix identity(std::size_t n);

    bool is_square() const
    { return height == width; }

    bool is_identity() const;
    bool is_symmetric() const;
    bool is_skewSymmetric() const;
    bool is_diagonal() const;
    bool is_null() const;
    bool is_constant() const;
    bool is_orthogonal() const;
    bool is_invertible() const;
    bool is_upperTriangular() const;
    bool is_lowerTriangular() const;

    Matrix transpose() const;
    Fraction determinant() const;
    Matrix inverse() const;
    Matrix gaussJordanElimination() const;

private:
    void swapRows(std::size_t row1, std::size_t row2);
    bool pivotEqualTo_one_Found(std::size_t pivot_row, std::size_t pivot_col, std::size_t&amp; alternative_pivot_row) const;
    bool pivotNot_zero_Found(std::size_t pivot_row, std::size_t pivot_col, std::size_t&amp; col_dif_zero) const;
    bool firstNumberNot_zero(std::size_t row_num, std::size_t&amp; num_coluna_num_dif_zero) const;
    void changePivotTo_one(std::size_t row_num, Fraction constant);
    void zeroOutTheColumn(std::size_t row_num, std::size_t num_pivot_row, Fraction constant);
};


Matrix operator+(Matrix a, const Matrix&amp; b)
{ return a += b; }

Matrix operator-(Matrix a, const Matrix&amp; b)
{ return a -= b; }

Matrix operator*(Matrix mx, const Fraction&amp; n)
{ return mx *= n; }

Matrix operator*(const Fraction&amp; n, Matrix mx)
{ return mx *= n; }

#endif // MATRIX_H_INCLUDED
</code></pre>

<p>Moving on to the implementation of <code>Matrix</code>, I'll start with <code>&lt;&lt;</code>.  I think it's easier to use <code>std::setw</code> rather than composing a <code>boost::format</code> string.  It's also inefficient to create a vector of widths to find the maximum - in this case, I'd leave the standard algorithm and just update as we go (this may change when C++20 Ranges are more widely available).  Don't use <code>std::endl</code> unless you really need to flush - <code>\n</code> is much more lightweight.</p>

<p>Those changes give me this:</p>

<pre><code>std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Matrix&amp; mx)
{
    // find maximum element width
    std::size_t max_width = 1;
    for (auto const&amp; element: mx.data) {
        auto w = element.to_string().size();
        if (w &gt; max_width) {
            max_width = w;
        }
    }

    // use the max width to format elements
    max_width += 4;             // padding between elements

    for (std::size_t i = 0;  i &lt; mx.height;  i++) {
        for (std::size_t j = 0;  j &lt; mx.width;  j++) {
            os &lt;&lt; std::setw(max_width) &lt;&lt;  mx.at(i, j);
        }
        os &lt;&lt; std::endl;
    }

    return os;
}
</code></pre>

<p>That required a simple <code>to_string()</code> member in <code>Fraction</code>:</p>

<pre><code>std::string Fraction::to_string() const
{
    std::ostringstream os;
    os &lt;&lt; *this;
    return os.str();
}
</code></pre>

<p>We don't need to hand-code loops in the addition and subtraction operators - <code>std::transform()</code> does that for us (and simplifies the path to parallelising):</p>

<pre><code>Matrix&amp; Matrix::operator-=(const Matrix&amp; mx)
{
    assert(height == mx.height);
    assert(width == mx.width);
    std::transform(data.begin(), data.end(),
                   mx.data.begin(), data.begin(),
                   std::minus{});
    return *this;
}

Matrix&amp; Matrix::operator+=(const Matrix&amp; mx)
{
    assert(height == mx.height);
    assert(width == mx.width);
    std::transform(data.begin(), data.end(),
                   mx.data.begin(), data.begin(),
                   std::plus{});
    return *this;
}
</code></pre>

<p>We can simplify <code>is_identity()</code> to use the code we already wrote:</p>

<pre><code>bool Matrix::is_identity() const
{
    if (! is_square())
        return false;

    return *this == identity(width);
}
</code></pre>

<p>And, similarly, <code>is_symmetric()</code>:</p>

<pre><code>bool Matrix::is_symmetric() const
{
    return *this == transposed();
}
</code></pre>

<p>Admittedly, these two now do more work when returning false, so you might not want to use these implementations.</p>

<p>We can reduce the work done in <code>is_skewSymmetric()</code> by about half, by starting <code>j</code> beyond the diagonal:</p>

<pre><code>bool Matrix::is_skewSymmetric() const
{
    if (!is_square()) {
        return false;
    }

    for (std::size_t i = 0; i &lt; height; ++i) {
        for (std::size_t j = i+1; j &lt; width; ++j) {
            if (at(i, j) != -at(j, i)) {
                return false;
            }
        }
    }

    return true;
}
</code></pre>

<p>I don't like the name of <code>is_null()</code> - to me that implies an uninitalised (zero-size) <code>Matrix</code>.  I'd call it <code>is_zero()</code> and use <code>&lt;algorithm&gt;</code> to simplify; similarly for <code>is_constant()</code>:</p>

<pre><code>bool Matrix::is_zero() const
{
    return std::all_of(data.begin(), data.end(),
                       [](auto const&amp; x){ return x == 0; });
}

bool Matrix::is_constant() const
{
    return std::adjacent_find(data.begin(), data.end(), std::not_equal_to{})
        == data.end();
}
</code></pre>

<p>The <code>is_*Triangular()</code> predicates can be sped up in a similar manner to <code>is_skewSymmetric()</code>, by avoiding <code>j &lt;= i</code> or <code>j &gt;= i</code> as appropriate:</p>

<pre><code>bool Matrix::is_orthogonal() const
{
    if (!is_square())
        return false;

    return(*this * transposed() == identity(width));
}

bool Matrix::is_invertible() const
{
    return determinant() != 0;
}

bool Matrix::is_lowerTriangular() const
{
    if (!is_square())
        return false;

    for (std::size_t i = 0;  i &lt; height;  ++i)
        for (std::size_t j = i + 1;  j &lt; width;  ++j)
            if (at(i, j))
                return false;

    return true;
}

bool Matrix::is_upperTriangular() const
{
    if (!is_square())
        return false;

    for (std::size_t i = 0;  i &lt; height;  ++i)
        for (std::size_t j = 0;  j &lt; i;  ++j)
            if (at(i, j) != 0)
                return false;

    return true;
}
</code></pre>

<p>In <code>determinant()</code>, many of the locals can be moved to smaller scope.  We're also calling <code>pivotEqualTo_one_Found()</code> and <code>pivotNot_zero_Found()</code> every time through the loop regardless of whether we use the results.  We can short-circuit test to only call those functions when needed, and also combine their results to a single block:</p>

<pre><code>    std::size_t other_row;
    if (mx.at(pivot_row, pivot_col) != 1 &amp;&amp; mx.pivotEqualTo_one_Found(pivot_row, pivot_col, other_row)
        || mx.at(pivot_row, pivot_col) == 0 &amp;&amp; mx.pivotNot_zero_Found(pivot_row, pivot_col, other_row))
    {
        mx.swapRows(pivot_row, other_row);
        sign *= -1;
    }
</code></pre>

<p>Immediatlely after this, we call <code>firstNumberNot_zero()</code> but ignore the result.  This is a serious bug, as <code>col_dif_zero</code> will be <em>uninitialised</em> if it returned false, meaning Undefined Behaviour.  I think that if we have a row with all zeros, then the result will be zero, so we can return immediately in that case.</p>

<p>Modified:</p>

<pre><code>Fraction Matrix::determinant() const
{
    assert(is_square());

    if (height == 1) {
        return at(0,0);
    }
    if (is_zero() || is_constant()) {
        return 0;
    }
    if (is_identity()) {
        return 1;
    }

    Matrix mx = *this;
    std::vector&lt;Fraction&gt; row_mults;
    int sign = 1;

    std::size_t pivot_row = 0;
    std::size_t pivot_col = 0;
    while (pivot_row &lt; (height - 1)) {
        std::size_t other_row;
        if (mx.at(pivot_row, pivot_col) != 1 &amp;&amp; mx.pivotEqualTo_one_Found(pivot_row, pivot_col, other_row)
            || mx.at(pivot_row, pivot_col) == 0 &amp;&amp; mx.pivotNot_zero_Found(pivot_row, pivot_col, other_row))
        {
            mx.swapRows(pivot_row, other_row);
            sign *= -1;
        }

        std::size_t col_dif_zero;

        if (!mx.firstNumberNot_zero(pivot_row, col_dif_zero)) {
            return 0;
        }

        if (mx.at(pivot_row, col_dif_zero) != 1) {
            row_mults.push_back(mx.at(pivot_row, col_dif_zero));
            mx.changePivotTo_one(pivot_row, mx.at(pivot_row, col_dif_zero));
        }

        for (std::size_t n = pivot_row + 1;  n &lt; height;  ++n) {
            auto const constant = mx.at(n, col_dif_zero);
            if (mx.at(n, col_dif_zero)) {
                mx.zeroOutTheColumn(n, pivot_row, constant);
            }
        }

        ++pivot_row;
        ++pivot_col;
    }

    Fraction det = sign;
    for (std::size_t i = 0;  i &lt; height;  ++i) {
        det *= mx.at(i, i);
    }

    // now multiply by all the row_mults
    return std::accumulate(row_mults.begin(), row_mults.end(),
                           det, std::multiplies());
}
</code></pre>

<p>Looking next at <code>inverse()</code>, it writes output to <code>std::cout</code>.  We should use <code>std::cerr</code> for error messages; in a library, we should strive to avoid writing to standard streams, and instead signal the caller by different means - I'd suggest raising an exception instead.</p>

<p>We can make a similar simplification as we did to <code>determinant()</code> where we swap rows in the Gauss elimination step.  Following that, we have:</p>

<pre><code>    if (number_not_zero_found) {
        ...
    }

    if (number_not_zero_found) {
        ...
    }
</code></pre>

<p>The value isn't changed in the block of the first <code>if</code>, so just combine these.   There's a similar structure in the Jordan elimination step, too.  That gives us:</p>

<pre><code>Matrix Matrix::inverse() const
{
    assert(is_square());

    if (!is_invertible()) {
        throw std::range_error("Matrix not invertible");
    }

    Matrix mx = *this;
    Matrix inverse = identity(height);

    //Gauss Elimination
    std::size_t pivot_row = 0;
    std::size_t pivot_col = 0;
    while (pivot_row &lt; (height - 1)) {
        std::size_t other_row;
        if (mx.at(pivot_row, pivot_col) != 1 &amp;&amp; mx.pivotEqualTo_one_Found(pivot_row, pivot_col, other_row)
            || mx.at(pivot_row, pivot_col) == 0 &amp;&amp; mx.pivotNot_zero_Found(pivot_row, pivot_col, other_row))
        {
            mx.swapRows(pivot_row, other_row);
            inverse.swapRows(pivot_row, other_row);
        }

        std::size_t col_dif_zero;
        if (mx.firstNumberNot_zero(pivot_row, col_dif_zero)) {
            if (mx.at(pivot_row, col_dif_zero) != 1) {
                inverse.changePivotTo_one(pivot_row, mx.at(pivot_row, col_dif_zero));
                mx.changePivotTo_one(pivot_row, mx.at(pivot_row, col_dif_zero));
            }
            for (std::size_t n = pivot_row + 1;  n &lt; height; ++n) {
                inverse.zeroOutTheColumn(n, pivot_row, mx.at(n, col_dif_zero));
                mx.zeroOutTheColumn(n, pivot_row, mx.at(n, col_dif_zero));
            }
        }

        ++pivot_row;
        ++pivot_col;
    }

    //Jordan Elimination
    while (pivot_row &gt; 0) {
        std::size_t col_dif_zero;
        if (mx.firstNumberNot_zero(pivot_row, col_dif_zero)) {
            if (mx.at(pivot_row, col_dif_zero) != 1) {
                inverse.changePivotTo_one(pivot_row, mx.at(pivot_row, col_dif_zero));
                mx.changePivotTo_one(pivot_row, mx.at(pivot_row, col_dif_zero));
            }
            for (size_t n = pivot_row;  n &gt; 0;  --n) {
                inverse.zeroOutTheColumn(n - 1, pivot_row, mx.at(n - 1, col_dif_zero));
                mx.zeroOutTheColumn(n - 1, pivot_row, mx.at(n - 1, col_dif_zero));

            }
        }
        --pivot_row;
    }

    return inverse;
}
</code></pre>

<p>We can apply the same simplifications to <code>gaussJordanElimination</code>:</p>

<pre><code>Matrix Matrix::gaussJordanElimination() const
{
    Matrix mx = *this;

    std::size_t pivot_row = 0;
    std::size_t pivot_col = 0;

    ///Gauss Elimination
    while (pivot_row &lt; (height - 1)) {
        std::size_t other_row;
        if (mx.at(pivot_row, pivot_col) != 1 &amp;&amp; mx.pivotEqualTo_one_Found(pivot_row, pivot_col, other_row)
            || mx.at(pivot_row, pivot_col) == 0 &amp;&amp; mx.pivotNot_zero_Found(pivot_row, pivot_col, other_row))
        {
            mx.swapRows(pivot_row, other_row);
        }

        std::size_t col_dif_zero;
        if (mx.firstNumberNot_zero(pivot_row, col_dif_zero)) {
            if ((mx.at(pivot_row, col_dif_zero)) != 1) {
                mx.changePivotTo_one(pivot_row, mx.at(pivot_row, col_dif_zero));
            }

            for (std::size_t n = pivot_row + 1;  n &lt; height;  ++n) {
                mx.zeroOutTheColumn(n, pivot_row, mx.at(n, col_dif_zero));
            }
        }

        ++pivot_row;
        ++pivot_col;
    }

    //Jordan Elimination
    while (pivot_row &gt; 0) {
        std::size_t col_dif_zero;
        if (mx.firstNumberNot_zero(pivot_row, col_dif_zero)) {
            if ((mx.at(pivot_row, col_dif_zero)) != 1) {
                mx.changePivotTo_one(pivot_row, mx.at(pivot_row, col_dif_zero));
            }
        }

        for (std::size_t n = pivot_row;  n &gt; 0;  --n) {
            mx.zeroOutTheColumn(n-1, pivot_row, mx.at(n-1, col_dif_zero));
        }
        --pivot_row;
    }

    return mx;
}
</code></pre>

<hr>

<h1>Full refactored code</h1>

<h3>Fraction.h</h3>

<pre><code>#ifndef FRACTION_H_INCLUDED
#define FRACTION_H_INCLUDED

#include &lt;iosfwd&gt;
#include &lt;string&gt;
#include &lt;utility&gt;

#include &lt;boost/multiprecision/cpp_int.hpp&gt;

class Fraction
{
    using cpp_int = boost::multiprecision::cpp_int;

    cpp_int num;
    cpp_int den;

public:
    Fraction(cpp_int num = 0, cpp_int den = 1)
        : num{std::move(num)},
          den{std::move(den)}
    {}

    Fraction(int num, int den = 1)
        : num{num},
          den{den}
    {}

    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Fraction&amp; fr);

    std::string to_string() const;

    bool operator==(const Fraction&amp; fr) const { return num == fr.num &amp;&amp; den == fr.den; }
    bool operator!=(const Fraction&amp; fr) const { return !(*this == fr); }

    bool operator&lt;(const Fraction&amp; fr) const { return num * fr.den &lt; den * fr.num; }
    bool operator&lt;=(const Fraction&amp; fr) const { return *this == fr || *this &lt; fr; }
    bool operator&gt;(const Fraction&amp; fr) const { return !(*this&lt;=fr); }
    bool operator&gt;=(const Fraction&amp; fr) const { return !(*this&lt;fr); }

    explicit operator bool() const { return num != 0; }

    Fraction operator+() const;
    Fraction operator-() const;

    Fraction&amp; operator++();
    Fraction&amp; operator--();

    Fraction operator++(int);
    Fraction operator--(int);

    Fraction&amp; operator+=(const Fraction&amp; fr);
    Fraction&amp; operator-=(const Fraction&amp; fr);
    Fraction&amp; operator*=(const Fraction&amp; fr);
    Fraction&amp; operator/=(const Fraction&amp; fr);

private:
    static cpp_int gcd(const cpp_int&amp; a, const cpp_int&amp; b);
    void simplify();
};

Fraction operator+(Fraction a, const Fraction&amp; b) { return a += b; }
Fraction operator-(Fraction a, const Fraction&amp; b) { return a -= b; }
Fraction operator*(Fraction a, const Fraction&amp; b) { return a *= b; }
Fraction operator/(Fraction a, const Fraction&amp; b) { return a /= b; }

#endif // FRACTION_H_INCLUDED
</code></pre>

<h3>Matrix.h</h3>

<pre><code>#ifndef MATRIX_H_INCLUDED
#define MATRIX_H_INCLUDED

#include "Fraction.h"

#include &lt;cassert&gt;
#include &lt;cstddef&gt;
#include &lt;iosfwd&gt;
#include &lt;vector&gt;

class Matrix
{
    std::size_t height = 0;
    std::size_t width = 0;

    std::vector&lt;Fraction&gt; data = {};

    Fraction&amp; at(std::size_t r, std::size_t c)
    { return data[r * width + c]; }

    const Fraction&amp; at(std::size_t r, std::size_t c) const
    { return data[r * width + c]; }


public:
    Matrix()
        : Matrix{0, 0}
    {}

    Matrix(std::size_t height, std::size_t width, const Fraction&amp; n = 0)
        : height{height},
          width{width},
          data(width * height, n)
    {}

    Matrix(std::size_t height, std::size_t width, std::initializer_list&lt;Fraction&gt; values)
        : height{height},
          width{width},
          data(values)
    {
        assert(values.size() == size());
    }

    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Matrix&amp; mx);

    bool operator==(const Matrix&amp; mx) const;
    bool operator!=(const Matrix&amp; mx) const;

    Matrix&amp; operator+=(const Matrix&amp; mx);
    Matrix&amp; operator-=(const Matrix&amp; mx);
    Matrix&amp; operator*=(const Matrix&amp; mx);
    Matrix operator*(const Matrix&amp;) const;

    // scalar multiplication
    Matrix&amp; operator*=(const Fraction&amp; n);

    Fraction&amp; operator()(std::size_t r, std::size_t c)
    { return at(r, c); }

    const Fraction&amp; operator()(std::size_t r, std::size_t c) const
    { return at(r, c); }

    std::size_t size() const
    { return height * width; }

    std::size_t rows() const
    { return height; }

    std::size_t cols() const
    { return width; }

    static Matrix identity(std::size_t n);

    bool is_square() const
    { return height == width; }

    bool is_identity() const;
    bool is_symmetric() const;
    bool is_skewSymmetric() const;
    bool is_diagonal() const;
    bool is_zero() const;
    bool is_constant() const;
    bool is_orthogonal() const;
    bool is_invertible() const;
    bool is_upperTriangular() const;
    bool is_lowerTriangular() const;

    Matrix transposed() const;
    Fraction determinant() const;
    Matrix inverse() const;
    Matrix gaussJordanElimination() const;

private:
    void swapRows(std::size_t row1, std::size_t row2);
    bool pivotEqualTo_one_Found(std::size_t pivot_row, std::size_t pivot_col, std::size_t&amp; alternative_pivot_row) const;
    bool pivotNot_zero_Found(std::size_t pivot_row, std::size_t pivot_col, std::size_t&amp; col_dif_zero) const;
    bool firstNumberNot_zero(std::size_t row_num, std::size_t&amp; num_coluna_num_dif_zero) const;
    void changePivotTo_one(std::size_t row_num, Fraction constant);
    void zeroOutTheColumn(std::size_t row_num, std::size_t num_pivot_row, Fraction constant);
};


Matrix operator+(Matrix a, const Matrix&amp; b)
{ return a += b; }

Matrix operator-(Matrix a, const Matrix&amp; b)
{ return a -= b; }

Matrix operator*(Matrix mx, const Fraction&amp; n)
{ return mx *= n; }

Matrix operator*(const Fraction&amp; n, Matrix mx)
{ return mx *= n; }

#endif // MATRIX_H_INCLUDED
</code></pre>

<h3>Fraction.cpp</h3>

<pre><code>#include "Fraction.h"

#include &lt;ostream&gt;
#include &lt;sstream&gt;

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Fraction&amp; fr)
{
    os &lt;&lt; fr.num;
    if (fr.den != 1) {
        os &lt;&lt; "/" &lt;&lt; fr.den;
    }
    return os;
}

std::string Fraction::to_string() const
{
    std::ostringstream os;
    os &lt;&lt; *this;
    return os.str();
}

Fraction::cpp_int Fraction::gcd(const Fraction::cpp_int&amp; a, const Fraction::cpp_int&amp; b)
{
    return b ? gcd(b, a%b) : a;
}

void Fraction::simplify()
{
    // Denominators are always positive
    if (den &lt; 0) {
        num = -num;
        den = -den;
    }

    // Factor out gcd from numerator and denominator.
    auto const n = gcd(abs(num), den);
    num /= n;
    den /= n;
}


Fraction Fraction::operator+() const
{
    return *this;
}

Fraction Fraction::operator-() const
{
    return { -num, den };
}

Fraction&amp; Fraction::operator++()
{
    num += den;
    return *this;
}

Fraction&amp; Fraction::operator--()
{
    num -= den;
    return *this;
}

Fraction Fraction::operator++(int)
{
    auto old = *this;
    ++*this;
    return old;
}

Fraction Fraction::operator--(int)
{
    auto old = *this;
    --*this;
    return old;
}

Fraction&amp; Fraction::operator+=(const Fraction&amp; fr)
{
    num = num * fr.den + fr.num * den;
    den *= fr.den;
    simplify();
    return *this;
}

Fraction&amp; Fraction::operator-=(const Fraction&amp; fr)
{
    return *this += -fr;
}

Fraction&amp; Fraction::operator*=(const Fraction&amp; fr)
{
    num *= fr.num;
    den *= fr.den;
    simplify();
    return *this;
}

Fraction&amp; Fraction::operator/=(const Fraction&amp; fr)
{
    return *this *= { fr.den, fr.num };
}
</code></pre>

<h3>Matrix.cpp</h3>

<pre><code>#include "Matrix.h"

#include &lt;algorithm&gt;
#include &lt;cassert&gt;
#include &lt;functional&gt;
#include &lt;iomanip&gt;
#include &lt;iostream&gt;
#include &lt;numeric&gt;

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Matrix&amp; mx)
{
    // find maximum element width
    std::size_t max_width = 1;
    for (auto const&amp; element: mx.data) {
        auto w = element.to_string().size();
        if (w &gt; max_width) {
            max_width = w;
        }
    }

    max_width += 4;             // add padding between elements

    // use the max width to format elements
    for (std::size_t i = 0;  i &lt; mx.height;  i++) {
        for (std::size_t j = 0;  j &lt; mx.width;  j++) {
            os &lt;&lt; std::setw(max_width) &lt;&lt;  mx.at(i, j);
        }
        os &lt;&lt; std::endl;
    }

    return os;
}

bool Matrix::operator==(const Matrix&amp; mx) const
{
    return width == mx.width
        &amp;&amp; data == mx.data;
}

bool Matrix::operator!=(const Matrix&amp; mx) const
{
    return !(*this == mx);
}

Matrix Matrix::operator*(const Matrix&amp; mx) const
{
    assert(width == mx.height);

    Matrix mult(height, mx.width);

    for (std::size_t i = 0;  i &lt; height;  ++i)
        for (std::size_t j = 0;  j &lt; mx.width;  ++j)
            for (std::size_t x = 0;  x &lt; width;  ++x)
                mult.at(i, j) += at(i, x) * mx.at(x, j);

    return mult;
}

Matrix&amp; Matrix::operator*=(const Matrix&amp; mx)
{
    return *this = (*this * mx);
}

Matrix&amp; Matrix::operator+=(const Matrix&amp; mx)
{
    assert(height == mx.height);
    assert(width == mx.width);
    std::transform(data.begin(), data.end(),
                   mx.data.begin(), data.begin(),
                   std::plus{});
    return *this;
}

Matrix&amp; Matrix::operator-=(const Matrix&amp; mx)
{
    assert(height == mx.height);
    assert(width == mx.width);
    std::transform(data.begin(), data.end(),
                   mx.data.begin(), data.begin(),
                   std::minus{});
    return *this;
}

Matrix&amp; Matrix::operator*=(const Fraction&amp; n)
{
    for (auto&amp; element: data) {
        element *= n;
    }
    return *this;
}

Matrix Matrix::identity(std::size_t n)
{
    assert(n &gt; 0);

    Matrix mx{n,n};
    for (std::size_t i = 0; i &lt; n; ++i)
        mx.at(i,i) = 1;

    return mx;
}

bool Matrix::is_identity() const
{
    if (! is_square())
        return false;

    return *this == identity(width);
}

bool Matrix::is_symmetric() const
{
    return *this == transposed();
}

bool Matrix::is_skewSymmetric() const
{
    if (!is_square()) {
        return false;
    }

    for (std::size_t i = 0; i &lt; height; ++i) {
        for (std::size_t j = i+1; j &lt; width; ++j) {
            if (at(i, j) != -at(j, i)) {
                return false;
            }
        }
    }

    return true;
}

bool Matrix::is_diagonal() const
{
    if (!is_square())
        return false;

    for (std::size_t i = 0; i &lt; height; ++i)
        for (std::size_t j = 0; j &lt; width; ++j)
            if (i != j &amp;&amp; at(i, j) != 0)
                return false;

    return true;
}

bool Matrix::is_zero() const
{
    return std::all_of(data.begin(), data.end(),
                       [](auto const&amp; x){ return x == 0; });
}

bool Matrix::is_constant() const
{
    return std::adjacent_find(data.begin(), data.end(), std::not_equal_to{})
        == data.end();
}

bool Matrix::is_orthogonal() const
{
    if (!is_square())
        return false;

    return(*this * transposed() == identity(width));
}

bool Matrix::is_invertible() const
{
    return determinant() != 0;
}

bool Matrix::is_lowerTriangular() const
{
    if (!is_square())
        return false;

    for (std::size_t i = 0;  i &lt; height;  ++i)
        for (std::size_t j = i + 1;  j &lt; width;  ++j)
            if (at(i, j))
                return false;

    return true;
}

bool Matrix::is_upperTriangular() const
{
    if (!is_square())
        return false;

    for (std::size_t i = 0;  i &lt; height;  ++i)
        for (std::size_t j = 0;  j &lt; i;  ++j)
            if (at(i, j) != 0)
                return false;

    return true;
}

Matrix Matrix::transposed() const
{
    Matrix trans(width, height);

    for (std::size_t i = 0; i &lt; height; ++i)
        for (std::size_t j = 0; j &lt; width; ++j)
            trans.at(j, i) = at(i, j);

    return trans;
}

Fraction Matrix::determinant() const
{
    assert(is_square());

    if (height == 1) {
        return at(0,0);
    }
    if (is_zero() || is_constant()) {
        return 0;
    }
    if (is_identity()) {
        return 1;
    }

    Matrix mx = *this;
    std::vector&lt;Fraction&gt; row_mults;
    int sign = 1;

    std::size_t pivot_row = 0;
    std::size_t pivot_col = 0;
    while (pivot_row &lt; (height - 1)) {
        std::size_t other_row;
        if (mx.at(pivot_row, pivot_col) != 1 &amp;&amp; mx.pivotEqualTo_one_Found(pivot_row, pivot_col, other_row)
            || mx.at(pivot_row, pivot_col) == 0 &amp;&amp; mx.pivotNot_zero_Found(pivot_row, pivot_col, other_row))
        {
            mx.swapRows(pivot_row, other_row);
            sign *= -1;
        }

        std::size_t col_dif_zero;

        if (!mx.firstNumberNot_zero(pivot_row, col_dif_zero)) {
            return 0;
        }

        if (mx.at(pivot_row, col_dif_zero) != 1) {
            row_mults.push_back(mx.at(pivot_row, col_dif_zero));
            mx.changePivotTo_one(pivot_row, mx.at(pivot_row, col_dif_zero));
        }

        for (std::size_t n = pivot_row + 1;  n &lt; height;  ++n) {
            auto const constant = mx.at(n, col_dif_zero);
            if (mx.at(n, col_dif_zero)) {
                mx.zeroOutTheColumn(n, pivot_row, constant);
            }
        }

        ++pivot_row;
        ++pivot_col;
    }

    Fraction det = sign;
    for (std::size_t i = 0;  i &lt; height;  ++i) {
        det *= mx.at(i, i);
    }

    // now multiply by all the row_mults
    return std::accumulate(row_mults.begin(), row_mults.end(),
                           det, std::multiplies());
}

Matrix Matrix::inverse() const
{
    assert(is_square());

    if (!is_invertible()) {
        throw std::range_error("Matrix not invertible");
    }

    Matrix mx = *this;
    Matrix inverse = identity(height);

    std::size_t pivot_row = 0;
    std::size_t pivot_col = 0;

    //Gauss Elimination
    while (pivot_row &lt; (height - 1)) {
        std::size_t other_row;
        if (mx.at(pivot_row, pivot_col) != 1 &amp;&amp; mx.pivotEqualTo_one_Found(pivot_row, pivot_col, other_row)
            || mx.at(pivot_row, pivot_col) == 0 &amp;&amp; mx.pivotNot_zero_Found(pivot_row, pivot_col, other_row))
        {
            mx.swapRows(pivot_row, other_row);
            inverse.swapRows(pivot_row, other_row);
        }

        std::size_t col_dif_zero;
        if (mx.firstNumberNot_zero(pivot_row, col_dif_zero)) {
            if (mx.at(pivot_row, col_dif_zero) != 1) {
                inverse.changePivotTo_one(pivot_row, mx.at(pivot_row, col_dif_zero));
                mx.changePivotTo_one(pivot_row, mx.at(pivot_row, col_dif_zero));
            }
            for (std::size_t n = pivot_row + 1;  n &lt; height; ++n) {
                inverse.zeroOutTheColumn(n, pivot_row, mx.at(n, col_dif_zero));
                mx.zeroOutTheColumn(n, pivot_row, mx.at(n, col_dif_zero));
            }
        }

        ++pivot_row;
        ++pivot_col;
    }

    //Jordan Elimination
    while (pivot_row &gt; 0) {
        std::size_t col_dif_zero;
        if (mx.firstNumberNot_zero(pivot_row, col_dif_zero)) {
            if (mx.at(pivot_row, col_dif_zero) != 1) {
                inverse.changePivotTo_one(pivot_row, mx.at(pivot_row, col_dif_zero));
                mx.changePivotTo_one(pivot_row, mx.at(pivot_row, col_dif_zero));
            }
            for (std::size_t n = pivot_row;  n &gt; 0;  --n) {
                inverse.zeroOutTheColumn(n - 1, pivot_row, mx.at(n - 1, col_dif_zero));
                mx.zeroOutTheColumn(n - 1, pivot_row, mx.at(n - 1, col_dif_zero));

            }
        }
        --pivot_row;
    }

    return inverse;
}

Matrix Matrix::gaussJordanElimination() const
{
    Matrix mx = *this;

    std::size_t pivot_row = 0;
    std::size_t pivot_col = 0;

    ///Gauss Elimination
    while (pivot_row &lt; (height - 1)) {
        std::size_t other_row;
        if (mx.at(pivot_row, pivot_col) != 1 &amp;&amp; mx.pivotEqualTo_one_Found(pivot_row, pivot_col, other_row)
            || mx.at(pivot_row, pivot_col) == 0 &amp;&amp; mx.pivotNot_zero_Found(pivot_row, pivot_col, other_row))
        {
            mx.swapRows(pivot_row, other_row);
        }

        std::size_t col_dif_zero;
        if (mx.firstNumberNot_zero(pivot_row, col_dif_zero)) {
            if ((mx.at(pivot_row, col_dif_zero)) != 1) {
                mx.changePivotTo_one(pivot_row, mx.at(pivot_row, col_dif_zero));
            }

            for (std::size_t n = pivot_row + 1;  n &lt; height;  ++n) {
                mx.zeroOutTheColumn(n, pivot_row, mx.at(n, col_dif_zero));
            }
        }

        ++pivot_row;
        ++pivot_col;
    }

    //Jordan Elimination
    while (pivot_row &gt; 0) {
        std::size_t col_dif_zero;
        if (mx.firstNumberNot_zero(pivot_row, col_dif_zero)) {
            if ((mx.at(pivot_row, col_dif_zero)) != 1) {
                mx.changePivotTo_one(pivot_row, mx.at(pivot_row, col_dif_zero));
            }
        }

        for (std::size_t n = pivot_row;  n &gt; 0;  --n) {
            mx.zeroOutTheColumn(n-1, pivot_row, mx.at(n-1, col_dif_zero));
        }
        --pivot_row;
    }

    return mx;
}

#include &lt;algorithm&gt;

void Matrix::swapRows(std::size_t row1, std::size_t row2)
{
    auto const a1 = data.begin() + width * row1;
    auto const z1 = a1 + width;
    auto const a2 = data.begin() + width * row2;
    std::swap_ranges(a1, z1, a2);
}

bool Matrix::pivotEqualTo_one_Found(std::size_t pivot_row, std::size_t pivot_col, std::size_t&amp; alternative_pivot_row) const
{
    for (std::size_t i = pivot_row + 1;  i &lt; height;  ++i) {
        if (at(i, pivot_col) == 1) {
            alternative_pivot_row = i;
            return true;
        }
    }

    return false;
}

bool Matrix::pivotNot_zero_Found(std::size_t pivot_row, std::size_t pivot_col, std::size_t&amp; col_dif_zero) const
{
    for (std::size_t i = pivot_row + 1;  i &lt; height;  ++i) {
        if (at(i, pivot_col)) {
            col_dif_zero = i;
            return true;
        }
    }

    return false;
}

bool Matrix::firstNumberNot_zero(std::size_t row_num, std::size_t&amp; num_coluna_num_dif_zero) const
{
    for (std::size_t i = 0;  i &lt; width;  ++i) {
        if (at(row_num, i) != 0) {
            num_coluna_num_dif_zero = i;
            return true;
        }
    }

    return false;
}

void Matrix::changePivotTo_one(std::size_t row_num, Fraction constant)
{
    for (std::size_t i = 0;  i &lt; width;  ++i)
        if (at(row_num, i) == 0)
            at(row_num, i) = at(row_num, i);
        else
            at(row_num, i) = at(row_num, i) / constant;
}

void Matrix::zeroOutTheColumn(std::size_t row_num, std::size_t num_pivot_row, Fraction constant)
{
    for (std::size_t i = 0;  i &lt; width;  ++i) {
        at(row_num, i) -= at(num_pivot_row, i) * constant;
    }
}
</code></pre>

<hr>

<h1>Unit tests</h1>

<p>As I said, we could do with some unit tests to give us more confidence when making changes.  Here's a few to be starting with:</p>

<pre><code>#include &lt;gtest/gtest.h&gt;

TEST(Fraction, equals)
{
    const Fraction zero{};
    const Fraction one{1};
    const Fraction another_one{1};
    const Fraction three_quarters{3,4};
    const Fraction three_fourths{3,4};
    EXPECT_EQ(zero, zero);
    EXPECT_NE(zero, one);
    EXPECT_EQ(one, another_one);
    EXPECT_EQ(three_quarters, three_fourths);
    EXPECT_NE(one, three_quarters);
}

TEST(Fraction, compare)
{
    const Fraction zero{};
    const Fraction one{1};
    const Fraction three_quarters{3,4};
    EXPECT_FALSE(zero &lt; zero);
    EXPECT_TRUE(zero &lt;= zero);
    EXPECT_TRUE(zero &lt; one);
    EXPECT_TRUE(three_quarters &lt; one);
    EXPECT_TRUE(three_quarters &lt;= one);
    EXPECT_FALSE(zero &gt; zero);
    EXPECT_TRUE(zero &gt;= zero);
    EXPECT_FALSE(zero &gt; one);
    EXPECT_FALSE(three_quarters &gt; one);
    EXPECT_FALSE(three_quarters &gt;= one);
}

TEST(Fraction, to_string)
{
    // Since to_string is implemented in terms of operator&lt;&lt;, we're
    // fully testing that, too.
    const Fraction zero{};
    const Fraction one{1};
    const Fraction half{1,2};
    EXPECT_EQ("0", zero.to_string());
    EXPECT_EQ("1", one.to_string());
    EXPECT_EQ("1/2", half.to_string());
}

TEST(Fraction, simplify)
{
    const Fraction half{1,2};
    const Fraction x{2,4};
    const Fraction y{3,6};
    EXPECT_EQ(x, half);
    EXPECT_EQ(y, half);

    const Fraction minus_one_half{-1,2};
    const Fraction one_minus_half{1,-2};
    EXPECT_EQ(minus_one_half, one_minus_half);
}

TEST(Fraction, increment_decrement)
{
    const Fraction one_quarter{1,4};
    const Fraction five_quarters{5,4};
    const Fraction nine_quarters{9,4};
    auto a = one_quarter;
    EXPECT_EQ(five_quarters, ++a);
    EXPECT_EQ(five_quarters, a);
    EXPECT_EQ(five_quarters, a++);
    EXPECT_EQ(nine_quarters, a);
    auto b = nine_quarters;
    EXPECT_EQ(five_quarters, --b);
    EXPECT_EQ(five_quarters, b);
    EXPECT_EQ(five_quarters, b--);
    EXPECT_EQ(one_quarter, b);
}

TEST(Fraction, add_subtract)
{
    // These are implemented in terms of += and -=
    const Fraction one_quarter{1,4};
    const Fraction one_half{1,2};
    const Fraction minus_one_half{1,-2};
    const Fraction five_sixths{5,6};
    const Fraction seven_twelfths{7,12};
    EXPECT_EQ(one_half, +one_half);
    EXPECT_EQ(minus_one_half, -one_half);
    EXPECT_EQ(0-one_half, -one_half);
    EXPECT_EQ(one_half, one_quarter + one_quarter);
    EXPECT_EQ(one_half - one_quarter, one_quarter);
    EXPECT_EQ(seven_twelfths, five_sixths - one_quarter);
}

TEST(Fraction, multiply_divide)
{
    // These are implemented in terms of *= and /=
    const Fraction one_quarter{1,4};
    const Fraction one_half{1,2};
    EXPECT_EQ(one_half, one_quarter * 2);
    EXPECT_EQ(one_half, 2 * one_quarter);
    EXPECT_EQ(one_half, one_quarter / one_half);
}

TEST(Matrix, equals)
{
    EXPECT_EQ(Matrix{}, Matrix{});
    EXPECT_EQ(Matrix::identity(3), Matrix::identity(3));
    EXPECT_NE(Matrix{}, Matrix::identity(1));

    const Matrix all_zero{3, 3, 0};
    const Matrix all_one{3, 3, 1};
    const Matrix all_default{3, 3};
    EXPECT_EQ(all_zero, all_default);
    EXPECT_NE(all_zero, all_one);

    const Matrix two_by_three{2, 3};
    const Matrix three_by_two{3, 2};
    EXPECT_NE(two_by_three, three_by_two);
}

TEST(Matrix, accessors)
{
    const Matrix two_by_three{2, 3};
    EXPECT_EQ(2, two_by_three.rows());
    EXPECT_EQ(3, two_by_three.cols());
    EXPECT_EQ(6, two_by_three.size());
    EXPECT_FALSE(two_by_three.is_square());
    EXPECT_FALSE(two_by_three.is_identity());
    EXPECT_TRUE(two_by_three.is_constant());
    EXPECT_TRUE(two_by_three.is_zero());

    const Matrix null{};
    EXPECT_TRUE(null.is_zero());
    EXPECT_TRUE(null.is_square());
    EXPECT_TRUE(null.is_symmetric());
    EXPECT_TRUE(null.is_skewSymmetric());

    const Matrix zero{2,2};
    EXPECT_TRUE(zero.is_zero());
    EXPECT_TRUE(zero.is_square());
    EXPECT_FALSE(zero.is_identity());
    EXPECT_TRUE(zero.is_symmetric());
    EXPECT_TRUE(zero.is_skewSymmetric());

    const Matrix one{2,2,1};
    EXPECT_FALSE(one.is_zero());
    EXPECT_TRUE(one.is_constant());
    EXPECT_TRUE(one.is_square());
    EXPECT_FALSE(one.is_identity());
    EXPECT_TRUE(one.is_symmetric());
    EXPECT_FALSE(one.is_skewSymmetric());
    EXPECT_FALSE(one.is_upperTriangular());
    EXPECT_FALSE(one.is_lowerTriangular());

    const Matrix identity = Matrix::identity(2);
    EXPECT_FALSE(identity.is_zero());
    EXPECT_FALSE(identity.is_constant());
    EXPECT_TRUE(identity.is_square());
    EXPECT_TRUE(identity.is_identity());
    EXPECT_TRUE(identity.is_symmetric());
    EXPECT_TRUE(identity.is_skewSymmetric());
    EXPECT_TRUE(identity.is_upperTriangular());
    EXPECT_TRUE(identity.is_lowerTriangular());

    Matrix two_by_two{2, 2,
                      {1, 2,
                       0, 4}};
    EXPECT_TRUE(two_by_two.is_upperTriangular());
    EXPECT_FALSE(two_by_two.is_lowerTriangular());
    EXPECT_FALSE(two_by_two.is_skewSymmetric());
    EXPECT_FALSE(two_by_two.is_symmetric());
    two_by_two(1,0) = 2;
    EXPECT_FALSE(two_by_two.is_skewSymmetric());
    EXPECT_TRUE(two_by_two.is_symmetric());
    two_by_two(1,0) = -2;
    EXPECT_TRUE(two_by_two.is_skewSymmetric());
    EXPECT_FALSE(two_by_two.is_symmetric());
    two_by_two(0,1) = 0;
    EXPECT_FALSE(two_by_two.is_upperTriangular());
    EXPECT_TRUE(two_by_two.is_lowerTriangular());
}

TEST(Matrix, plus_minus)
{
    Matrix zero{3,2};
    Matrix one{3,2,1};
    Matrix two{3,2,2};
    Matrix three{3,2,3};
    ASSERT_EQ(one, one + zero);
    ASSERT_EQ(three, one + two);
    ASSERT_EQ(two, three - one);
    ASSERT_EQ(zero, one - one);
}

TEST(Matrix, transposed)
{
    Matrix a{2, 3,
             { 1, 2, 3,
               4, 5, 6 }};
    Matrix b{3, 2,
             { 1, 4,
               2, 5,
               3, 6 }};
    ASSERT_EQ(a, b.transposed());
    ASSERT_EQ(b, a.transposed());
}

TEST(Matrix, determinant)
{
    // identity matrices have determinant == 1
    ASSERT_EQ(Fraction{1}, Matrix::identity(3).determinant());
    // example from Wikipedia
    Matrix a{3, 3,
             { -2, 2, -3,
               -1, 1,  3,
               2,  0, -1 }};
    ASSERT_EQ(Fraction{18}, a.determinant());
    // from https://people.richland.edu/james/lecture/m116/matrices/determinant.html
    Matrix b{4, 4,
             { 3, 2, 0, 1,
               4, 0, 1, 2,
               3, 0, 2, 1,
               9, 2, 3, 1 }};
    ASSERT_EQ(Fraction{24}, b.determinant());
}

TEST(Matrix, inverse)
{
    Matrix a{3, 3,
             { -2, 2, -3,
               -1, 1,  3,
               2,  0, -1 }};
    Matrix b = a.inverse();
    ASSERT_EQ(a * b, Matrix::identity(3));
    ASSERT_EQ(b * a, Matrix::identity(3));
}
</code></pre>
    </div>