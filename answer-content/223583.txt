<div class="s-prose s-prose__disable-spoiler-hover js-post-body" itemprop="text">
<ul>
<li>You can optimize all 3 methods if you initialize <code>list</code>'s capacity to the longest of the two arrays. Resizing a list involves allocating a new internal array and copying old items into the new array, which is something to keep in mind if you care about performance.</li>
<li>Your tests often contain small pieces of manually crafted data. That's not a very scalable approach. It's easy to generate large amounts of test data with a bit of Linq: <code>Enumerable.Range(0, 1000).Select(i =&gt; random.Next(0, 1000)).OrderBy(n =&gt; n).ToArray()</code> gives you an input array. Verification can be done with a few loops (is every number in <code>arr1</code> and <code>arr2</code> present in <code>union</code>, and is every number in <code>union</code> present in either <code>arr1</code> or <code>arr2</code>?). For the duplicate-handling implementation verification is even easier with a combination of Linq's <code>Union</code>, <code>Intersect</code> and <code>OrderBy</code> methods.</li>
<li>Names like <code>i</code>, <code>j</code>, <code>n</code> and <code>m</code> are not very descriptive - specifically which array they're associated with is not clear from their names. Changing them to something like <code>index1</code>, <code>index2</code>, <code>length1</code> and <code>length2</code> will make that relationship clear.</li>
<li>If you're storing array lengths in local variables, then why not also store the results of <code>arr1[i]</code> and <code>arr2[j]</code> in local variables before comparing them? Both of these are micro-optimizations that affect the readability of the code, so I would only do this for performance-sensitive code, and only when profiling shows that it's actually an improvement.</li>
</ul>
    </div>