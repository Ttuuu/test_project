<div class="s-prose s-prose__disable-spoiler-hover js-post-body" itemprop="text">
<h3>Always double-quote variables used in command arguments</h3>

<p>The arguments of <code>mv</code> should have been double-quoted, like this:</p>

<pre><code>mv "${files[${filenum}]}" "$(sed "${filenum}q;d" ~/.temp/newfilenames)"
</code></pre>

<h3>The script is fragile</h3>

<p>As it is, the script looks very fragile:</p>

<ul>
<li><p>The list of files for editing is generated by <code>ls</code>, and then the edited list items are paired up with the <code>files</code> array generated with <code>*</code>. I'm not sure the ordering is guaranteed to be consistent, and I think it would be painful to track down in the documentation if this is indeed the case. It would be easier to generate both lists in a way to ensure consistent ordering.</p></li>
<li><p>Using <code>ls</code> to generate the list is problematic. The output of <code>ls &gt; ...</code> will depend on active aliases. <code>command ls &gt; ...</code> would be safer.</p></li>
<li><p>Files whose names don't change will raise errors when executing <code>mv same same</code></p></li>
<li><p>If there are duplicate lines after editing, one of the original files may silently disappear.</p></li>
<li><p>The script may behave unexpectedly in certain corner cases:</p>

<ul>
<li>the user deleted a line from the file</li>
<li>the user inserted a line in the file</li>
<li>the list of files in the directory changed while editing the file</li>
</ul></li>
<li><p>The user may not have a way to abort the operation. With default shell settings, even if <code>nvim</code> exits with failure, the script goes ahead with the renames, which is probably not what a user would want.</p></li>
<li><p>Even with the double-quoting fixed, the script will not work for files whose names contain newlines. I think that's acceptable and not worth the pain to make it work, but it would be good to document (in a comment).</p></li>
</ul>

<p>To mitigate these issues, I suggest:</p>

<ul>
<li>Create an array from <code>*</code>, let's call it <code>oldnames</code></li>
<li>Save <code>oldnames</code> to the work file: <code>printf '%s\n' "${oldnames[@]}" &gt; "$work"
</code></li>
<li>Let the user edit the work file</li>
<li>Check the exit code, and abort on failure (user can cause failure by exiting <code>nvim</code> with <code>:cq</code>)</li>
<li>Load the content of the work file into another array: <code>mapfile -t newnames &lt; "$work"</code></li>
<li>Add a sanity check to verify that the number of files match before and after.</li>
<li>Run <code>mv</code> only for the files whose names changed, and use <code>-i</code> to avoid overwriting existing files, and <code>-v</code> to show what was actually renamed.</li>
</ul>

<h3>Use <code>mktemp</code> to create temporary files</h3>

<p>The script is not safe to use concurrently.
It's easy enough to create a unique temporary file using <code>mktemp</code>.</p>

<h3>Use <code>trap</code> to clean up temporary files</h3>

<p>To make sure that temporary files get cleaned up when the script exits, use <code>trap</code>, for example:</p>

<pre><code>trap 'rm -f "$tmpfile"' EXIT
</code></pre>

<p>Declare this trap right before creating <code>tmpfile</code>.</p>

<h3>Declare all local variables as <code>local</code></h3>

<p>It's good you declared <code>local files</code>. There is <code>filenum</code> too.</p>

<h3>Don't use <code>seq</code></h3>

<p>The <code>seq</code> utility is not installed by default in all systems,
and Bash has a native way to use counting loops:</p>

<pre><code>for ((i = 0; i &lt; size; i++)); do ...; done
</code></pre>

<h3>If you use Bash arrays, reap all the benefits</h3>

<p>Instead of <code>$(ls | wc -l)</code> to find the count of files,
you already have that in the <code>files</code> array: <code>${#files[@]}</code>.</p>

<h3>Improve performance</h3>

<p>Calling <code>sed</code> in a loop to get the n-th line of a file is inefficient.
It would be better to read the lines into an array,
and then use a counting loop to with the two arrays, for example:</p>

<pre><code>for ((i = 0; i &lt; ${#oldnames[@]}; i++)); do
    old=${oldnames[i]}
    new=${newnames[i]}
    if [[ "$old" != "$new" ]]; then
        mv -vi "$old" "$new"
    fi
done
</code></pre>
    </div>