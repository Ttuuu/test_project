<div class="s-prose s-prose__disable-spoiler-hover js-post-body" itemprop="text">
<ol>
<li>It depends on what is exactly possible in your class - can you override class, can some fields be null at any point? For example retrofit creates classes using reflection and some classes can be very unexpectedly null unless set in constructor without parameters.</li>
<li>Many IDEs have generators, they do this really well.</li>
<li>If you override <code>equals</code>, you really should override <code>hashCode</code> too:
<a href="https://stackoverflow.com/questions/2265503/why-do-i-need-to-override-the-equals-and-hashcode-methods-in-java">https://stackoverflow.com/questions/2265503/why-do-i-need-to-override-the-equals-and-hashcode-methods-in-java</a></li>
</ol>

<p>I included equals generated by Android Studio - 2 possibilities, depending on if you are okay with subclasses too (hashcodes both same).</p>

<pre><code>    @Override
    public boolean equalsV1(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        College college = (College) o;
        return Arrays.equals(student, college.student) &amp;&amp;
                Arrays.equals(teacher, college.teacher);
    }

    @Override
    public boolean equalsV2(Object o) {
        if (this == o) return true;
        if (!(o instanceof College)) return false;
        College college = (College) o;
        return Arrays.equals(student, college.student) &amp;&amp;
                Arrays.equals(teacher, college.teacher);
    }

    @Override
    public int hashCode() {
        int result = Arrays.hashCode(student);
        result = 31 * result + Arrays.hashCode(teacher);
        return result;
    }
</code></pre>

<ul>
<li>You can notice, that there are static methods for arrays in <code>Array</code> class.</li>
<li>Code is trying to exit as soon as it is sure, that equality isn't there rather than your approach, where code runs till the end and maybe it will set equals to <code>true</code> along the way, which has to run longer.</li>
<li>You don't need to use getters, you can use fields directly since it's accessing fields of different instance, but same class.</li>
<li>In <code>College</code> class it's fine, but in <code>Student</code> your class would crash if name is <code>null</code>. It shouldn't happen as even if your empty constructor you set it to something. But sadly in java I can still create <code>Student</code> class and pass <code>null</code> myself (would be good to do null check there). So just to be safe, equals should be able to handle that. There's method for that to make it easier - <code>Objects.equals(name, other.name)</code> rather than <code>name.equals(other.name)</code>. First one will work fine and return false when <code>name</code> is null. Second one will raise <code>NullPointerException</code>. </li>
<li><code>equals</code> shouldn't ever throw <code>Exception</code>. If you aren't sure to guarantee that, it might be better to just surround code in try-catch and return <code>false</code> on exception.</li>
<li>Unless it's exercise, try to rely on these generators. They are pretty good and worked well for me. </li>
<li>Now I switched to <code>kotlin</code>, that has data classes, which automatically have <code>equals</code> and <code>hashCode</code> based on all class properties already saves work and lines of code!</li>
</ul>
    </div>