<div class="s-prose s-prose__disable-spoiler-hover js-post-body" itemprop="text">
<ol>
<li>If you do not need custom piecewise probabilities (which look very strange to me) and instead want to use one of <a href="https://docs.scipy.org/doc/scipy/reference/stats.html" rel="nofollow noreferrer">the many SciPy distributions</a>, you can use their predefined <a href="https://stackoverflow.com/a/20627638/235463">percent point functions (which are inverse CDFs)</a>. Only if you actually need to create a new distribution, you might find my next observations useful. Also, as <a href="https://codereview.stackexchange.com/questions/196286/inverse-transform-sampling#comment479448_196286">agtoever mentioned</a>, you might want to take advantage of <code>rv_continuous</code> in <code>scipy</code>.</li>
<li>Using SymPy is a two-edged sword. Defining and computing CDFs and inverse samples symbolically might be exact, but it may cost more in terms of syntax or CPU time. Still, the CDF is costly to compute numerically also, so your approach might be right for such piecewise functions.</li>
<li>For each call of <code>sample</code>, the CDF should not be recalculated. You should split the computation of the CDF from a PDF into a different function (and have <code>def sample(cdf: [...]</code>). In general, my advice is the same as <a href="https://www.sites.google.com/site/unclebobconsultingllc/one-thing-extract-till-you-drop" rel="nofollow noreferrer">uncle Bob's</a>, namely, to have functions as short as you can make them. (for instance, you could also extract lines from <code>if not isinstance(pdf, sym.Piecewise):</code> to <code>raise NotImplementedError(error_message)</code> in a method which could be called <code>validate</code>.</li>
<li>After extracting the CDF and/or the validation methods, they become testable, and you might want to add tests for them. Perhaps you can also extract and test the pointwise solution of the inverse. Sadly, testing the random sampling itself might be impossible (would fail randomly).</li>
<li>I am not very skilled in optimization, but looking at <a href="https://github.com/peterewills/itsample" rel="nofollow noreferrer">another solution</a>, it seems to me you've got the right idea in deriving the CDF from the given PDF, then solve the pointwise inverse. The other solution finds the CDF numerically, and has the option of approximating the CDF using Chebyshev polynomials for performance reasons.</li>
</ol>
<p>While I can't find more significant problems with the solution, I can't be sure it's correct either (you can never be with software in general). But tests might increase one's confidence in the code.</p>
    </div>