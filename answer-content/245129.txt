<div class="s-prose s-prose__disable-spoiler-hover js-post-body" itemprop="text">
<p>For a coding contest, the answer is almost never to implement the problem the same way as it is given.</p>
<p>For example here, functions A and B are actually intentionally misleading. Function A is also known as Euler's Totient, and function B computes the sum of totients of divisors which <a href="https://proofwiki.org/wiki/Sum_of_Euler_Phi_Function_over_Divisors" rel="nofollow noreferrer">is the same as the original number</a>. Detailed review of them is therefore a waste, functions A and B don't need to be implemented at all.</p>
<p>Function C can be improved by noting that the lowest divisor of a number is necessarily a prime, so calling <code>check_prime</code> is unnecessary. If <code>itr</code> was <code>a * b</code> then <code>a</code> and <code>b</code> would have been found first and divided out of <code>remNum</code> already, making <code>itr</code> not a divisor of <code>remNum</code>.
The square root is also unnecessary, and relatively expensive. It can be avoided by testing <code>itr * itr &lt;= numb</code> instead. There is no risk of overflow given that <code>numb &lt;= 1000000</code>. Further refinements are possible.</p>
<p>Function D can be improved by caching the partial sums. In isolation that would not help, but there can be multiple test cases during a run of the program, and they can reuse the previously computed sums. For example as an extreme case, after the test case <code>1000000</code> has been used, any further test cases could be essentially free, because all possible cases would have been calculated at that point. Also, after <code>funcD(10)</code> has been evaluated, <code>funcD(20)</code> could start with that result instead of starting over from scratch.</p>
    </div>