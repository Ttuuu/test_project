<div class="s-prose s-prose__disable-spoiler-hover js-post-body" itemprop="text">
<p>It seems to me that since you have all these Funcs for getting/setting parents/children and their identifiers, any class you want to use this on basically has to be "ready" to be a heirarchy item and already have a notion of parents/children etc.</p>

<p>Because of this I'd create a interface to indicate how the heirarchy items relate to each other. Something like:</p>

<pre><code>public interface IHeirarchyItem&lt;TKey, TItem&gt; where TItem : IComparable&lt;T&gt; {
    TKey HeirarchyKey {get;}
    TKey ParentKey {get;}
}
</code></pre>

<p>And a interface for a heirarchy "node":</p>

<pre><code>public interface IHeirarchyNode&lt;TKey, TItem&gt; where TItem : IHeirarchyItem {
    void AddChild(TItem child);
    TItem Parent {get; set; }
}
</code></pre>

<p>Category and CategoryDTO can implement these interfaces through existing methods (it is my understanding that those classes are generated by you). Such an implementation would be something like:</p>

<pre><code>public class CategoryDto : IHeirarchyItem&lt;int, CategoryDTO&gt;
{
    public CategoryDto()
    {
        this.ChildCategories = new HashSet&lt;CategoryDto&gt;();
    }

    public int HeirarchyKey { get { return CategoryId;}}
    public int? ParentKey { get { return CategoryParentId ;}}

    public int CategoryId { get; set; }    
    public string Name { get; set; }    
    public int? CategoryParentId { get; set; }    
    public CategoryDto ParentCategory { get; set; }    
    public IEnumerable&lt;CategoryDto&gt; ChildCategories { get; set; }
}
</code></pre>

<p>Or alternatively:</p>

<pre><code>public class CategoryDto : IHeirarchyItem&lt;int, CategoryDto&gt;, IHeirarchyNode&lt;int, CategoryDto&gt;, IComparable&lt;CategoryDto&gt;
{
    public CategoryDto()
    {
        this.ChildCategories = new HashSet&lt;CategoryDto&gt;();
    }

    public int HeirarchyKey { get { return CategoryId;}}
    public int? ParentKey { get { return CategoryParentId ;}}

    public void AddChild(CategoryDto child) =&gt; ChildCategories.Append(child); //not efficient at all! Just an example

    public CategoryDto Parent {
        get =&gt; ParentCategory; 
        set =&gt; ParentCategory= value;
    }

    public int CategoryId { get; set; }    
    public string Name { get; set; }    
    public int? CategoryParentId { get; set; }    
    public CategoryDto ParentCategory { get; set; }    
    public IEnumerable&lt;CategoryDto&gt; ChildCategories { get; set; }

    public int CompareTo (T other) {//do comparison}; 
}
</code></pre>

<p>You can also have a concrete HeirarchyNode : IHeirarchyNode where TItem : IHeirarchyItem {...} which has an actual list of children and a reference to a parent e.g. </p>

<pre><code>public class HeirarchyNode&lt;TKey, TItem&gt; : IHeirarchyNode&lt;int, TItem&gt; where TKey : struct where TItem : IHeirarchyItem&lt;int, TItem&gt;, IComparable&lt;TItem&gt; {
        public List&lt;TItem&gt; Children {get;set;}
        public TItem Parent {get;set;}

        public void AddChild(TItem child) =&gt; Children.Add(child);
    }
</code></pre>

<p>Your code for setting up the heirarchy can then work off these interfaces.</p>

<p>The benefit of this approach is that the Category objects always have control of how they fit into a heirarchy with each other and AsHierarchy() method can have a shorter, more readable signature.</p>

<p>If you cannot or do not want to have classes implementing these heirarchy interfaces directly, you could have a implementation of IHeirarchyItem which takes in Func(s) for getting the keys etc. I recommend you do this using some kind of factory so that you can ensure that the way a IHeirarchyItem for a given type works will be consistent in all cases.</p>
    </div>