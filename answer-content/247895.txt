<div class="s-prose s-prose__disable-spoiler-hover js-post-body" itemprop="text">
<p>I agree with the other answer and yourself that you should try and keep away from encoding / decoding binary values altogether. The same goes for finding the highest bit from a number; converting to a string to find a character is vastly less performant than looking for bits directly. However, that's already mentioned <a href="https://codereview.stackexchange.com/a/247489/9555">in the other answer</a>, so this is just code review following up on that.</p>
<p>I'm not sure why you would not just use <code>i</code> (formatted as a byte array) as input, I just wanted to mention that as the RNG might well be dependent on a hash, and may therefore be a bigger bottleneck than the SHA-1 hash itself. Just a small note that <code>getrandbits</code> uses the Mersenne Twister underneath, so you should get non-secure but well distributed random numbers from it (so <em>that</em> particular random number generator probably won't be a bottleneck).</p>
<p>Since Python 3.6 you can use underscores in number literals (<code>10_000_000_000</code> is easier to distinguish as 10 billion on the short scale). Otherwise you can write it down as <code>10 * 1000 * 1000 * 1000</code> which at least makes is readable without having to manually count zeros.</p>
<p>[EDIT] I've removed the part of <code>str</code> method adding additional characters (which it seemingly still does). For this question the encoding of the characters afterwards as ASCII seems to resolve the issue anyway. Encoding as a string and then converting back to bytes immediately after still doesn't seem to be the way to go, obviously.</p>
    </div>