<div class="s-prose s-prose__disable-spoiler-hover js-post-body" itemprop="text">
<h1>Naming</h1>
<p>I'm sure you already know this, but naming matters.  The few keystrokes that you save using <code>w</code> are paid for every time somebody reads the code.  Consider always using more meaningful names <code>withdrawalAmount</code> etc.</p>
<p>Be cautious about reusing names of classes from the standard library.  Rather than <code>Consumer</code>, consider giving it a more specific name to reflect what it's consuming.  This will both be more descriptive and remove the name conflict with <code>Consumer&lt;T&gt;</code>.</p>
<h1>Scenario</h1>
<p>The scenario you've constructed feels a bit forced, which makes it more difficult to assess if the code really makes sense.  Bank accounts don't really a producer/consumer relationship.  Spinning up a new thread, in order to perform a single transaction feels very inefficient.  On the face of it, your producer creates money and your consumer removes money.  I can't help but feel like really, they are both producing transactions that would be better served by a <code>TransactionConsumer</code>.</p>
<h1>Factory</h1>
<p>Consider using an enum rather than a raw <code>String</code> for the account.  Perhaps you need the flexibility of a string, however if you can use an enum it makes typo's less likely and removes the need for your 'else' conditions.</p>
<p>Generally speaking, when you can't handle a situation you want to throw an exception.  The error printed if an unsupported account is specified suggests that the caller does something else do you really want this method to return <code>null</code> in that scenario?  If you do want to support 'possibly' creating the account, consider returning an <code>Optional</code> instead to give the caller a hint that it could fail.  Currently your <code>main</code> doesn't check if null is returned, so you'll end up with <code>NullPointerException</code>s from your Producer/Consumers.</p>
<p>If the intention is to only have the accounts created by your factory, I would consider dropping the non-balance constructor from your accounts.  This would make it easier to overload the construction methods and chain them:</p>
<pre><code>public BankAccount getAccount(String account, String name) {
    return getAccount(account, name, 0);
}
</code></pre>
<h1>BankAccount</h1>
<p>To answer question 4, no you shouldn't always include setters.  If you don't want the value to be changed from outside the class after construction, don't include setters.  In the future, people with less context may decide that since it's there, it must be ok to use it.  <code>setBalance</code> is a good example of a confusing setter.  Why would you want an external actor to be able to set the balance of this account?  But what makes it stand out is that whilst <code>getBalance</code>, <code>deposit</code> and <code>withdrawal</code> are synchronised, <code>setBalance</code> isn't.  So, somebody could do a deposit and have a receipt for a different balance entirely printed...</p>
<p>Money is one of those things where people start getting upset if rounding errors start impacting their balance.  Generally speaking you should be using <code>BigDecimal</code> for money, rather than relying on <code>double</code>.</p>
<p>I'm not a huge fan of overly commented code, however in your deposit method you sleep for 300.  Consider adding a comment as to why you're sleeping, or extracting the logic into a private method that indicates what the sleep is about, something like <code>simulateSlowProcessing</code> perhaps.</p>
<p>To me, <strong>withdraw has a bug</strong>.  If a withdrawal comes in that is more than the balance, the thread can't escape until after the balance goes above that value.  This might be ok, if you were waiting for a message to process, however it doesn't really seem to make sense for a withdrawal.  If you don't have money, you expect it to tell you that and move on.  Indeed, if you escape the while loop, you perform a check that suggests you want to be able to fail transactions if there isn't sufficient funds.  Because the scenario isn't entirely clear, it's difficult to know what you expect the behaviour to be.  Changing <code>Main.Consumer</code> to withdraw 500, for example can result in the program never exiting.</p>
<p>It also looks like there is an <strong>AccountNumber bug</strong>.  Again, this is probably caused by the scenario, however you're using a static to set the account number for created accounts.  However, you only do this through the 'name' constructor.  You don't do it through the 'name' and 'initial balance' constructor, which is the one you're actually using.</p>
<h1>SavingsAccount</h1>
<p><strong>compoundInterest has a bug</strong> in my view.  You're not currently calling it, however it makes use of <code>setBalance</code> on the base class.  You get the balance, perform some calculation and then set the balance.  It's possible for <code>deposit</code>/<code>withdrawal</code> to be called between the <code>getBalance</code> and the <code>setBalance</code> which meaning that money can be lost or gained as a consequence.  If you want to do stuff like this, then it would be better to use the atomic adjustment methods in the base class.  So, for example you could use <code>deposit</code> to add a calculated amount of interest to the balance...</p>
<h1>Your questions</h1>
<ol>
<li><p>Whether or not to use runnable or thread class depends on what you're doing, at the moment I don't think it makes a lot of difference either way.  As I've said, I'm not sure that spinning up a thread for each transaction really makes sense to me.</p>
</li>
<li><p><code>static</code> methods in your main class are fine, however, you want your main to be responsible for one thing, typically bootstrapping your application.  With that in mind, the scope for having many static methods should be quite small.  I think the same applies for <code>static</code> classes, they aren't 'bad', however they may be a sign that the Main class is doing too much.</p>
</li>
<li><p>For multi-threading, control performed at the right level.  Typically, you want to minimise the amount of time when objects are locked, so protecting balance in the base object seems to make sense.  However, as I've already indicated you need to be careful about what you do in derived classes to ensure you don't accidentally break that encapsulation.</p>
</li>
<li><p>Setters aren't always required, fields that you don't expect at all (open date, account number...) should also be marked as <code>final</code>. Some serialisation may require setters, but then you might want to reconsider your logic location.</p>
</li>
<li><p>An arraylist of accounts sounds OK in principal, however you've not done anything with it the code.  Whether or not it's tightly coupled really depends on what you do with it and how/if you expose it to other classes.  A <code>HashMap</code> of accountNumber to Account might make more sense... but consider how/if your Bank needs to know the type of account and how it will identify them.</p>
</li>
</ol>
    </div>