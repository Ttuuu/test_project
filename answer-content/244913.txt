<div class="s-prose s-prose__disable-spoiler-hover js-post-body" itemprop="text">
<p>The code is slow on larger arrays because of the nested <code>for</code> loops. The number of times the inner loop runs depends on the length of the array. The outer loop runs <code>arr_len</code> times and the inner loop runs <code>arr_len/2</code> times on average. As a result the code in the loop runs <code>arr_len**2 / 2</code>. If the size of the array doubles, the amount of work the code does quadruples. If the size goes up by a thousand, the work goes up by a million.  You may see this described as O(n^2) time complexity.</p>
<p>The trick is to find an algorithm than scans the array once (or maybe a few times). Here are some observations that might help:</p>
<p>If the 1st element of a subarray is <code>x</code>, then a valid subarray is a sequence of <code>x</code>'s, a sequence of <code>x</code>'s and <code>x+1</code>'s or a sequence of <code>x</code>'s and <code>x-1</code>'s. For example, [2,2,2], [2,2,3,3,2,3], and [2,1,1,2,2,2,2,2] could be valid subarrays.</p>
<p>Depending on the form of the subarray, <code>min, max</code> is either <code>(x,x)</code>, <code>(x, x+1)</code>, or <code>(x-1, x)</code>. And all the values in the valid subarray are <code>min</code> or <code>max</code>.</p>
<p>Depending on the value that ends the current subarray, a new subarray can start where it changed between <code>min</code> to <code>max</code>, or the reverse.  Or it could start with the new value. For example, [1,1,2,2,3,3] has overlapping subarrays [1,1,2,2] and [2,2,3,3].  But [1,1,2,2,0,0] doesn't: [1,1,2,2] and [0,0].</p>
    </div>