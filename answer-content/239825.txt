<div class="s-prose s-prose__disable-spoiler-hover js-post-body" itemprop="text">
<p>I'd say that yes, using globals was an evil choice, and I think that splitting this functionality into objects would be a good move.</p>

<p>As the original author you might have found it easier to just keep track of the globals in your head and not have to type them as arguments to each function, but as a reader, it makes it very hard to follow the changes in state between functions.</p>

<p>Not having to pass large numbers of variables as arguments between functions is where OOP can help you.  (Note: I always think of OOP as being a means to an end and do not advocate shoving it in without a purpose -- come at me, Java bros!  In this case, the "end" is being able to better organize all your bits and bobs of state.)  On first blush, my approach to this would be to have two objects: a "game state" object (that tracks where everything is in the game and implements the "rules") and a "game UI" object (that manages all of the interface business, i.e. the screen drawing and the keypresses).  So instead of one big pile of globals, you have two objects that hold all that data; your "setup" function creates and returns those two objects and then the rest of your game logic operates on/within them.  You'd probably be able to turn some of your functions into class methods (as a rule of thumb, anything that modifies one of those pieces of state should probably live inside that class).</p>

<p>Once you'd finished that refactoring, my next recommendation would be to look at functions that don't operate purely on one object or the other, and then split those up -- separate your game logic from your UI.  Basically you want each function to do one thing in one "layer" of your app, and keep responsibilities separated; this is the concept of "model/view" in a nutshell.</p>
    </div>