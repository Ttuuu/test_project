<div class="s-prose s-prose__disable-spoiler-hover js-post-body" itemprop="text">
<h1>Be careful naming your functions</h1>
<p>You declare a lambda function named <code>EncodeAES</code>, but this function itself doesn't know anything about AES. It accepts an object with an <code>encrypt()</code> member function which it calls, but that object could be anything.</p>
<p>The name should reflect what the function does. This one does two things: it base64-encodes, and it calls <code>encrypt()</code>. I think any descriptive name would be really awkward, maybe it is best not to use these lambda's at all, especially since they are only used once.</p>
<h1>Don't modify the message before/after encryption</h1>
<p>Your <code>DecodeAES</code> lambda calls <code>rstrip()</code> on the decrypted message. But what if the original text has whitespace of its own at the end of the message that is significant? Or what if the message is not a piece of text but a binary file? Then the output after decryption will be different from the message before encryption. It also allows for <a href="https://en.wikipedia.org/wiki/Length_extension_attack" rel="nofollow noreferrer">length extension attacks</a>.</p>
<h1>Don't use ECB mode</h1>
<p>You should <a href="https://crypto.stackexchange.com/questions/20941/why-shouldnt-i-use-ecb-encryption">never use ECB mode to encrypt things</a>, it has many issues such as revealing patterns in the plaintext, and allowing an attacker to flip bits in the plaintext at will.</p>
<p>Almost any other mode would be suitable to use, if you add a <em>unique</em> <a href="https://en.wikipedia.org/wiki/Initialization_vector" rel="nofollow noreferrer">initialization vector</a> (IV) to the ciphertext. Note that this IV should be different each time you write an encrypted file, otherwise it might make it easy for someone to decrypt parts of the message by comparing two ciphertexts.</p>
<p>Even better would be to use an <a href="https://en.wikipedia.org/wiki/Authenticated_encryption" rel="nofollow noreferrer">authenticated encryption</a> mode to ensure that if an attacker has tampered with the ciphertext, this is detected when trying to decrypt the message. If you don't provide any form of authentication of the ciphertext, it allows an attacker to modify it, and then the output after decryption will be modified as well, sometimes in ways that are not easy to spot.</p>
<h1>Don't use home-grown crypto in production code</h1>
<p>While it is perfectly fine to try to implement your own encryption protocols (it's a good way to start learning about it), it is very easy to make mistakes, and mistakes will be costly (since there probably is a good reason why you want to keep the data private).</p>
<p>Go to  <a href="https://crypto.stackexchange.com/">https://crypto.stackexchange.com/</a> and search there for how to safely encrypt files. You'll likely find many answers <a href="https://crypto.stackexchange.com/questions/3746/what-is-the-best-practice-for-encrypting-small-files">like this one</a> that tell you to not try it yourself and rather use existing, well-established software to do encryption for you. If you don't want to become a crypto expert, then follow that advice. If you really do want to become better at crypto, then have a look at the well-established software and protocols out there, and try to learn how they work.</p>
<h1>Use a higher-level cryptography library</h1>
<p>The Crypto package is quite low-level. It provides you the basics of encryption, but already for <em>properly</em> encrypting a file you need to combine several techniques. It is better to use a library that provides higher level functions that take care of all the details for you. There are many of them out there. A popular one is <a href="https://pypi.org/project/PyNaCl/" rel="nofollow noreferrer">PyNacl</a>.</p>
    </div>