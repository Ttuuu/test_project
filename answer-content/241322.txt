<div class="s-prose s-prose__disable-spoiler-hover js-post-body" itemprop="text">
<p>Seems like cheating to re-implement a list using a list... I feel like the real challenge would be doing so without a list of any sort, say creating a linked list or a tree or something like that. That might be pedantic, but it'd clarify what your limitation are and thus what efficient solutions are available versus what you're making needlessly hard for yourself because it's fun.</p>

<p>Most of your functions are going to be very expensive because you're constantly copying memory around. A more common approach is to over-allocate space and then keep two values, "length" and "_allocated". The first is how many valid elements your array contains; the second is how much space you've reserved to store values. When you want to append X to your array, you can just assign X to <code>self.array[self.length]</code> and then increment <code>self.length</code>. If that would take you beyond what you've allocated, only then you do the expensive act of allocating a new chunk of memory (in your case, the <code>[None] * (length + 1)</code> line) and copying the data. To minimize the number of copies, it's common practice to double the length of the array each time you resize it (maybe up to some maximum, at which point you add on new 4K element blocks or whatever rather than multiplying, to prevent running out of memory prematurely). When inserting, then, you'd just need to shift the later values rather than copy everything; similarly, when popping values off, just decrement <code>self.length</code> to mark that last element as unimportant and available to be overwritten.</p>

<p>To complement that approach, if you want to optimize for mid-array insertions and deletions, you can maintain a parallel bit-array of which values are valid and which aren't. Iterating through the array becomes trickier (you need to zip the values with the validity flags and only return the valid ones), but deleting an item becomes cheaper since you only need to find the element and mark it as deleted (no shifting required), and inserting an item only requires shifting things until you find an unused element that can be overwritten instead of shifted.</p>

<p>Caching the length of the array is a good idea in general (though not necessary if you don't over-allocate). It requires extra code and care to keep synchronized with the rest of the array, but checking a list's length is a very common thing for users to want to do, and the O(N) computation each time can get painful.</p>

<p>As a general Python'ism, I'd say use <a href="https://docs.python.org/3/reference/datamodel.html#object.__len__" rel="nofollow noreferrer"><code>def __len__</code></a> instead of <code>def len</code> and implement <a href="https://docs.python.org/3/reference/datamodel.html#object.__getitem__" rel="nofollow noreferrer"><code>__get_item__</code></a>, as well as any other magic methods that generally correspond to an array. For reference see <a href="https://docs.python.org/3/library/collections.abc.html" rel="nofollow noreferrer">this documentation page</a>, and consider that most people think of an array as some combination of a <a href="https://docs.python.org/3/library/collections.abc.html#collections.abc.Collection" rel="nofollow noreferrer">"Collection"</a> and <a href="https://docs.python.org/3/library/collections.abc.html#collections.abc.MutableSequence" rel="nofollow noreferrer">"[Mutable]Sequence"</a></p>
    </div>