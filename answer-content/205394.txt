<div class="s-prose s-prose__disable-spoiler-hover js-post-body" itemprop="text">
<h3>1. Dynamic problem</h3>

<p>The post says:</p>

<blockquote>
  <p>I have a Python-Tkinter UI that has a field with dots. A user can choose some of them, and program must show points for currently chosen dots after every new click (so speed matters).</p>
</blockquote>

<p>This kind of situation, where there are small changes to the input (here, adding a dot to the set of selected dots) and the algorithm must update its output (here, the score) in a timely manner, is known as a <a href="https://en.wikipedia.org/wiki/Dynamic_problem_(algorithms)" rel="noreferrer">dynamic problem</a>.</p>

<p>The code in the post starts again from scratch whenever the input changes. But this is inefficient: when a new dot is chosen, the code in <code>Algorithm.init_vectors</code> looks at the vector from each dot to every other dot. So if there are <span class="math-container">\$n\$</span> dots, it takes <span class="math-container">\$O(n^2)\$</span> to update the score.</p>

<p>However, as we'll see below, an algorithm that maintains a suitable data structure can process each new dot and update the total number of points in constant time. (Strictly speaking, in time that depends on the size of the field of dots and the goal value, but this is constant for any particular game.)</p>

<p>Accordingly, I won't review the code in the post, but instead present the better algorithm.</p>

<h3>2. Algorithm sketch</h3>

<p>The key observation is that there is a fixed set of lines through each dot that have the goal number of dots (or more). For example, if the field is an 8×8 checkerboard of dots, and the goal is four dots per line, then there are eight lines through the red dot that we might need to consider:</p>

<p><img src="https://i.stack.imgur.com/31N6e.png" alt=""></p>

<p>What this means is that we can keep a mapping from lines to the number of selected dots on each line, for example using <a href="https://docs.python.org/3/library/collections.html#collections.Counter" rel="noreferrer"><code>collections.Counter</code></a>:</p>

<pre><code>from collections import Counter

class Dots:
    """Object representing the state of a rectangular grid of dots."""

    def __init__(self, width, height, goal):
        """Construct rectangular grid of dots with the given width and height,
        and the goal being to construct lines with the given number of
        dots.

        """
        self.width = width
        self.height = height
        self.goal = goal
        self.selected = set() # Set of selected dots
        self.line_dots = Counter() # line -&gt; count of selected dots on line
        self.goal_lines = 0 # Lines with selected dots &gt;= goal
</code></pre>

<p>And then when the user selects a new dot, we can update the mapping and the score like this:</p>

<pre><code>def select_dot(self, dot):
    """Select the dot with the given coordinates."""
    assert dot not in self.selected
    self.selected.add(dot)
    for line in self.lines_through_dot(dot):
        self.line_dots[line] += 1
        if self.line_dots[line] == goal:
            self.goal_lines += 1
</code></pre>

<h3>3. Representing lines</h3>

<p>What kind of objects are the <code>line</code> values generated by <code>lines_through_dot</code>?</p>

<p>A natural way to uniquely represent a line is by the pair <span class="math-container">\$n, n·p\$</span> where <span class="math-container">\$n\$</span> is a normal vector to the line, <span class="math-container">\$p\$</span> is any point on the line and <span class="math-container">\$·\$</span> is the dot product. (This works as a representation because the value of <span class="math-container">\$n·p\$</span> is the same for every point on the line.)</p>

<p>So <code>lines_through_dot</code> can be implemented like this:</p>

<pre><code>def lines_through_dot(self, dot):
    """Generate the lines passing through dot that might have at least
    goal dots, in a rectangular grid of dots with the given width
    and height. Each line is a pair (n, n @ dot) where n is a
    normal vector to the line.

    """
    for normal in self.line_normals:
        yield normal, sum(i * j for i, j in zip(normal, dot))
</code></pre>

<p>Note that because we're going to be using these line representations as dictionary keys, I've been careful to avoid the need for floating-point arithmetic, because then it might not be the case that <span class="math-container">\$n·p\$</span> is the same for every <span class="math-container">\$p\$</span> due to the limitations of floating point. This is why I've not required <span class="math-container">\$n\$</span> to be a <em>unit</em> normal.</p>

<h3>4. Finding the lines</h3>

<p>How are we going to implement <code>line_normals</code>? Well, it depends on how the field of dots is arranged, and the post doesn't explain this. But the <a href="https://github.com/iAnanich/rpo-4inaline/blob/upgrade_algo/app/tk_gui.py" rel="noreferrer">code for the user interface</a> suggests that it is a rectangular grid of dots. Where the dots form a regular grid it's possible to enumerate the lines by considering the possible slopes for the line. For example, if the field is an 8×8 checkerboard of dots, and the goal is four dots per line, then there are 74 lines altogether:</p>

<p><img src="https://i.stack.imgur.com/LiKcT.png" alt=""></p>

<p>In the figure I've grouped the lines according to their direction, given as a vector <span class="math-container">\$x, y\$</span> below the group. The normals to these directions can be generated like this, using <a href="http://docs.python.org/3/library/itertools.html#itertools.product" rel="noreferrer"><code>itertools.product</code></a> and <a href="http://docs.python.org/3/library/math.html#math.gcd" rel="noreferrer"><code>math.gcd</code></a>:</p>

<pre><code>from functools import lru_cache
from itertools import product
from math import gcd

@property
@lru_cache(maxsize=1)
def line_normals(self):
    """List of distinct normal vectors (x, y) to lines that might have at
    least goal dots.

    """
    x_max = (self.width - 1) // (self.goal - 1)
    y_max = (self.height - 1) // (self.goal - 1)
    result = []
    for x, y in product(range(x_max + 1), range(-y_max, y_max + 1)):
        if gcd(x, y) == 1 and (x, y) != (0, -1):
            result.append((-y, x))
    return result
</code></pre>

<p>Notes:</p>

<ol>
<li><p>The reason for the call to <code>gcd</code> is that, for example, the direction <span class="math-container">\$1, 1\$</span> is the same as <span class="math-container">\$2, 2\$</span>, but we need to generate each direction just once to avoid double-counting.</p></li>
<li><p>The reason for the special case <code>(x, y) != (0, -1)</code> is that the directions <span class="math-container">\$0, 1\$</span> and <span class="math-container">\$0, −1\$</span> both have greatest common divisor 1, but represent the same set of lines, so we need to drop one of them to avoid double-counting.</p></li>
<li><p>I've made this a <em>cached property</em> using <a href="http://docs.python.org/3/library/functools.html#functools.lru_cache" rel="noreferrer"><code>functools.lru_cache</code></a> so that we can call it multiple times without worrying about the cost of recomputing the result.</p></li>
</ol>

<p>For example:</p>

<pre><code>&gt;&gt;&gt; Dots(8, 8, 4).line_normals
[(-1, 0), (2, 1), (1, 1), (0, 1), (-1, 1), (-2, 1), (1, 2), (-1, 2)]
</code></pre>

<h3>5. Summary</h3>

<p>The <code>select_dot</code> method updates <code>self.goal_lines</code> in time <span class="math-container">\$O\left({wh \over g^2}\right)\$</span>, where <span class="math-container">\$w\$</span> and <span class="math-container">\$h\$</span> are the width and height of the grid, and <span class="math-container">\$g\$</span> is the goal (dots per line). This does not depend on the number of dots and so is constant for any particular game.</p>
    </div>