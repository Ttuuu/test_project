<div class="s-prose s-prose__disable-spoiler-hover js-post-body" itemprop="text">
<p>(Uh-oh: <code>better</code> - better define a quality measure!)  </p>

<ul>
<li>Your <em>code</em> doesn't <a href="http://www.doxygen.nl/manual/docblocks.html" rel="nofollow noreferrer">tell</a> what it's about.  </li>
<li><code>constexpr</code> <em>looks</em> good - "my" environment complains with C++11.  </li>
<li><p>"The array&amp;index manipulation" where "simultaneous assignment" is wanted is hard to read (could be worse: the elements of <code>result[]</code> could be non-interchangeable).<br>
Alas, what I found for "modern C++" is ghastly compared to python's <code>a, b = b, a + b</code>. I appreciate the attempt to avoid avoidable assignments; I'm mildly curious if it makes <em>any</em> difference in the code generated by an optimising compiler.  </p></li>
<li><p><code>Is there any better?</code> Well, with <em>output size limited by a constant</em>, there's a tighter limit:<br>
the runtime of your code is in <code>O(1)</code>, just as any other.<br>
In a comment, you express concern about the complexity of multiplication. If you accept ("bit-wise") "shift" as a (very) cheap operation, you can take three steps in the Fibonacci sequence at once without an increase in "logic gate complexity":</p></li>
</ul>

<pre class="lang-cpp prettyprint-override"><code>#include &lt;cstdlib&gt;
#include &lt;tuple&gt;
#include &lt;iostream&gt;

/// Iterates an a,b = b,a+b sequence in steps of three.
//constexpr
static unsigned long tri(int previous, int current, const unsigned int n) {
    if (n &lt; 2)
        return n ? current : previous;
    std::div_t split = std::div(n-2, 3);
    while (0 &lt;= --split.rem)
        std::tie(previous, current)
            = std::make_tuple(current, current+previous);
    unsigned long
        a = current - previous,
        b = current + previous;      
    while (0 &lt;= --split.quot)
        std::tie(a, b) = std::make_tuple(b, (b&lt;&lt;2)+a);

    return b;
}
/// Iterates the Fibonacci sequence in steps of three.
unsigned long fibonacci(const unsigned int n) {
    return tri(0, 1, n);
}
/// Iterates the Lucas numbers in steps of three.
unsigned long lucas(const unsigned int n) {
    return tri(2, 1, n);
}
</code></pre>

<p>(For variants using arrays of precomputed elements in stead of "the setup-loop" (and a <code>main()</code>), consult the edit history.)<br>
(<code>b</code>*Phi³ <em>coincidentally</em> can be computed with just two summands (and no other power up to 2³² can).)  </p>
    </div>