<div class="s-prose s-prose__disable-spoiler-hover js-post-body" itemprop="text">
<p>First, I think this code arguably <em>abuses</em> tuple destructuring to declare and reassign variables. Declaring multiple variables on a line generally hurts readability, just to save a line/some keystrokes. I would write everything out fully, even if that comes with the cost of verbosity. I'd also space it out a bit:</p>

<pre><code>def my_blur_image1(a):
    result = []
    for i in range(len(a)):
        row = []
        for j in range(len(a[i])):
            total = a[i][j]
            count = 1
            if i + 1 &lt; len(a):
                total += a[i+1][j]
                count += 1

            if j + 1 &lt; len(a[i]):
                total += a[i][j+1]
                count += 1

            if i - 1 &gt; -1:
                total += a[i-1][j]
                count += 1

            if j - 1 &gt; -1:
                total += a[i][j-1]
                count += 1

            row.append(round(total/count, 2))

        result.append(row)

    return result
</code></pre>

<hr>

<p>Twice, you have something along the lines of</p>

<pre><code>lst = [] # Create a list
for i in range(len(a)):
    res = # Calculate some result
    lst.append(res)
</code></pre>

<p>I think the logic could be broken up, and could make use of some list comprehensions. This is basically the scenario that list comprehensions (and <code>map</code>) are intended for. Iterating over a list to produce a new list is a <em>very</em> common operation.</p>

<p>I'm not <em>necessarily</em> recommending this way, but it does show an alternative, more functional way of approaching the problem. I'll say that my way ended up a fair bit slower than yours. On my machine, yours takes roughly 14 seconds for a 2000x2000 matrix, while my version takes 25 seconds unfortunately. You didn't tag performance though :D</p>

<pre><code># Returns whether or not i,j is inbound for a given a matrix
def inbounds(i, j, a):
    return 0 &lt;= i &lt; len(a) and \
           0 &lt;= j &lt; len(a[i])

# Returns the inbound pixel values on and surrounding the given point
def inbound_pixels_around(i, j, a):
    # I figured it was best to hard-code the indices instead of using several "if"s like you had done
    # That way, I can make use of looping to reduce some duplication
    # If diagonal pixels were included, this could be generated by another comprehension instead
    indices = [(i, j), (i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]

    # Iterate over the indices.
    # Remove the ones that are  out of bounds, and use the inbound ones to index the list
    return [a[i][j] for (i, j) in indices if inbounds(i, j, a)]

def my_blur_image2(a):
    # A 3D-array. Each pixel has been replaced by a list of inbound neighbor values
    inbound_neigh_rows = [[inbound_pixels_around(i, j, a) for j in range(len(a[i]))]
                          for i in range(len(a))]

    # Then iterate ever each set of neighbors, and divide the sum of the neighbors by their length
    # This does away with needing an explicit "count" variable
    return [[sum(neighs) / len(neighs) for neighs in row]
            for row in inbound_neigh_rows]
</code></pre>

<p>I'm making fairly extensive use of list comprehensions here. I'm using them to filter out non-inbound cells in <code>inbound_pixels_around</code> using <code>inbounds</code>, and to generate neighbors and their average values in <code>my_blur_image2</code>.</p>

<pre><code>test_data = [[1, 2, 3],
             [4, 5, 6],
             [7, 8 ,9]]

print(blur_image(test_data))
print(my_blur_image1(test_data))
print(my_blur_image2(test_data))

[[2.33, 2.75, 3.67], [4.25, 5.0, 5.75], [6.33, 7.25, 7.67]]
[[2.33, 2.75, 3.67], [4.25, 5.0, 5.75], [6.33, 7.25, 7.67]]
[[2.3333333333333335, 2.75, 3.6666666666666665], [4.25, 5.0, 5.75], [6.333333333333333, 7.25, 7.666666666666667]]
</code></pre>

<hr>

<p>Updated to make use of comparison chaining. Thanks @Mathias.</p>
    </div>