<div class="s-prose s-prose__disable-spoiler-hover js-post-body" itemprop="text">
<h1>A bug</h1>
<p>This version of the program uses limited-length codes, which is good. Decoding looks good. However, limited-length codes create a new edge case: what if the tree is deeper than the length limit? There are various solutions, but as far as I can tell, none of them are used in this program - a length that exceeds <code>MAX_CODE_LEN</code> is generated and things go wrong. This is difficult to find with tests, as almost any realistic string would not result in such a long code. As an example of an unrealistic string, <a href="https://gist.github.com/IJzerbaard/cda751c7c2c43217371099c84ce1e18f" rel="nofollow noreferrer">here</a> is one (I cannot put it directly in this answer, it exceeds the size limit of 64KB). I mentioned some approaches to handle that edge case last time, but to go into a little more detail of the simplest trick: divide the frequencies by 2 while rounding up, then rebuild the tree (iterate if necessary).</p>
<p>Or, as an alternative to correctly handling that edge case, I suggest at least correctly failing to handle it: outputting an appropriate error message instead of producing bad data which cannot be decompressed.</p>
<h1>Divide rounding up</h1>
<p>A couple of times there is a construction like <code>(n &gt;&gt; 3) + !!(n &amp; 0x7)</code>. There is a simpler way: <code>(n + 7) / 8</code>, or if you prefer, <code>(n + 7) &gt;&gt; 3</code>.</p>
<h1>Header size</h1>
<p>Similar as in the previous review: if <a href="https://en.wikipedia.org/wiki/Canonical_Huffman_code" rel="nofollow noreferrer">canonical Huffman codes</a> were used, the header would not need to store the codes (as they can be reconstructed from the lengths and the implicit alphabetical order of the symbols), saving space. The sequence of lengths could be further compressed.</p>
    </div>