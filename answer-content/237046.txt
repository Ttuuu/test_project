<div class="s-prose s-prose__disable-spoiler-hover js-post-body" itemprop="text">
<p>Regarding time complexity, since your algorithm traverses the entire matrix once, it is working at <em>O(n)</em>.  this means the performance is affected in direct proportion to the size of the input (the matrix in this case). it is expected that a matrix with double the size (meaning four times the cell count) will perform 4 times worse than the original, and so forth.</p>

<p>Regarding space complexity, the algorithm allocates a new matrix the same size as the original. this also means that space requirements relate in direct proportion to the size of input. Here I have an improvement suggestion: the transformation can easily be done "in place" by iterating over half the matrix (triangular half, bordered by the diagonal) and swapping values of two cells. it also bares a small performance improvement - you need not touch the cells on the diagonal itself.</p>
    </div>