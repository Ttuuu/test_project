<div class="s-prose s-prose__disable-spoiler-hover js-post-body" itemprop="text">
<p>The idiomatic <code>TryParse</code> signature is <code>public bool TryParse(string input, out T result)</code>. It should never throw; that's what regular <code>Parse</code> is for. Return <code>true</code> if it succeeds and <code>false</code> otherwise, with <code>result</code> being set to the parsed value or <code>default</code> respectively. If you really do want to distinguish between the cases "there exists a converter but the string simply couldn't be parsed" and "there doesn't even exist a converter for that type", then I suppose you can keep those exceptions, but I'd still like to see some way of indicating whether or not the parse succeeded given there exists a parser for that type. null is not a particularly strong indicator since it's conceivable that someone might want to encode null in their CSV file.</p>
<p>XML documentation is a good habit to get into so I'm glad to see that. I would add a note to the docs for <code>ReadLine</code> indicating that it'll return <code>default(TRow)</code> when it hits the end of the text reader.</p>
<p>Which brings me to something that sticks out, and that's the end-of-text-reader condition: your mechanism for that is to return the default value of <code>TRow</code> from <code>ReadLine</code>. What happens if <code>TRow</code> is a value type and I happen to read a line that's intended to populate an instance of <code>TRow</code> with default values? For example, if <code>TRow</code> is <code>Point</code> and my CSV line is <code>0,0</code>, it looks like the parser enumerator will end prematurely. Perhaps <code>ReadLine</code> should return a flag indicating whether something was actually read or not. Or maybe define a <code>TryReadLine</code> in the same manner as <code>TryParse</code> which returns a bool indicating whether it worked.</p>
<p>You will never need to instantiate <code>Parsers</code> so it should be a <code>static class</code> instead of a <code>readonly struct</code>.</p>
<p>If you're not using the new C# 8.0 nullable references, then you should be throwing <code>ArgumentNullException</code>s in the Parser constructor if any of those parameters are null.</p>
<p><code>_headers</code> can be null but you're not checking for null anywhere; although I suppose you can reason that it will always be non-null in the parts where it's actually used, in which case I'd document that with an assertion.</p>
<p>You will read a lot of wisdom saying that premature optimization is the root of all evil, but here is a case where it's possibly warranted:</p>
<pre><code>foreach (var prop in typeof(TRow).GetProperties().Where(p =&gt; p.CanWrite))
</code></pre>
<p>Reflection is super slow and the properties associated with <code>TRow</code> will not change during runtime, so you can cache the result of <code>typeof(TRow).GetProperties()</code>. Likewise for <code>prop.GetCustomAttribute&lt;PropertyNameAttribute&gt;()</code>. It's up to you/your stakeholders whether your current solution is fast enough. If it isn't, look into caching those things.</p>
    </div>