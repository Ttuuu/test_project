<div class="s-prose s-prose__disable-spoiler-hover js-post-body" itemprop="text">
<p>The C++ side seems covered, so in this answer I take more of a linear algebra angle.</p>

<p>The algorithms used for the determinant is not practical for matrixes that are not small. Cofactor expansion works fine with small matrixes and it is a useful mathematical definition, but its computational expense scales as the factorial of the matrix size, which quickly grows to unreasonable levels.</p>

<p>There are some other options. You could implement triangular factorization (eg LUP), after which the determinant can be found by multiplying the diagonal elements. The cost of this approach scales only as the cube of the matrix size, though it involves divisions which makes it not so efficient for small matrixes where such overhead still dominates. The divisions also mean that it only works with <code>T</code> being <code>float</code> or <code>double</code>, there are some techniques that do work for integers but they are probably out of scope for a <a href="/questions/tagged/beginner" class="post-tag" title="show questions tagged 'beginner'" rel="tag">beginner</a> question. To counter these disadvantages you could keep cofactor expansion as well, and apply the best algorithm for the case depending on <code>T</code> and the matrix dimensions (this seems like a nice place to apply some template magic).</p>

<p>Triangular factorization can also be used to efficiently solve equations of the form Ax=b, and therefore also to find the explicit inverse of A by solving for all the basis vectors, though most commonly this wouldn't be needed since the purpose of the inverse would typically be to solve such equations in the first place.</p>
    </div>