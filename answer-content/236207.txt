<div class="s-prose s-prose__disable-spoiler-hover js-post-body" itemprop="text">
<p><em>(Too long for a comment, not really a code review)</em></p>

<p>I've seen the <a href="https://www.youtube.com/watch?v=kPR8h4-qZdk" rel="nofollow noreferrer">Facebook presentation about their custom <code>fbstring</code> class</a> used as a motivation for people writing their own string classes. However people seem to conveniently miss the part that even at Facebook where arguably they do a lot more string processing than the average Joe Programmer, the performance gain over using non SSO optimised <code>std::string</code> in GCC &lt; 5.0 is <strong>only 1%</strong> of their total CPU time. </p>

<p>The video also clearly states that they have no benchmarks (at time of filming) about if their <code>fbstring</code> class is any better than then new SSO <code>std::string</code> in GCC &gt;= 5.0, and that it is a non trivial engineering effort to maintain the string class. And their use case is also pathological for the new standard string as their most commonly stored string is a 20 byte UUID which fits in the SSO of <code>fbstring</code> but not in <code>std::string</code> of GCC &gt;= 5.0, at least for compilers they talk about in the presentation. I don't know about clang or the latest and greatest from GCC.</p>

<p><em>I want to emphasise the above, it's a non trivial engineering effort for a large, multinational, tech company with large amounts of engineering resources to maintain having their custom string class. And the gains over standard string in modern compilers is unclear from the presentation.</em></p>

<p>Yes, I know CPU cache utilisation and memory layout benefit from a smaller data structure. Yes this is true, but the impact to your overall runtime may still be low if you don't actually miss the accesses in the cache. If your access pattern is bad and you make the cache prefetcher sad and the majority time of your program is spent working these strings in a random fashion, then you can gain some performance by having more of your strings in the cache, but you can likely gain a larger improvement by fixing your access patterns instead.</p>

<p>You are also making interoperability with other libraries that typically use <code>std::string</code> harder and you will incur string copy penalties when converting between them in addition to the extra code complexity. And you will miss out on improvements to the standard string with new versions of the standard library.</p>

<p>What I'm trying to say is, unless you have clear benchmark data that indicates that writing your own micro optimised string class actually has a measurable and appreciable macro level performance impact on your application that is worth the engineering effort in developing and long term maintaining the use of this string class, your efforts would probably be better spent fixing bugs, adding features or optimising some other part of the application where the ROI will be higher.</p>

<p>The original post as written does not have any benchmarks (macro or micro) or other raw data to support the claim that this class makes a significant impact to the total program runtime/performance, but rather seems to argue that "FB did it so I should do it as well" and "it's smaller, so it's gotta be faster!". Remember that Facebook only got 1% improvement, which is basically indistinguishable from measurement noise except when your data set is massive, and 1% of a hundred million of dollars is still a million dollar less in utility cost in Facebook's case (or whatever their DCs cost to run). Does a 1% gain make sense in your application?</p>

<p>At the end of the day, I'm a sign, not a cop, and I'm not here to tell you what to do or how to code. I'm a just a friendly neighbourhood engineer, pointing out that it might be worth reconsidering if this is the best way to spend your effort; and stop to think about if you're building yourself a future headache and if it'll be worth it.</p>
    </div>