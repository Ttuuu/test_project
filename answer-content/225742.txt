<div class="s-prose s-prose__disable-spoiler-hover js-post-body" itemprop="text">
<p>I can only give you some general tips; I'm afraid Unity is outside my expertise.</p>

<ul>
<li><p>I would consider redefining what <code>renderDistance</code> means. Currently it seems like a diameter; the rendered terrain consists of renderDistance<sup>2</sup> chunks. What that means in practice is that every time you reference renderDistance, you divide it by 2. What happens if it is odd? It may be easier to treat this value as a radius instead (and just use values that are about twice as large).</p></li>
<li><p>You have a list of <code>expectedGridChunkPositions</code>, and it's not clear to me why it exists. It may just be that I'm not understanding the work done in the latter third of <code>UpdateChunkPositions</code>. What is troubling is that you have a lookup on this list (<code>expectedChunkGridPositions.Contains</code>). I doubt that your performance problems are coming from this alone... but if it's not possible to remove this List, you might consider changed it to a HashSet.</p></li>
<li><p>The latter two thirds of <code>UpdateChunkPositions</code> could be combined, in fact. You spend one foreach-loop building up <code>positionsWithOldChunks</code>, just to iterate through it and do work in another for-loop. Why not do the work right away?</p></li>
<li><p>It's possible that, as you examine the behavior of your game more closely, you will find opportunities for broad optimizations, and you will be able to keep the game running smoothly on a single thread. I recommend<sup>1</sup> that you treat multithreading as a last resort, due to the inherent complexity increase it will cause in your code. You may find <a href="https://docs.microsoft.com/en-us/visualstudio/profiling/profiling-feature-tour?view=vs-2019" rel="nofollow noreferrer">Visual Studio's performance analysis tooling</a> very helpful here, especially its capability to show which functions are consuming the most resources.</p></li>
<li><p>It's also possible that, as the player crosses a chunk boundary, there's just too much terrain generation work to handle in the next dozen milliseconds, and lag will be unavoidable. In that case, good luck with your multithreading adventure. One thing you'll want to avoid as you explore that space is the use of Systems.Collections.Generic for anything that might be shared across threads. Instead, you'll need to use specialized collections like <code>ConcurrentDictionary</code> and <code>ConcurrentBag</code>, which have very handy functions with built-in locking mechanisms (such as <code>GetOrAdd</code>, and <code>AddOrUpdate</code>).</p></li>
</ul>

<p><sup>1</sup>On the other hand, I've never programmed a game before. Maybe multithreading is considered a best practice for Unity3d games? If so, then my recommendation isn't worth much.</p>
    </div>