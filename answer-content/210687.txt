<div class="s-prose s-prose__disable-spoiler-hover js-post-body" itemprop="text">
<p>It would be nice to pass a size with the buffer, so we can check the size of the type vs the size of the buffer. Also, a pointer to <code>unsigned char</code> or <a href="https://en.cppreference.com/w/cpp/types/byte" rel="nofollow noreferrer"><code>std::byte</code></a> would be better than a <code>void*</code>.</p>

<p>I think using <a href="https://en.cppreference.com/w/cpp/language/reinterpret_cast" rel="nofollow noreferrer"><code>reinterpret_cast</code></a> like this is undefined behaviour. We can copy the object representation (by <code>reinterpret_cast</code>ing to <code>char</code> or <code>unsigned char</code> and copying manually, or using <code>std::memcpy</code>). However, the object may have alignment requirements or padding that aren't observable in this representation.</p>

<p>Since the character array was created as a character array, it doesn't have the necessary alignment / padding, so using it directly as if it were the object is undefined behaviour. We have to use <code>std::memcpy</code> to copy the bytes back into memory that was actually allocated as the object in question.</p>

<p>Note that <a href="https://en.cppreference.com/w/cpp/string/byte/memcpy" rel="nofollow noreferrer"><code>std::memcpy</code> has requirements of its own</a>. Specifically that types be <a href="https://en.cppreference.com/w/cpp/named_req/TriviallyCopyable" rel="nofollow noreferrer"><code>TriviallyCopyable</code></a>, so constructors with side-effects will not work. It would be good to check this when serializing the object with a <code>static_assert(is_trivially_copyable_v&lt;T&gt;, "...")</code>.</p>
    </div>