<div class="s-prose s-prose__disable-spoiler-hover js-post-body" itemprop="text">
<p>You should make sure to follow the <a href="https://en.cppreference.com/w/cpp/language/rule_of_three" rel="nofollow noreferrer">rule of three/five/zero</a>.</p>
<p>In your case we have a user defined destructor, which clears the list by deleting all nodes.  Problems arise now when you make a copy of a list:</p>
<pre class="lang-cpp prettyprint-override"><code>LincedList&lt;int&gt; one(1,2);
LincedList&lt;int&gt; two(one); // a copy?
</code></pre>
<p>When that scope ends, <em>both</em> lists try to delete the same nodes; resulting in "double free" and thus undefined behavior. (<a href="https://ideone.com/gH9QMW" rel="nofollow noreferrer">example on ideone</a>)</p>
<p>Therefore you should provide a user defined copy constructor and a user defined copy assignment operator with a suitable implementation.  A suitable implementation could be to create copies of all nodes.  A suitable implementation could also be to disallow copies of lists being made (by <a href="https://stackoverflow.com/q/5513881/1116364">deleting</a> the copy constructor and copy assignment operator).  If your lists can be copied, then it makes probably sense to allow list (contents) to be also <em>moved</em> from one list to the other; reducing the needs for copies.  Therefore you should then also implement a user defined move constructor and a user defined move assignment operator.</p>
<p>Or, to follow the rule of zero, you could also use <a href="https://en.cppreference.com/w/cpp/memory/unique_ptr" rel="nofollow noreferrer"><code>std::unique_ptr&lt;Node&gt;</code> </a>instead of a raw pointer to the head of the node as well as <code>std::unique_ptr&lt;Node&gt;</code> instead of a raw pointers to the next nodes.  Then memory would be taken care of itself (no need to write a destructor!) and copies would be disallowed.</p>
    </div>