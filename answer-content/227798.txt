<div class="s-prose s-prose__disable-spoiler-hover js-post-body" itemprop="text">
<p>Disclaimer: I haven't done authentication in Flask before.</p>

<p>Tl;dr: Don't do authentication yourself, it's VERY hard to do right (and using a global ain't right); also, separate the user's authentication from their key store: the former you should ONLY be able to verify, not decode, and the latter should be inaccessible to your server without some secret information from the user.</p>

<p>Your code example is fairly long and I'm not terribly experienced with Flask, so I won't provide a robust judgement of the whole thing, though I will give you the compliment that your code was fairly easy to read and follow, with excellent docstrings, good modularization, and following general good practices... except that you use global variables, which is the death knell for this entire server. The user's identity should be pulled from the session, not stored in a global variable. As it is, only one user can be logged in a time, and if I log in first, then you log in second, then I can potentially see all of your passwords.</p>

<p>Here are some code-related suggestions, before I dive into how a password manager, as an entire application, should probably function:</p>

<ol>
<li><p>Use standard packages for standard tasks, particularly authentication.</p></li>
<li><p>Avoid globals. The only exception, <em>maybe</em>, is you can have a config.py with non-secret constants. Otherwise, these are more likely to get you into trouble when your server starts running in multiple threads or processes, and state management becomes an issue.</p></li>
<li><p>Don't be afraid to store things in a database. DB's are essential to just about every web app, and are very secure and very very fast. Getting familiar with using them is a basic necessity as you move forward with building bigger web apps.</p></li>
<li><p>Load secure keys from files or environment variables, don't hard-code them. If you use files, they should be explicitly excluded from source control, so that someone with access to your source code won't also have access to your data.</p></li>
<li><p>The fact that your "encrypt" and "decrypt" functions don't take keys as arguments should be indicative that you're doing something wrong. If the external code doesn't need to know anything secret about a data blob in order to access it, then why is it encrypted at all? If all you care about is encryption at-rest on-disk, there are better ways to do that (encrypted file systems, secure databases, password-protected zip files, etc.) where you don't need to manage, and thus perhaps introduce vulnerabilities into, the encryption/decryption process yourself.</p></li>
</ol>

<p>As a philosophical suggestion, a robust password manager should probably 1) authenticate the user using standard best practices, then 2) provide an opaque blob to the client, who can then decrypt the data locally using some secret key of their own (maybe the same password they used to log in to the server). Ideally, at no point should the server be capable of accessing the user's secrets, and thus be capable of leaking them to internal or external threats.</p>

<p>For #1, you <em>need</em> to look into using a standard Flask authentication package, which will probably leverage a database of some sort. This database should be protected using usual means (password-protected, and only be accessible from the web server), and it should only store password hashes, no cleartext passwords. If you find a good authentication package, it'll do this for you. I know Django comes with robust authentication built-in (including session management, password hashing, etc.), so I'm sure something comparable exists for Flask. Do not build stuff like this from scratch, it's a big hassle/waste of time, makes your code messy, and will result in your application being riddled with security vulnerabilities.</p>

<p>For #2, this becomes tricky to do in a static website (hence why the most secure password managers usually involve a client-side browser plugin or other OS-installed component). It is possible using a little javascript embedded in the HTML page you return to the user, with some degree of security. You could pass the encrypted password store (binary data can be sent/stored in JSON using base64 encoding), then have the user re-enter their password client-side and have the javascript locally decrypt the blob and present its contents somehow. To update the data, just do so in-browser (don't send anything in cleartext to the server) and have the javascript re-package the blob, encrypt it, and send that encrypted blob back to the server. So long as the encryption library you use (and there are plenty of options) is implemented correctly, the password blob will be as safe as the algorithm and keysize you use (e.g., AES 256). This way, there's absolutely no way the server could reveal one user's secrets to another, since the server is never given the ability to decrypt any user's secrets, only authenticate them and given them their encrypted data blob.</p>

<p>Even if you're just building this as a toy to learn Python/Flask and don't actually care about making a decent password manager, you should still encrypt the user's data blob using some piece of information unique to that user that's stored somewhere secure (e.g. in the database). E.g., when they POST their password, use it to authenticate them first, then if that succeeds, use it to decrypt some random gibberish that you've stored in the User table of your database which is their unique key to their password store, and store that key in their session data (either in a cookie or in a session table in the database). When their session ends, the server becomes incapable of accessing the user's password store again and everything returns to being secure.</p>
    </div>