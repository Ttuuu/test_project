<div class="s-prose s-prose__disable-spoiler-hover js-post-body" itemprop="text">
<p>None of your <code>QUEUE_*</code> functions validate their input arguments before using them.  <code>NULL</code> pointers will be a problem, particularly for the pointer-to-pointer arguments.</p>

<p>C's memory-allocation functions return a <code>void*</code>, which implicitly converts to any other pointer type.  This means that you don't need to typecast the result of <code>calloc</code>.  Doing so can actually mask certain errors that the compiler would otherwise catch.</p>

<p>Your <code>node_t</code> structure is missing a vital piece of information: the size of the target object.  This would be okay if your queue dealt purely with pointers.  In several places, though, you access the actual data behind that pointer.  Without knowing the size of that data, you're opening up yourself to tons of buffer overrun problems.  For example, if I queue a char and then call <code>QUEUE_peek()</code> with a size of 1 MB, bad things happen.  Trusting the caller to keep track of this is problematic.  First and foremost, you shouldn't trust the user to do the right thing.  More importantly, requiring a second queue to keep track of object sizes in the first queue makes your implementation difficult to use.  You have two options for resolving this.  If the queue will only hold objects of the same type, replace <code>void* data</code> with a pointer to a specific type (clever macros can even make this type user-configurable like a C++ template).  The other option is to add a <code>size_t size</code> member to <code>struct node</code>.  If you go with the latter, you'll need to either re-design <code>peek</code>/<code>dequeue</code> to allocate the output buffer internally, or add a function that returns the size of the object at the head of the queue.</p>

<p>Your code is very vulnerable to what I sometimes call the "nosy user".  That is, a user that pokes around at the internals of your implementation.  If a user decides to alter the value of a queue's <code>size</code> member (either through malice or incompetence), your code will break in a number of places.  I recommend hiding the implementation details from the user.  The easiest way to do this would be to move the definitions of <code>struct queue</code> and <code>struct node</code> into the .c file.  Then, add the line <code>struct queue;</code> to the top of the header (a forward declaration).  This allows the user to create pointers to queue objects - which is all they need in order to use your API - but doesn't let them poke about at the internals.  This is similar to how <code>stdio.h</code> implements the <code>FILE</code> type.  Side note: nice work on the clean API that only requires the user to know about a single pointer type.  Most first passes leak a lot more implementation details than that.</p>

<p>Expanding on what ratchet freak mentioned above, your API is asymmetrical.  You enqueue a <em>pointer</em> to an object, but you dequeue a <em>copy</em> of the <em>content</em> of the object.  This can cause problems when you queue objects that have been dynamically allocated.  Once you dequeue that object and want to free it, you have no real way of figuring out the original pointer so that you can pass it to <code>free()</code>.  If the dequeue function returned the pointer instead, the caller would have all of the information they'd need.</p>

<p>Having enqueue/dequeue only deal in pointers would avoid another problem as well.  The current dequeue implementation makes a complete copy of the queued object, which can have <em>severe</em> performance penalties.  Using large objects with your queue would lead to a lot of memory churn plus a lot of time wasted copying bits unnecessarily.  Users could always queue pointers to these objects instead of the objects themselves, but that's more of a workaround than a solution.</p>

<p>Portability issues:</p>

<p>The POSIX standard reserves typenames that end in <code>_t</code>.  For the sake of portability, it's best if you avoid using that suffix on your custom types.  The risk of name collisions is particularly high when you have basic, generic names like <code>queue_t</code> and <code>node_t</code>.</p>

<p><code>#pragma once</code> is not standard C.  It's a relatively common extension but if you want to ensure that your code works with any compiler/platform, use a traditional <code>#define</code>-based include guard instead.</p>

<p>Minor things:</p>

<p>In general, I usually advise to avoid typedef-ing struct types.  It hides the fact that what you're dealing with are actually structures.  Plus, you now have two names for the same type (<code>struct node</code> and <code>node_t</code>), which can cause confusion and make refactoring more difficult.  There are even some contexts (like forward declarations) where you can use the <code>struct</code> name but the <code>typedef</code>-ed name won't work.</p>

<p>I can see where the name for <code>queue-&gt;size</code> could be confusing.  "Size" generally refers to how much storage space something takes.  A name like "count" or "length" could make it more obvious what this field measures.</p>
    </div>