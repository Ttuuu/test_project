<div class="s-prose s-prose__disable-spoiler-hover js-post-body" itemprop="text">
<p>Here are some things that may help you improve your code.</p>

<h2>Use appropriate <code>#include</code>s</h2>

<p>The code refers to a number of things, such as <code>std::size_t</code> and <code>std::swap</code> which do not have the corresponding <code>#include</code>s.  The code should have the following:</p>

<pre><code>#include &lt;cstddef&gt;
#include &lt;utility&gt;
#include &lt;stdexcept&gt;
</code></pre>

<h2>Don't define the default constructor</h2>

<p>The default constructor for the <code>Deque</code> does nothing except for initializing members.  Instead, you should use in-class member initializers and let the constructor be generated by the compiler as you have with <code>Node</code>.  See <a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rc-default" rel="nofollow noreferrer">CppCoreGuidelines C.45</a>.</p>

<h2>Don't use leading underscores in names</h2>

<p>Anything with a leading underscore is a <em>reserved name</em> in C++ (and in C).  See <a href="http://stackoverflow.com/questions/228783/what-are-the-rules-about-using-an-underscore-in-a-c-identifier">this question</a> for details.  In this case it applies to your chosen name for the include guard.</p>

<h2>Simplify your code</h2>

<p>The code for <code>push_back</code> and <code>push_front</code> and a number of other functions can be simplified considerably. In the case of <code>push_back</code>, for example, by using the autogenerated constructor for <code>Node</code>:</p>

<pre><code>template &lt;typename Type&gt;
void Deque&lt;Type&gt;::push_back(const Type &amp; tp)
{
    if (tail) {
        tail = tail-&gt;next = new Node{tp, tail, nullptr};
    } else {
        head = tail = new Node{tp, nullptr, nullptr};
    }
    ++count;
}
</code></pre>

<h2>Fix the error messages</h2>

<p>Some of the error messages don't seem to match what they're signalling very well.  For example, if we attempt to use <code>back()</code> on an empty <code>Deque</code>, it says</p>

<pre><code>throw std::out_of_range("List&lt;Type&gt;::top: empty stack");
</code></pre>

<p>This would be a very confusing and unhelpful error message!</p>

<h2>Use your own functions</h2>

<p>In some cases, the code uses <code>count</code> to determine when the deque is empty, in others it checks if <code>head == nullptr</code> and still others it uses <code>empty()</code>.  I'd recommend choosing one mechanism and using it exclusively.  Likewise, if you use your own functions, the <code>copy</code> could be as simple as this:</p>

<pre><code>template &lt;typename Type&gt;
Deque&lt;Type&gt;::Deque(const Deque &amp; deq) {
    for (auto curr = deq.head; curr; curr = curr-&gt;next) {
        push_back(curr-&gt;element);
    }
}
</code></pre>

<h2>Consider supporting list initialization</h2>

<p>At the moment, a construction like this is not supported:</p>

<pre><code>Deque&lt;std::string&gt; d3{"alpha", "beta", "gamma"};
</code></pre>

<p>It's easy to do, however.  Here's how I'd do it:</p>

<pre><code>template &lt;typename Type&gt;
Deque&lt;Type&gt;::Deque(std::initializer_list&lt;Type&gt; list) {
    for (auto&amp; item : list) {
        push_back(item);
    }
}
</code></pre>
    </div>