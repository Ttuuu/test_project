<div class="s-prose s-prose__disable-spoiler-hover js-post-body" itemprop="text">
<p>It is good to see cstdlib, EXIT_SUCCESS and EXIT_FAILURE in use. This is a very interesting concept with some good ideas. I admire your tenacity because it really must have been difficult to debug with all the functions in the headers.</p>

<p>It might be good to have a Installshield setup or some other mechanism to install the source code as well as the <code>cryptopp810</code> header files.</p>

<blockquote>
  <p>Would using this library as directed provide the guarantees expected of a blind signature protocol?</p>
</blockquote>

<p>I may not be able to provide a security audit, this review is based primarily on the code itself.</p>

<p>This is a set of binaries, where is the library? I would expect to see a shared library generated by the make file. I would also expect to see the header files contain only function prototypes or classes and not the functions themselves. Including the function bodies in the header file makes the project more difficult to maintain. It means that any time a bug is fixed or code changes then everything that includes the header file needs to recompile. Creating a shared library would be better because the library interfaces would stay constant and the user code would not have to rebuild, only re-link. The current implementation could lead to multiple definitions of functions at link time.</p>

<p>It might also be possible to eliminate the inclusion and use of the <code>cryptopp810</code> header files and the <code>using namespace CryptoPP;</code> from the end users code if the library is implemented as a shared library rather than a header file. This would decrease compile/build times for the end user. </p>

<p>Embedding the <code>cryptopp810</code> header files in the user space prevents the user from upgrading to newer libraries.</p>

<p>If the code continues to be in the header file it might be better to adopt the <code>Boost Library filename.hpp</code> extensions instead of <code>.h</code>. </p>

<p>I'm curious as to why the library wasn't implemented in a class for encapsulate and data hiding reasons.</p>

<p><strong>The use of Macros as Constants in C++</strong><br>
C++ provides the <code>const</code> or <code>constexpr</code> to create symbolic constants, the use of <code>#define</code> is really the C programming language and is generally avoided because it is not type safe. The <code>const</code> symbolic constants have a type and can be checked at compile time. This <a href="https://stackoverflow.com/questions/1637332/static-const-vs-define">stackoverflow question</a> may provide more background.
Using #ifdef and #define within header files to prevent repeated includes is still an accepted practice.</p>

<p><strong>The try/catch Blocks</strong><br>
It might be better to include all of the successful code in the <code>try</code> block. The code is a little confusing the way it is implemented now.</p>

<p>Instead of</p>

<pre><code>    try{
        message = argv[1];
        client_secret = Integer(argv[2]);
        public_key = ReadPEMPublicKey(argv[3]);
    }
    catch(std::runtime_error&amp; e)
    {
        std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;
        return EXIT_FAILURE;
    }

    Integer hashed_message = GenerateHash(message);
    Integer hidden_message = MessageBlinding(hashed_message, public_key, client_secret);

    std::cout &lt;&lt; std::hex &lt;&lt; hidden_message &lt;&lt; std::endl;
    return EXIT_SUCCESS;
</code></pre>

<p>This might be better, as it provides a continuos flow of the code.</p>

<pre><code>    try{
        message = argv[1];
        client_secret = Integer(argv[2]);
        public_key = ReadPEMPublicKey(argv[3]);
        Integer hashed_message = GenerateHash(message);
        Integer hidden_message = MessageBlinding(hashed_message, public_key, client_secret);

        std::cout &lt;&lt; std::hex &lt;&lt; hidden_message &lt;&lt; std::endl;
        return EXIT_SUCCESS;
    }
    catch(std::runtime_error&amp; e)
    {
        std::cerr &lt;&lt; e.what() &lt;&lt; std::endl;
        return EXIT_FAILURE;
    }
</code></pre>

<p>If this alternate method is used then the declarations for current global variables could be moved into the try block. Even in the current implementation the global variables should be declared as local variables in <code>main()</code>.</p>

<p><strong>Complexity</strong><br>
While the Single Responsibility Principle is primarily an object oriented it can and should be applied to functional programs as well. <a href="https://en.wikipedia.org/wiki/Single_responsibility_principle" rel="noreferrer">The Single Responsibility Principle states</a>:</p>

<blockquote>
  <p>every module, class, or function should have responsibility over a single part of the functionality provided by the software...</p>
</blockquote>

<p>The function <code>void PEM_NextObject(BufferedTransformation&amp; src, BufferedTransformation&amp; dest)</code> is overly complex and could be broken up into multiple functions. </p>

<p>The <code>PEM</code> code is also a good candidate for being turned into an object. Most of the <code>PEM</code> functions could be private functions in the class.    </p>
    </div>